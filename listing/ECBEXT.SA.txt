PAGE  001  ECBCOM  .SA:0  EXTEND Extension ROM Direct Page RAM

00700                             OPT    L,LLE=120
00701                             NAM    EXTEND   - Extended Features for TCC / MLC
00702
00703                      **********************************************************************
00704                      *                                                                    *
00705                      *    Copyright 1982 by Microsoft Corporation, all rights reserved    *
00706                      *                                                                    *
00707                      **********************************************************************
00708
00709                             TTL    External Declarations
00710
00711                             XREF   ASC2
00712                             XREF   BASRST,BLKOUT,BLTU,BUF
00713                             XREF   CASOFF,CHEAD,CHEADA,CHKCLS,CHKCOM,CHKNUM,CHKOPN,CHKSTR,CHROUT
00714                             XREF   CIRCLE,CLEARC,CLOATK,COLORS,COMBYT,CONDCR,CONINT,COPLOP
00715                             XREF   CRDO,CSAVE,CSAVTK
00716                             XREF   DATA,DCRNCH,DEVPRM,DLOAD,DOFDSP,DOSDSP,DRAW
00717                             XREF   EDTENT,ELSETK,ENDCON,EOFFIN,EOFWRT,EQULTK
00718                             XREF   ERPRNT,ERRID,ERROR,ERRUF,EVLADR
00719                             XREF   FADD,FCERR,FDIV,FHALF,FINIT
00720                             XREF   FINLOG,FINSAV,FMULT,FNDLIN,FNTK,FONE
00721                             XREF   FOUT,FOUTCP,FPWRT,FREFAC,FRESTR,FRETMP,FRMEVL
00722                             XREF   FRMNUM,FSUB,FUNDS1
00723                             XREF   GET,GETADR,GETBYT,GETDNM,GETFLN,GETSPA
00724                             XREF   GIVABF,GOGONE,GONE3,GOPTNW,GOTK
00725                             XREF   HKASGN,HKCHRI,HKCHRO,HKCLS1,HKCRNC,HKERR,HKEVAL
00726                             XREF   HKNWST,HKRENM,HKRUN
00727                             XREF   INCHR,INIT,INLNDO,INPCOM,INPRT,INT,ISCNTC,ISDIGC,ISLETC
00728                             XREF   LET,LINE,LINGET,LINPRT,LOADAD,LOFBUF
00729                             XREF   MID$TK,MINUTK,ML1632,MLDVEX,MOVAF,MOV1F,MOVFA1,MOVFM
00730                             XREF   MOVINS,MOVMF,MULDIV
00731                             XREF   NEGOP,NORMAL
00732                             XREF   OPNICK,OPNCSO,OPNOCK,OUTQST,OUTSPC,OVERR
007,Z                             XREF   PAINT,PARCHK,PCLEAR,PCLS,PCOPY,PIA0BC,PIA0BD,PIA1BD
00734                             XREF   PINIT,PLAY,PLYCLK,PMODE
00735                             XREF   POLY,POLYX,PPOINT,PRESET,PSET,PTRGET,PTRGT2,PUT
00736                             XREF   READY,RUNC
00737                             XREF   SAM,SAMALP,SCREEN,SCRTCH,SETDNM,SIGN,SIN,SIN1,SNDOFF,SNERR
00738                             XREF   SNGFLT,STRLTI,STRSPA,STRTAD,STKINI,STMDS1
00739                             XREF   STRLT3,STROUT,STRPRT,STRTXT,STUB1,SUBTK,SYNCHR
00740                             XREF   THENTK,TICKER,TOTK,TRMCHK
00741                             XREF   ULERR,USRTAB,USRTK
00742                             XREF   VIRQ
00743                             XREF   WRTLDR
00744                             XREF   ZEROF1
00745
00746                             TTL    Miscellanous Routines
00747
00748                      *
00749                      * The RUN code comes here to set up the defaults for the PLAY
00750                      * and DRAW code.  The initialization code also comes here for
00751                      * the same reason.
00752                      *
00753
00754                             XDEF   XRRUN
00755P 0000 CC   B844    A XRRUN  LDD    #$B844   Init the PLAY arguments.
00756P 0003 DD   DF      A        STD    HIGHA    Set volume to 15 decimal.
00757P 0005 86   02      A        LDA    #&2      Set tempo to 2.

PAGE  002  ECBEXT  .SA:1  EXTEND Miscellanous Routines

00758P 0007 97   E2      A        STA    TEMPO
00759P 0009 97   DE      A        STA    OCTAVE   Select middle C octave.
00760P 000B 48                    ASLA            Set to undotted quarter notes.
00761P 000C 97   E1      A        STA    LNOTE
00762P 000E 0F   E5      A        CLR    DOTFLG
00763P 0010 DC   8A      A        LDD    DBLZER   Init the DRAW arguments.
00764P 0012 DD   E8      A        STD    DRWANG   Set angle and scale to zero.
00765P 0014 C6   80      A        LDB    #&128    Position to the middle.  (128,96) 
00766P 0016 DD   C7      A        STD    LSAVEX
00767P 0018 C6   60      A        LDB    #&96
00768P 001A DD   C9      A        STD    LSAVEY
00769P 001C 39             RUNRTS RTS             Return to RUN or initialization code.
00770
00771                             TTL    CSAVEM Code
00772
00773                      *
00774                      * CSAVEM <filename>,<first address>,<last address>,<execution address>
00775                      *
00776
00777                             XDEF   CSAVEM
00778P 001D 9D   9F      A CSAVEM JSR    CHRGET   Eat the "M" of CSAVEM.
00779P 001F BD   0000    A        JSR    GETFLN   Scan the filename.
00780P 0022 8D   43   0067        BSR    STKXAD   Evaluate the first address.
00781P 0024 BF   0000    A        STX    LOADAD   Put it in the file header too.
00782P 0027 8D   3E   0067        BSR    STKXAD   Evaluate the last address.
00783P 0029 AC   62      A        CMPX   &2,S     Is last .GE. first?
00784P 002B 1025 FFD1    A        LBLO   FCERR    No, give FC error.
00785P 002F 8D   36   0067        BSR    STKXAD   Yes, evaluate the execution address
00786P 0031 BF   0000    A        STX    STRTAD   and put it in the file header block.
00787P 0034 9D   A5      A        JSR    CHRGOT   The statement must end now or we
00788P 0036 26   E4   001C        BNE    RUNRTS   to a RTS so NEWSTT will give a
00789                      *    syntax error.
00790P 0038 86   02      A CSMDOR LDA    #&2      File type is machine language.
00791P 003A 9E   8A      A        LDX    DBLZER   GAPFLG:=ASCFLG:=.FALSE.
00792P 003C BD   0000    A        JSR    OPNCSO   Open cassette output file.
00793P 003F 0F   78      A        CLR    CASOPN   Mark cassette as closed since
00794                      *    OPNCSO marked it as open.
00795P 0041 0C   7C      A        INC    BLKTYP   Set block type to data.
00796P 0043 BD   0000    A        JSR    WRTLDR   Turn on the cassette and write a
00797                      *    leader.
00798
00799P 0046 AE   64      A        LDX    &4,S     X:=first address.
00800P 0048 9F   7E      A CSAVML STX    CBUFAD   Set the buffer address to write the
00801                      *    next block out 
00802P 004A 86   FF      A        LDA    #&255    Assume it's a full block.
00803P 004C 97   7D      A        STA    BLKLEN
00804P 004E EC   62      A        LDD    &2,S     See how many more bytes to write.
00805P 0050 93   7E      A        SUBD   CBUFAD
00606P 0052 24   05   0059        BHS    MORSAV   There's more to save.
00807P 0054 32   66      A        LEAS   &6,S     Nothing more, clean up the stack
00808P 0056 7E   0000    A        JMP    FINSAV   and go close the file.
00809
00810P 0059 1083 00FF    A MORSAV CMPD   #&255    Is there a full block?
00811P 005D 24   03   0062        BHS    BIGBLK   Yes.
00812P 005F 5C                    INCB            No be sure to get the last byte.
00813P 0060 D7   7D      A        STB    BLKLEN   Set actual block length.
00814P 0062 BD   0000    A BIGBLK JSR    BLKOUT   Write out the block.
00815P 0065 20   E1   0048        BRA    CSAVML   Go back for more.

PAGE  003  ECBEXT  .SA:1  EXTEND CSAVEM Code

00816
00817                             XDEF   STKXAD
00818P 0067 BD   0000    A STKXAD JSR    CHKCOM   Eat the comma.
00819P 006A BD   0000    A        JSR    EVLADR   Evaluate address into X.
00820P 006D EE   E4      A        LDU    ,S       U:=return address.
00821P 006F AF   E4      A        STX    ,S       Stack the evaluated address.
00822P 0071 1F   35      A        TFR    U,PC     Return with evaluated address on
00823                      *    the stack and in X.
00824
00825                              TTL   The FIX function.
00826
00827                      *
00828                      * FIX(X) returns the truncated integer part of X.
00829                      * FIX(X) is equivalent to SGN(X)*INT(ABS(X)).
00830                      * FIX differs from INT in that FIX does not return the next lower
00831                      * integer for negative arguments.
00832                      *
00833
00834
00835                             XDEF   FIX
00336P 0073 BD   0000    A FIX    JSR    SIGN     Is the number positive?
00837P 0076 2B   03   007B        BMI    FIXNEG   No.
00838P 0078 7E   0000    A GOINT  JMP    INT      Yes, just do normal INT function.
00839
00840P 007B 03   54      A FIXNEG COM    FACSGN   Negate the argument.
00841P 007D 8D   F9   0078        BSR    GOINT    Take the INT.
00842P 007F 7E   0000    A        JMP    NEGOP    Restore the original sign and return.
00843                      *    (Can't COM FACSGN, RTS since 0
00844                      *    would become -0. For example,
00845                      *    ?FIX(-.1) would print -0.)
00846
00847                             TTL    The EDIT Command
00848
00849                             XDEF   EDIT
00850P 0082 BD   04BC    P EDIT   JSR    LINTRM   LINNUM:=number of line to EDIT.
00851                      *    (Line number must be terminated.)
00852P 0085 32   62      A        LEAS   &2,S     Get rid of the NEWSTT return address
00853                      *    since EDIT exits into the MAIN code.
00854P 0087 86   01      A EDITA  LDA    #&1      Set flag so line will be listed
00855P 0089 97   D8      A        STA    EDTLST   prior to starting the edit.
00856P 008B BD   0000    A        JSR    FNDLIN   X:=pointer to link field of line.
00857P 008E 1025 FF6E    A        LBCS   ULERR    If carry set then line doesn't exist.
00858P 0092 BD   0000    A        JSR    DCRNCH   Decrunch the line into BUF.
00859P 0095 1F   20      A        TFR    Y,D      Calculate and store the line length.
00860P 0097 83   0001    A        SUBD   #BUF+&1  (The zero byte terminator isn't
00861P 009A D7   D7      A        STB    EDTLEN   included in the length.)
00862
00863P 009C DC   2B      A EDTPLN LDD    LINNUM   Print the line number followed
00864P 009E BD   0000    A        JSR    LINPRT   by a space.
00865P 00A1 BD   0000    A        JSR    OUTSPC
00866P 00A4 8E   0000    A        LDX    #BUF     Point to the start of the line.
00667P 00A7 D6   D8      A        LDB    EDTLST   Should the line be listed?
00868P 00A9 26   25   00D0        BNE    ELSTIT   Yes, go do it
00869
00870P 00AB 5F             EDTSUB CLRB            Repetition count:=0.
00871P 00AC BD   01D6    P EDTREP JSR    EDITIN   Get char - screen out bad ones.
00872P 00AF BD   0000    A        JSR    ISDIGC   Is it a digit?
00877P 00B2 25   0B   00BF        BCS    EDNTDG   No.

PAGE  004  ECBEXT  .SA:1  EXTEND The EDIT Command

00874P 00B4 80   30      A        SUBA   #'0      Its a digit, get  rid of ASCII offset.
00875P 00B6 34   02      A        PSHS   A        Save the digit.
00876P 00B8 86   0A      A        LDA    #&10     Rep count:=rep count*10.
00877P 00BA 3D                    MUL
00878P 00BB EB   E0      A        ADDB   ,S+      Add in the new digit.
00879P 00BD 20   ED   00AC        BRA    EDTREP   Look for more digits.
00880
00881P 00BF C0   01      A EDNTDG SUBB   #&1      If REP COUNT=0 then REP COUNT:=1.
00882P 00C1 C9   01      A        ADCB   #&1
00883P 00C3 81   41      A        CMPA   #'A      EDIT again?
00884P 00C5 26   05   00CC        BNE    EDITL    No.
00885P 00C7 BD   0000    A        JSR    CRDO     Yes,  start new line
00886P 00CA 20   BB   0087        BRA    EDITA    and  restart edit.
00887
00888P 00CC 81   4C      A EDITL  CMPA   #'L      LIST AND CONTINUE EDIT?
00889P 00CE 26   0B   00DB        BNE    EDITCR   NO
00890P 00D0 8D   31   0103 ELSTIT BSR    EDTPRT   YES, PRINT REST OF LINE
00891P 00D2 0F   D8      A        CLR    EDTLST   CLEAR LIST FLAG
00892P 00D4 BD   0000    A        JSR    CRDO     START A NEW LINE
00893P 00D7 20   C3   009C        BRA    EDTPLN   CONTINUE EDIT AT START OF LINE
00894
00895P 00D9 32   62      A CRINS  LEAS   &2,S     GET RID OF EDTSUB RETURN ADDRESS
00896P 00DB 81   0D      A EDITCR CMPA   #CR      CARRIAGE RETURN, LIST AND FINISH EDIT?
00897P 00DD 26   0D   00EC        BNE    EDITE    NO
00898P 00DF 8D   22   0103        BSR    EDTPRT   YES, PRINT REST OF LINE
00899P 00E1 BD   0000    A EDTEND JSR    CRDO     START A NEW LINE
00900P 00E4 8E   0000    A AUTENT LDX    #BUF     SET TXTPTR FOR CRUNCH CODE
00901P 00E7 9F   A6      A        STX    TXTPTR
0090P  00E9 7E   0000    A        JMP    EDTENT   JUMP INTO "MAIN" CODE
00903
00904P 00EC 81   45      A EDITE  CMPA   #'E      END EDIT?
00905P 00EE 27   F1   00E1        BEQ    EDTEND   YES
00906P 00F0 81   51      A        CMPA   #'Q      ABORT EDIT?
00907P 00F2 26   06   00FA        BNE    NOTQ     NO
00908P 00F4 BD   0000    A        JSR    CRDO     YES, START NEW LINE
00909P 00F7 7E   0000    A        JMP    READY    AND ABORT EDIT
00910P 00FA 8D   02   00FE NOTQ   BSR    DOSUBC   ALL OTHER SUBCOMMANDS RETURN TO EDTSUB
00911P 00FC 20   AD   00AB        BRA    EDTSUB   TO GET NEXT SUBCOMMAND
00912
00913P 00FE 81   20      A DOSUBC CMPA   #'       MOVE CURSOR RIGHT?
00914P 0100 26   10   0112        BNE    EDITD    NO
00915P 0102                       SKIP2  JUST     PRINT [B] CHARS
00916                             XDEF   EDTPRT
00917P 0103 C6   F9      A EDTPRT LDB    #MAXLEN  PRINT REST OF CHARS ON LINE
00918P 0105 A6   84      A EPLOOP LDA    ,X       GET CURRENT CHAR
00919P 0107 27   08   0111        BEQ    EPRTFN   IF END OF LINE THEN RETURN
00920P 0109 BD   0000    A        JSR    CHROUT   PRINT THE CHAR
00921P 010C 30   01               INX             BUMP EDIT POSITION
00922P 010E 5A                    DECB            DECREMENT REP COUNT
00923P 010F 26   F4   0105        BNE    EPLOOP   REPEAT AS NECESSARY
00924P 0111 39             EPRTFN RTS
00925
00926P 0112 81   44      A EDITD  CMPA   #'D      DELETE CHARS?
00927P 0114 26   48   015E        BNE    EDITC    NO
00928P 0116 6D   84      A DELLP  TST    ,X       AT END OF LINE?
00929P 0118 27   F7   0111        BEQ    EPRTFN   YES, NOTHING MORE TO DELETE
00930P 011A 8D   04   0120        BSR    DELCHR   NO, DELETE CURRENT CHAR
00931P 011C 5A                    DECB            REPEAT AS INDICATED

PAGE  005  ECBEXT  .SA:1  EXTEND The EDIT Command

00932P 011D 26   F7   0116        BNE    DELLP
00933P 011F 39                    RTS
00934
00935P 0120 0A   D7      A DELCHR DEC    EDTLEN   DECREMENT LINE LENGTH
00936P 0122 31   1F      A        LEAY   -&1,Y    ADJUST POINTER FOR preincrement.
00937P 0124 31   21      A CMPRSS LEAY   &1,Y     POINT TO NEXT CHAR
00938P 0126 A6   21      A        LDA    &1,Y     MOVE CHARS DOWN A BYTE
00939P 0128 A7   A4      A        STA    ,Y
00940P 012A 26   F8   0124        BNE    CMPRSS   UNTIL END OF LINE IS REACHED
00941P 012C 39                    RTS
00942
00943P 012D 81   49      A CHKI   CMPA   #'I      INSERT CHARS?
00944P 012F 27   13   0144        BEQ    EDITI    YES, GO DO IT
00945P 0131 81   58      A        CMPA   #'X      ADD CHARS TO END OF LINE?
00946P 0133 27   0D   0142        BEQ    EDITX    YES
00947P 0135 81   48      A        CMPA   #'H      HACK OFF REST OF LINE AND ADD CHARS?
00948P 0137 26   5C   0195        BNE    EDITCD   NO
00949P 0139 6F   84      A        CLR    ,X       YES, LINE ENDS HERE
00950P 013B 1F   10      A        TFR    X,D      Calculate and store the new line
00951P 013D 83   0001    A        SUBD   #BUF+&1  length.
00952P 0140 D7   D7      A        STB    EDTLEN
00953
00954P 0142 8D   BF   0103 EDITX  BSR    EDTPRT   PRINT REST OF LINE
00955P 0144 BD   01D6    P EDITI  JSR    EDITIN   GET CHAR TO INSERT
00956P 0147 81   0D      A        CMPA   #CR      CARRIAGE RETURN?
00957P 0149 27   8E   00D9        BEQ    CRINS    YES, END INSERTION AND EDIT
00958P 014B 81   1B      A        CMPA   #ESCAPE  ESCAPE?
00959P 014D 27   25   0174        BEQ    CHGRTS   YES, ALL DONE INSERTING
00960P 014F 81   08      A        CMPA   #CHRDEL  CHARACTER DELETE?
00961P 0151 26   22   0175        BNE    EDTINS   NO, GO INSERT THE CHAR
00962P 0153 8C   0000    A        CMPX   #BUF     IF AT START OF LINE IGNORE DELETE
00963P 0156 27   EC   0144        BEQ    EDITI    AND GET NEXT CHAR TO INSERT
00964P 0158 8D   45   019F        BSR    GOBACK   BACK UP THE CURSOR
00965P 015A 8D   C4   0120        BSR    DELCHR   DELETE THE CHAR AND COMPRESS THE LINE
00566P 015C 20   E6   0144        BRA    EDITI    GO GET NEXT CHAR TO INSERT
00967
00968P 015E 81   43      A EDITC  CMPA   #'C      CHANGE CHARACTERS?
00969P 0160 26   CB   012D        BNE    CHKI     NO
00970P 0162 6D   84      A EDTCHG TST    ,X       AT END OF LINE?
00971P 0164 27   0E   0174        BEQ    CHGRTS   YES, NOTHING LEFT TO CHANGE
00972P 0166 BD   01D6    P        JSR    EDITIN   GET CHAR TO REPLACE CURRENT CHAR
00973P 0169 25   02   016D        BCS    OKCCHR   IF IT'S A CR, ESCAPE, OR CHRDEL
00974P 016B 20   F5   0162        BRA    EDTCHG   ignore  it.
00975P 016D A7   80      A OKCCHR STA    ,X+      OVERWRITE THE OLD CHAR
00976P 016F 8D   37   01A8        BSR    GCHROT   ECHO THE NEW CHAR
00977P 0171 5A                    DECB            REPEAT
00976P 0172 26   EE   0162        BNE    EDTCHG
00979P 0174 39             CHGRTS RTS
00960
00981
00982P 0175 D6   D7      A EDTINS LDB    EDTLEN   WILL LINE BE TOO LONG?
00983P 0177 C1   F9      A        CMPB   #MAXLEN
00984P 0179 26   02   017D        BNE    OKINS    NO
00985P 017B 20   C7   0144        BRA    EDITI    Yes, wait for escape or CR.
00566
00987P 017D 34   10      A OKINS  PSHS   X        SAVE EDIT POINTER
00988P 017F 6D   80      A FNDEND TST    ,X+      FIND THE END OF THE LINE
00989P 0181 26   FC   017F        BNE    FNDEND

PAGE  006  ECBEXT  .SA:1  EXTEND The EDIT Command

00990P 0183 E6   82      A INSMOV LDB    ,-X      MAKE ROOM FOR THE NEW CHAR BY MOVING
00991P 0185 E7   01      A        STB    &1,X     THE REST OF THE CHARS UP A BYTE
00992P 0187 AC   E4      A        CMPX   ,S       MOVE ALL INCLUDING CURRENT CHAR
00993P 0189 26   F8   0183        BNE    INSMOV
00994P 018B 32   62      A        LEAS   &2,S     Clean up the stack.
00995P 018D A7   80      A        STA    ,X+      PUT THE NEW CHAR INTO THE LINE
00996P 018F 8D   17   01A8        BSR    GCHROT   ECHO THE NEW CHAR
00997P 0191 0C   D7      A        INC    EDTLEN   INCREMENT THE LENGTH
00998P 0193 20   AF   0144        BRA    EDITI    GET NEXT CHAR TO INSERT
00999
01000P 0195 81   08      A EDITCD CMPA   #CHRDEL  CHARACTER DELETE?
01001P 0197 26   12   01AB        BNE    CHKK     NO
01002P 0199 8D   04   019F BACKB  BSR    GOBACK   Yes, output B backspaces.
01003P 019B 5A                    DECB
01004P 019C 26   FB   0199        BNE    BACKB
01005P 019E 39                    RTS
01006
01007P 019F 8C   0000    A GOBACK CMPX   #BUF     IF AT START OF LINE DO NOTHING
01008P 01A2 27   D0   0174        BEQ    CHGRTS
01009P 01A4 30   1F               DEX             OTHERWISE BACK UP THE EDIT POINTER
01010                      *    AND BACK UP THE CURSOR
01011            0001    A        IFEQ   REALIO
01014                       ENDC  IFN    REALIO
01015P 01A6 86   08      A BCKSPC LDA    #CHRDEL  Back up the cursor.
01016P 01A8 7E   0000    A GCHROT JMP    CHROUT
01017
01018P 01AB 81   4B      A CHKK   CMPA   #'K      KILL UNTIL MATCH FOUND?
01019P 01AD 27   05   01B4        BEQ    EDITK    YES
01020P 01AF 80   53      A        SUBA   #'S      SEARCH FOR CHAR?
01021P 01B1 27   01   01B4        BEQ    EDITK    YES, USE SAME CODE AS K EXCEPT
01022                      *    ACCA IS CLEAR AS A FLAG NOT TO KILL
01023P 01B3 39                    RTS             Unrecognizable command, ignore it and
01024                      *    go get another one.
01026P 01B4 34   02      A EDITK  PSHS   A        SAVE KILL FLAG
01027P 01B6 8D   1E   01D6        BSR    EDITIN   GET SEARCH CHAR
01028P 01B8 34   02      A        PSHS   A        PUT IT AWAY
01029P 01BA A6   84      A EDTSRC LDA    ,X       END OF LINE?
01030P 01BC 27   16   01D4        BEQ    SRCFIN   YES, GIVE UP SEARCH
010312 01BE 6D   61      A        TST    &1,S     IF NOT KILLING THEN PRINT CHARS
01032P 01C0 26   06   01C8        BNE    ISKILL   INSTEAD OF DELETING THEM
01033P 01C2 8D   E4   01A8        BSR    GCHROT
01034P 01C4 30   01               INX             POINT TO NEXT CHAR
01035P 01C6 20   03   01CB        BRA    NOKILL
01036P 01C8 BD   0120    P ISKILL JSR    DELCHR   DELETE THE CHAR
01037P 01CB A6   84      A NOKILL LDA    ,X       DO THE CHARS MATCH?
01038P 01CD A1   E4      A        CMPA   ,S
01039P 01CF 26   E9   01BA        BNE    EDTSRC   NO, CONTINUE SEARCH
01040P 01D1 5A                    DECB            YES, BUT MUST SEARCH REP COUNT TIMES
01041P 01D2 26   E6   01BA        BNE    EDTSRC
01042P 01D4 35   A0      A SRCFIN PULS   Y,PC     Clean up the stack and return.
01043
01044P 01D6 BD   0000    A EDITIN JSR    INCHR    GET A CHAR
01045P 01D9 81   7F      A        CMPA   #&127    THROW AWAY ALL BIGGER THAN TILDA.
01046P 01DB 24   F9   01D6        BCC    EDITIN
01047P 01DD 81   5F      A        CMPA   #@137    Translate shift uparrow key which
01048P 01DF 26   02   01E3        BNE    NOTESC   generates a backarrow to an escape
01049P 01E1 86   1B      A        LDA    #ESCAPE  for compatibility with the TRS-80.

PAGE  007  ECBEXT  .SA:1  EXTEND The EDIT Command

01050P 01E3 81   0D      A NOTESC CMPA   #CR      ADMIT LOW EXCEPTIONS
01051P 01E5 27   0E   01F5        BEQ    EDTINR
01052P 01E7 81   1B      A        CMPA   #ESCAPE
01053P 01E9 27   0A   01F5        BEQ    EDTINR
01054P 01EB 81   08      A        CMPA   #CHRDEL
01055P 01ED 27   06   01F5        BEQ    EDTINR
01056P 01EF 81   20      A        CMPA   #'       ALL OTHERS BELOW SPACE ARE BAD
01057P 01F1 25   E3   01D6        BCS    EDITIN
01058P 01F3 lA   01        EDTSEC SEC             SAY IT ISN'T A LOW EXCEPTION.
01059P 01F5 39             EDTINR RTS
010E0
01061                             TTL    TRON and TROFF
01062
01063                      *
01064                      * TRON turns on program tracing by setting TRCFLG to a nonzero
01065                      * value.  TRCFLG is checked at NEWSTT and if it is nonzero the
01066                      * line number of the line about to be executed is printed enclosed
01067                      * in square brackets.  TROFF turns off the program tracing by clearing
01068                      * TRCFLG.
01069
01070                             XDEF   TRON
01071P 01F6      86      A TRON   FCB    @206     LDAIM CLRA opcode to make A nonzero
01072                      *    skip over the CLRA.
01073                             XDEF   TROFF
01074P 01F7 4F             TROFF  CLRA            Prepare to clear TRCFLG.
01075P 01F8 97   AF      A        STA    TRCFLG   Set or clear the trace flag.
01076P 01FA 39             TRORTS RTS
01077
01078                             TTL    The POS function.
01079
01080                      *
01081                      * POS(<device number>) returns the print postion of the specified
01082                      * device.
01083                      *
01084                      * POS(0) returns the cursor column position.
01085                      * POS(-1), if the cassette is open for output, returns a meaningless
01086                      * result.  If the cassette is not  open a File Not Open error results.
01087                      * If the cassette is open for input, a Bad File Mode error results.
01088                      * POS(-2) returns the print position of the lineprinter.
01089                      *
01090
01091                             XDEF   POS
01092P 01FB 96   6F      A POS    LDA    DEVNUM   Preserve DEVNUM since this could be
01093P 01FD 34   02      A        PSHS   A        a case such as PRINT #-1,POS(0).
01094P 01FF BD   0000    A        JSR    SETDNM   Convert and check the argument.
01095P 0202 BD   0000    A        JSR    OPNOCK   Make sure the device is open for
01096                      *    output.
01097P 0205 BD   0000    A        JSR    DEVPRM   Get the device parameters.
01098P 0208 D6   6C      A        LDB    DEVPOS   Get the position into B.
01099P 020A 35   02      A        PULS   A        Restore DEVNUM.
01100P 020C 97   6F      A        STA    DEVNUM
01101P 020E 7E   0000    A        JMP    SNGFLT   Float the result and return.
01102
01103                             TTL    The VARPTR function.
01104
01105                      *
01106                      * VARPTR(<variable name>) returns the address of the specified
01107                      *

PAGE  008  ECBEXT  .SA:1  EXTEND The VARPTR function.

01106                      * It is important to note that VARPTR is not legal for undefined
01109                      * variables.  This is due to the fact that PTRGET will block transfer
01110                      * to make room for the new variable. A case such as A(0)=VARPTR(S)
01111                      * where S is undefined would cause disastrous results since the array
01112                      * A would have moved. Therefore, an FC error results is VARPTR is
01113                      * called with an undefined variable as the argument.
01114                      * This is accomplished by saving STREND prior to the PRTGET call
01115                      * and checking to see that it hasn't changed when PTRGET returns.
01116                      *
01117
01118                             XDEF   VARPTR
01119P 0211 BD   0000    A VARPTR JSR    CHKOPN   Eat the opening parenthesis.
01120P 0214 DC   1F      A        LDD    STREND   Remember the top of storage.
01121P 0216 34   06      A        PSHS   D
01122P 0218 BD   0000    A        JSR    PTRGET   X:=pointer to the variable.
01123P 021B BD   0000    A        JSR    CHKCLS   Check for the closing parenthesis.
01124P 021E 35   06      A        PULS   D        X:=original top of storage,
01125P 0220 1E   10      A        EXG    X,D      D:=pointer to variable.
01126P 0222 9C   1F      A        CMPX   STREND   Did the top of storage change during
01127                      *    the call to PTRGET?
01128P 0224 26   51   0277        BNE    XRFC1    Yes, give an FC error since the
01129                      *    variable was undefined prior to the
01130                      *    PTRGET call.
01131P 0226 7E   06ED    P        JMP    PATCHV   No, go float the result and return.
01132
01133                             TTL    MID$ Assignment (MID$ on the Left Side).
01134
01135                             XDEF   LHMID$
01136P 0229 9D   9F      A LHMID$ JSR    CHRGET   Eat the second byte of the function
01137P 022B BD   0000    A        JSR    CHKOPN   token and the left parenthesis.
01138P 022E BD   0000    A        JSR    PTRGET   X:=pointer to left string
01139                      *    variable's descriptor.
01140P 0231 34   10      A        PSHS   X        Save it.
01141P 0233 EC   02      A        LDD    &2,X     X:=pointer to left string data.
01142P 0235 1093 21      A        CMPD   STKTOP   is it in string space?
01143P 0238 23   04   023E        BLS    LHMD05   No, must copy.
01144P 023A 93   27      A        SUBD   MEMSIZ
01145P 023C 23   12   0250        BLS    LHMD10   Yes, don't copy.
01146                      *    No, it must be copied into string
01147                      *    space prior ro being modified.  (It
01148                      *    could be a string literal in the
01149                      *    program for example.)
01150                      *    Note that this code checks both
01151                      *    ends of string space rather than
01152                      *    just checking to see if the string
01153                      *    is above STKTOP.  This is done
01154                      *    so it will be possible to put
01155                      *    random file buffers above MEMSIZ
01156                      *    and the copy will still occur for
01157                      *    compatibility with other versions
01158                      *    of BASIC.
01159P 023E E6   84      A LHMD05 LDB    ,X       Get the required amount of string
01160P 0240 BD   0000    A        JSR    GETSPA   space.
01161P 0243 34   10      A        PSHS   X        Save the pointer to the free space.
01162P 0245 AE   62      A        LDX    &2,S     Copy the string.
01163P 0247 BD   0000    A        JSR    MOVINS
01164P 024A 35   50      A        PULS   X,U      Put the new string data address into
01165P 024C AF   42      A        STX    &2,U     the string descriptor.

PAGE  009  ECBEXT  .SA:1  EXTEND MID$ Assignment (MID$ on the Left Side).

01166P 024E 34   40      A        PSHS   U        Resave the descriptor pointer.
01167P 0250 BD   0000    A LHMD10 JSR    COMBYT   Skip comma, B:=offset into left
01168                      *    string.
01169P 0253 34   04      A        PSHS   B        Save the offset.
01170P 0255 5D                    TSTB            Give a Function Call error if the
01171P 0256 27   1F   0277        BEQ    XRFC1    offset is zero.
01772P 0258 C6   FF      A        LDB    #&255    Assume no third argument, in which
01173                      *    case as many chars as possible will
01174                      *    be replaced.
01175P 025A 81   29      A        CMPA   #CLSPAR  Arrived at the closing parenthesis?
01176P 025C 27   03   0261        BEQ    LHMD30   Yes, no third argument.
01177P 025E BD   0000    A        JSR    COMBYT   No, skip the comma and evaluate the
01178                      *    number of chars to replace.
01179P 0261 34   04      A LHMD30 PSHS   B        Save the number of chars to replace.
01180P 0263 BD   0000    A        JSR    CHKCLS   Eat the closing parenthesis and
01181P 0266                       SYNCHK EQULTK   the equals sign.
01182P 026B 8D   2E   029B        BSR    EVLSTR   Evaluate the right string
01183                      *    formula, B:=length, X:=pointer to
01184                      *    string data.
01185P 026D 1F   13      A        TFR    X,U      Save pointer in U.
01186P 026F AE   62      A        LDX    &2,S     X:=pointer to left string
01187                      *    descriptor.
01188P 0271 A6   84      A        LDA    ,X       A:=length of left string.
01189P 0273 A0   61      A        SUBA   &1,S     Is the specified offset beyond the
01190                      *    end of the left string?
01191P 0275 24   03   027A        BHS    LHMD35   No.
01192P 0277 7E   0000    A XRFC1  JMP    FCERR    Yes, give FC error.
01193
01194P 027A 4C             LHMD35 INCA            No, A:=number of chars between the
01195                      *    offset and theend of the left
01196                      *    string.
01197P 027B A1   E4      A        CMPA   ,S       Is the number of chars that can be
01198                      *    replaced greater than or equal to
01199                      *    the specified number or default (255)?
01200P 027D 24   02   0281        BHS    LHMD40   Yes, use the use the specified or
01201                      *    default number.
01202P 027F A7   E4      A        STA    ,S       No, use the lesser number.
01203P 0281 A6   61      A LHMD40 LDA    &1,S     A:=offset into left string.
01204P 0283 1E   89      A        EXG    A,B      A:=length of right string,
01205                      *    B:=offset into left string.
01206                      *    (Want to use ABX below since it
01207                      *    does an unsigned addition.)
01208P 0285 AE   02      A        LDX    &2,X     X:=pointer to left string data.
01209P 0287 5A                    DECB            X:=pointer into left string
01210P 0288 3A                    ABX             where replacement will begin.
01211P 0289 4D                    TSTA            Is the right string null?
01212P 028A 27   0D   0299        BEQ    LHMD60   Yes, no replacement can be done.
01213P 028C A1   E4      A        CMPA   ,S       No, is the right string shorter 
01214                      *    than the number of chars to be
01215                      *    replaced?
01216P 028E 23   02   0292        BLS    LHMD50   Yes, only replace the number of chars
01217                      *    contained in the right string.
01218P 0290 A6   E4      A        LDA    ,S       No, use the replacement count
01219                      *    previously determined.
01220P 0292 1F   89      A LHMD50 TFR    A,B      B:=number of chars to move.
01221P 0294 1E   31      A        EXG    U,X      X:=source pointer (right string),
01222                      *    U:=destination pointer (left
01223                      *    string).

PAGE  010  ECBEXT  .SA:1  EXTEND MID$ Assignment (MID$ on the Left Side).

01224P 0296 BD   0000    A        JSR     COPLOP  Go move the characters.
01225P 0299 35   96      A LHMD60 PULS    D,X,PC  Clean up the stack and return.
01226
01227
01228                      *
01229                      * EVLSTR evaluates a numeric formula and returns with
01230                      * B containing the length of the string and X containing
01231                      * a pointer to the string data.
01232                      *
01233
01234                             XDEF   EVLSTR
01235P  029B BD  0000    A EVLSTR JSR    FRMEVL   Evaluate a formula.
01236P  029E 7E  0000    A        JMP    FRESTR   Make sure it's a string, free up
01237                      *    the temporary, X:=pointer to string
01238                      *    data, B:=length of string.
01239
01240                             TTL    The STRING$ Function.
01241
01242                      *
01243                      * STRING$(<count>, <character>) returns a string of length <count>
01244                      * which is filled with the character specified by <character>.
01245                      * <character> can be specified as a string or a numeric formula.
01246                      * If string, the first  character is used to fill the result.
01247                      * If numeric, the value is used as an ASCII code to fill the
01248                      * result.
01249                      *
01250
01251                             XDEF   STRNG$
01252P  02A1 BD  0000    A STRNG$ JSR    CHKOPN   Eat the open parenthesis.
01253P  02A4 BD  0000    A        JSR    GETBYT   Evaluate and save the count.
01254P  02A7 34  04      A        PSHS   B
01255P  02A9 BD  0000    A        JSR    CHKCOM   Eat the comma.
01256P  02AC BD  0000    A        JSR    FRMEVL   Evaluate the second argument.
01257P  02AF BD  0000    A        JSR    CHKCLS   Check for the closing parenthesis.
01258P  02B2 96  06      A        LDA    VALTYP   Is the second argument numeric?
01259P  02B4 26  05   02BB        BNE    STR2AR   No, it's a string.
01260P  02B6 BD  0000    A        JSR    CONINT   Yes, convert it to an integer in B.
01261P  02B9 20  03   02BE        BRA    GTROOM   Go get space for the string.
01262
01263P  02BB BD  0000    A STR2AR JSR    ASC2     B:=ASCII code of the first byte of
01264                      *    the second argument.
01265P  02BE 34  04      A GTROOM PSHS   B        Save the character code.
01266P  02C0 E6  61      A        LDB    &1,S     Get length of result string.
01267P  02C2 BD  0000    A        JSR    STRSPA   Get the required amount of string
01268                      *    space.
01269P  02C5 35  06      A        PULS   A,B      A:=char code, B:=string length.
01270P  02C7 27  05   02CE        BEQ    FINBLD   Zero length string, don't put
01271                      *    any chars into it.  (STRSPA set
01272                      *    the condition codes on the length
01273                      *    of the string.)
01274P  02C9 A7  80      A BUILDS STA    ,X+      Build the result string by storing
01275P  02CB 5A                   DECB            the character code into each
01276P  02CC 26  FB   02C9        BNE    BUILDS   byte of the string.
01277P  02CE 7E  0000    A FINBLD JMP    GOPTNW   Go put away the result.
01278
01279                             TTL    The INSTR Function.
01280
01281                      *

PAGE  011  ECBEXT  .SA:1  EXTEND The INSTR Function.

01282                      * INSTR([<offset>,<S1$>,<S2$>) searches S1$ for the first
01283                      * occurence of S2$ starting at the specified offset or at the
01284                      * start of S1$ if no offset is specified.
01285                      *
01286                      * The value returned is the position of the first char if a match
01287                      * is found, zero if a match is not found.
01268                      *
01289                      * If S2$ is null, the specified offset or 1 is returned.
01290                      *
01291                      * If S1$ is null, or the offset is beyond the end of S1$,
01292                      * 0 is returned. (These are not really special cases
01293                      * from the user's viewpoint, but the code checks for them as
01254                      * special cases.)
01295                      *
01296                      * If an offset of zero is specified, an FC error results.
01297                      *
01298
01299                             XDEF   INSTR
01300P 02D1 BD   0000    A INSTR  JSR    CHKOPN   Check for the left parenthesis.
01301P 02D4 BD   0000    A        JSR    FRMEVL   Evaluate the first argument.
01302P 02D7 C6   01      A        LDB    #&1      Assume no offset is specified and
01303P 02D9 34   04      A        PSHS   B        set up the default.
01304P 02DB 96   06      A        LDA    VALTYP   Is the first argument numeric?
01305P 02DD 26   10   02EF        BNE    INST10   No, no offset.
01306P 02DF BD   0000    A        JSR    CONINT   Yes, B:=specified offset.
01307P 02E2 E7   E4      A        STB    ,S       Overwrite the default.
01308P 02E4 27   91   0277        BEQ    XRFC1    Don't allow an offset of zero.
01309P 02E6 BD   0000    A        JSR    CHKCOM   Eat the comma, evaluate and check
01310P 02E9 BD   0000    A        JSR    FRMEVL   the S1$ argument.  (Don't want to call
01311P 02EC BD   0000    A        JSR    CHKSTR   EVLSTR since it would free up the
01312                      *    temporary and we can't do that until
01313                      *    the S2$ argument has been evaluated.)
01314P 02EF 9E   52      A INST10 LDX    FACMO    Save the pointer to the S1$
01315P 02F1 34   10      A        PSHS   X        descriptor.
01316P 02F3 BD   0000    A        JSR    CHKCOM   Skip the comma and evaluate the S2$
01317P 02F6 BD   029B    P        JSR    EVLSTR   argument.
01318P 02F9 34   14      A        PSHS   X,B      Save data pointer and length of S2$.
01319P 02FB BD   0000    A        JSR    CHKCLS   Check for the right parenthesis.
01320P 02FE AE   63      A        LDX    &3,S     Free up the S1$ temp.
01321P 0300 BD   0000    A        JSR    FRETMP   X:=data pointer, B:=length.
01322P 0303 34   04      A        PSHS   B        Save length of S1$.
01323P 0305 E1   66      A        CMPB   &6,S     Is the offset beyond the end of S1$?
01324P 0307 25   23   032C        BLO    INST50   Yes, return 0.
01325P 0309 A6   61      A        LDA    &1,S     No, is S2$ null?
01326P 030B 27   1C   0329        BEQ    INST40   Yes, return the offset.
01327P 030D E6   66      A        LDB    &6,S     No, X:=pointer into S1$ where the
01328P 030F 5A                    DECB            search must begin.
01329P 0310 3A                    ABX
01330
01331P 0311 31   84      A INST20 LEAY   ,X       Save S1$ pointer where current
01332                      *    search began.
01333P 0313 EE   62      A        LDU    &2,S     U:=pointer to S2$.
01334P 0315 E6   61      A        LDB    &1,S     B:=length of S2$.
01335P 0317 A6   E4      A        LDA    ,S       A:=number of chars between the
01336P 0319 A0   66      A        SUBA   &6,S     search starting point and the end
01337P 031B 4C                    INCA            of S1$.
01338P 031C A1   61      A        CMPA   &1,S     Is it shorter than S2$?
01339P 031E 25   0C   032C        BLO    INST50   Yes, give up and return 0.

PAGE  012  ECBEXT  .SA:1  EXTEND The INSTR Function.

01340
01341P 0320 A6   80      A INST30 LDA    ,X+      Get char from S1$.
01342P 0322 A1   C0      A        CMPA   ,U+      Compare to char in S2$.
01343P 0324 26   0C   0332        BNE    INST60   Not the same.
01344P 0326 5A                    DECB            Same, more to check?
01345P 0327 26   F7   0320        BNE    INST30   Yes, check next chars.
01346
01347P 0329 E6   66      A INST40 LDB    &6,S     Match, return the offset.
01348P 032B      21      A        FCB    @41      BRN over CLRB.
01349P 032C 5F             INST50 CLRB            No match, return 0.
01350P 032D 32   67      A        LEAS   &7,S     Clean up the stack.
01351P 032F 7E   0000    A        JMP    SNGFLT   Float the result and return.
01352
01353P 0332 6C   66      A INST60 INC    &6,S     Chars not the same, increment offset
01354                      *    into S1$.
01355P 0334 30   21      A        LEAX   &1,Y     Start searching one char to the right
01356P 0336 20   D9   0311        BRA    INST20   in S1$.
01357
01358                             TTL    Hex and Octal Constants
01359
01360                             XDEF   HOCONS
01361P 0338 0F   52      A HOCONS CLR    FACMO    Clear FACMO,FACLO since that's where
01362P 033A 0F   53      A        CLR    FACLO    the result is built.
01363P 033C 8E   0052    A        LDX    #FACMO   Set up a pointer to the FAC.
01364P 033F 9D   9F      A        JSR    CHRGET   See if O or H specified.
01365P 0341 81   4F      A        CMPA   #'O      O for octal?
01366P 0343 27   12   0357        BEQ    OCTCN1   Yes, go do octal.
01367P 0345 81   48      A        CMPA   #'H      No, H for hex?
01368P 0347 27   23   036C        BEQ    HEXCN0   Yes, go do hex.
01369                      *    No, default to octal.
01370P 0349 9D   A5      A        JSR    CHRGOT   Reget current char to set
01371P 034B 20   0C   0359        BRA    OCTCN2   condition codes.
01372
01373P 034D 81   38      A OCTCN0 CMPA   #'8      Is it a valid octal digit?
01374P 034F 1022 FCAD    A        LBHI   SNERR    No, give a syntax error.
01375P 0353 C6   03      A        LDB    #&3      Yes, bits/digit:=3.
01376P 0355 8D   2A   0381        BSR    HODIG    Go add in the new digit.
01377P 0357 9D   9F      A OCTCN1 JSR    CHRGET   Get next char.
01378P 0359 25   F2   034D OCTCN2 BCS    OCTCN0   It's a digit, continue.
01379                      *    Not a digit, time to quit.
01380
01381                      *
01382                      * Float the sixteen bit unsigned value in FACMO,FACLO.
01383                      *
01384
01385                             XDEF   CONS16
01386P 035B 0F   50      A CONS16 CLR    FACHO    Clear the most significant byte.
01387            0001    A        IFNE   ADDPRC
01368P 035D 0F   51      A        CLR    FACMOH
01389                             ENDC   IFN      ADDPRC
01390P 035F 0F   06      A CONS24 CLR    VALTYP   Set VALTYP to numeric.
01391P 0361 0F   63      A        CLR    FACOV
01392P 0363 0F   54      A        CLR    FACSGN   Mark as positive.
01393P 0365 C6   A0      A        LDB    #@230+@10*ADDPRC Set up the exponent.
01394P 0367 D7   4F      A        STB    FACEXP
01395P 0369 7E   0000    A        JMP    NORMAL   So normalize it.
01396
01397P 036C 9D   9F      A HEXCN0 JSR    CHRGET   Get next char.

PAGE  013  ECBEXT  .SA:1  EXTEND Hex and Octal Constants

01398                             XDEF   HEXCNX
01399P 036E 25   0B   037B HEXCNX BCS    HEXCN1   It's a numeric digit.
01400P 0370 BD   0000    A        JSR    ISLETC   Not numeric, see if letter.
01401P 0373 25   E6   035B        BCS    CONS16   Not letter, finished.
01402P 0375 81   47      A        CMPA   #'F+&1   Valid hex alpha digit?
01403P 0377 24   E2   035B        BCC    CONS16   No, all done.
01404P 0379 80   07      A        SUBA   #'A-'0-&10 Yes, adjust alpha code.
01405
01406P 037B C6   04      A HEXCN1 LDB    #&4      Bits/digit:=4.
01407P 037D 8D   02   0381        BSR    HODIG    Add in new digit.
01408P 037F 20   EB   036C        BRA    HEXCN0   Do next digit.
01409
01410
01411P 0381 68   01      A HODIG  ASL    &1,X     Shift current value left bits/digit
01412P 0383 69   84      A        ROL    ,X       times while checking for overflow.
01413P 0385 1025 FC77    A        LBCS   OVERR
01414P 0389 5A                    DECB
01415P 038A 26   F5   0381        BNE    HODIG
01416P 038C 80   30      A        SUBA   #'0      Subtract out ASCII offset.
01417P 036E AB   01      A        ADDA   &1,X     Add in new digit to
01418P 0390 A7   01      A        STA    &1,X     low order byte.
01419P 0392 39             HORTS  RTS             (Can't get carry since low order
01420                      *    hex or octal digit is a zero from
01421                      *    shifting done above.)
01422
01423                             TTL    Simple User Defined Function Code.
01424
01425
01426                      *
01427                      * Note only single arguments are allowed to functions
01428                      * and functions must be of the single line form:
01429                      * DEF FNA(X)=X^2+X-2
01430                      * Both the argument and result must be numeric.
01431                      *
01432                      * Idea: create a simple variable entry
01433                      * whose first character has the 200 bit set.
01434                      * The value will be:
01433                      *
01436                      * A text pntr to the formula.
01437                      * A pntr to the argument variable.
01438                      *
01439                      * Function names can be like FNA4.
01440                      *
01441                      *
01442                      * Subroutine to see if we are in direct mode
01443                      * and complain if so.
01444                      *
01445
01446                             XDEF   ERRDIR
01447P 0393 9E   68      A ERRDIR LDX    CURLIN   Dir mode has CURLIN=65535.
01446P 0395 30   01      A        LEAX   &1,X     So now, is result zero?
01449P 0397 26   F9   0392        BNE    HORTS    Yes.
01450P 0399 C6   00      A        LDB    #ERRID   Illegal Direct Error.
01451P 039B 7E   0000    A ERRGO1 JMP    ERROR
01452
01453                             XDEF   DEF
01454P 039E AE   9F 00A6 A DEF    LDX    [TXTPTR] Is it DEF USR?
01455P 03A2 8C   FF00    A        CMPX   #$FF00+USRTK

PAGE  014  ECBEXT  .SA:1  EXTEND Simple User Defined Function Code.

****WARNING   001--00000
01456P 03A5 1027 0074 041D        LBEQ   DEFUSR   Yes, go define the USR function
01457                      *    address.
01458P 03A9 8D   23   03CE        BSR    GETFNM   Get a pntr to the function.
01459P 03AB 8D   E6   0393        BSR    ERRDIR
01460P 03AD BD   0000    A        JSR    CHKOPN   Must have "(".
01461P 03B0 C6   80      A        LDB    #&128
01462P 03B2 D7   08      A        STB    SUBFLG   Prohibit subscripted variables.
01463P 03B4 BD   0000    A        JSR    PTRGET   Get pntr to argument.
01464P 03B7 8D   25   03DE        BSR    CHKNU2   Is it a number?
01465P 03B9 BD   0000    A        JSR    CHKCLS   Must have ")"
01466P 03BC                       SYNCHK EQULTK   Must have "=".
01467P 03C1 9E   4B      A        LDX    DEFPNT   Get pntr to thing to store in.
01468P 03C3 DC   A6      A        LDD    TXTPTR   Get thing to store.
01469P 03C5 ED   84      A        STD    ,X       Put down text pointer.
01470P 03C7 DC   39      A        LDD    VARPNT   Get more to store.
01471P 03C9 ED   02      A        STD    &2,X     Store it.
01472P 03CB 7E   0000    A        JMP    DATA     Skip to end.
01473
01474                      *
01475                      * Subroutine to get a pntr to a function name.
01476                      *
01477
01478P 03CE                GETFNM SYNCHK FNTK     Must start with FN.
01479P 03D3 C6   80      A        LDB    #&128    Don't allow an array.
01460P 03D5 D7   08      A        STB    SUBFLG
01481P 03D7 8A   80      A        ORA    #&128    Put function bit on.
01482P 03D9 BD   0000    A        JSR    PTRGT2   Get pntr to function or create anew.
01483P 03DC 9F   4B      A        STX    DEFPNT
01484P 03DE 7E   0000    A CHKNU2 JMP    CHKNUM   Make sure it's numeric and return.
01485
01486                             XDEF   FNDOER
01487P 03E1 8D   EB   03CE FNDOER BSR    GETFNM   Get pointer to function definition.
01488P 03E3 34   10      A        PSHS   X        Save it.
01489P 03E5 BD   0000    A        JSR    PARCHK   Evaluate the actual parameter.
01490                      *    (It's enclosed in parentheses.)
01491P 03E8 8D   F4   03DE        BSR    CHKNU2   Make sure it's numeric.
01492P 03EA 35   40      A        PULS   U        U:=pointer to function def.
01493P 03EC C6   00      A        LDB    #ERRUF   In case function is undefined.
01494P 03EE AE   42      A        LDX    &2,U     X:=pointer to dummy arg variable.
01495P 03F0 27   A9   039B        BEQ    ERRGO1   If zero the function isn't defined.
01496P 03F2 109E A6      A        LDY    TXTPTR   Y:=text pointer which points into
01497                      *    function call.
01498P 03F5 EE   C4      A        LDU    ,U       U:=function definition text pointer.
01499P 03F7 DF   A6      A        STU    TXTPTR   Set up txtptr for FRMEVL.
01500            0001    A        IFNE   ADDPRC
01501P 03F9 A6   04      A        LDA    &4,X     Push on extra byte of arg variable.
01502P 03FB 34   02      A        PSHS   A
01503                             ENDC   IFN      ADDPRC
01504P 03FD EC   84      A        LDD    ,X       D,U:=dummy arg variable value.
01505P 03FF EE   02      A        LDU    &2,X
01506P 0401 34   76      A        PSHS   U,Y,X,B,A Save dummy arg variable value, pointer
01507                      *    to dummy arg, and call text pointer.
01508P 0403 BD   0000    A        JSR    MOVMF    Move actual parm value into dummy
01509                      *    arg variable from FAC.
01510P 0406 BD   0000    A        JSR    FRMNUM   Evaluate a numeric formula.  (This
01511                      *    is the function def formula.)
01512P 0409 35   76      A        PULS   A,B,X,Y,U Get back dummy arg value, dummy arg

PAGE  015  ECBEXT  .SA:1  EXTEND Simple User Defined Function Code.

01513                      *    pointer, and call text pointer.
01514P 040B ED   84      A        STD    ,X       Restore the dummy arg.
01515P 040D EF   02      A        STU    &2,X
01516            0001    A        IFNE   ADDPRC
01517P 040F 35   02      A        PULS   A        Restore extra byte of arg variable.
01518P 0411 A7   04      A        STA    &4,X
01519                             ENDC   IFN      ADDPRC
01520P 0413 9D   A5      A        JSR    CHRGOT   Make sure the function definition is
01521P 0415 1026 FBE7    A        LBNE   SNERR    Properly terminated.  (Can't make this
01522                      *    check during definition time since
01523                      *    it is then not known where the end of
01524                      *    the expression is.)
01525P 0419 109F A6      A        STY    TXTPTR   Restore caller's TXTPTR.
01526P 041C 39             DEFRTS RTS
01527
01528                             TTL    USR Function Code.
01529
01530                      *
01531                      * Here when DEF sees a USR token.
01532                      *
01533
01534P 041D 9D   9F      A DEFUSR JSR    CHRGET   Skip the first byte of the function
01535                      *    token.
01536P 041F 9D   9F      A        JSR    CHRGET
01537P 0421 8D   07   042A        BSR    SCNUSR   X:=address of USRTAB entry.
01538P 0423 34   10      A        PSHS   X        Save it.
01539P 0425 8D   2B   0452        BSR    EQUADR   Skip equals sign, X:=address.
01540P 0427 AF   F1      A        STX    [,S++]   return.
01541P 0429 39                    RTS
01542
01543
01544                      *
01545                      * Scan USR function number and return a pointer to the specified
01546                      * USRTAB entry in X.
01547                      *
01548
01549P 042A 5F             SCNUSR CLRB            Assume no function number specified.
01550                      *    The default is USR0.
01551P 042B 9D   A5      A        JSR     CHRGOT  USR token ALREADY SKIPPED.
01552P 042D 24   06   0435        BCC     ISUSR0  No digit, default to USR0.
01553P 042F 80   30      A        SUBA    #'0     Get rid of ASCII offset and put the
01554P 0431 1F   89      A        TFR     A,B     function number into B.
01555P 0433 9D   97      A        JSR     CHRGET  Skip the digit.
01556P 0435 9E   B0      A ISUSR0 LDX     USTBAD  X:=pointer to USRTAB.
01557P 0437 58                    ASLB            USRTAB entries are two bytes each.
01558P 0438 3A                    ABX             X:=pointer to specified entry and
01559P 0439 39                    RTS             return.
01560
01561
01562                      *
01563                      * Here when USR token is seen by the EVAL chain.
01564                      *
01565
01566                             XDEF   USRFN
01567P 043A 8D   EE   042A USRFN  BSR    SCNUSR   X:=pointer to USRTAB entry.
01568P 043C AE   84      A        LDX    ,X       Save the address of the USR function.
01569P 043E 34   10      A        PSHS   X
01570P 0440 BD   0000    A        JSR    PARCHK   Evaluate formula enclosed in parens.

