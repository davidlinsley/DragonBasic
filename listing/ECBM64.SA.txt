PAGE  001  ECBCOM  .SA:0  ECBM64 Extension ROM Direct Page RAM

00700                             OPT    L,LLE=120
00701                             NAM    ECBM64
00702
00703                      **********************************************************************
00704                      *                                                                    *
00705                      *    Copyright 1982 by Microsoft Corporation, all rights reserved    *
00706                      *                                                                    *
00707                      **********************************************************************
00708
00709                             TTL     External Declarations
00710
00711                             XREF    ALPHLK,ASC2,ASCFLG
00712                             XREF    BITIN,BUF
00713                             XREP    CASBUF,CASOFF,CASON,CBIN,CBLINK,CBOUT,CHKCLS,CHKCOM,CHKOPN
00714                             XREF    CHR$DO,CLOADM,COMBYT,CONINT,CRDO,CSAVEM,CSFNAM,CSRDON
00715                             XREF    CLEARC
00716                             XREF    DBNCNT
00717                             XREF    ENDHKS,ERRAO,ERRBM,ERRDN,ERRIO,ERRNO,ERROR,EVLADR
00716                             XREF    FCERR,FILNAM,FILTYP,FINI,FNAMLN,FRESTR,FRMEVL,FRMNUM
00719                             XREF    FUNDSP,FUNLST
00720                             XREF    GAPFLG,GETBYT,GIVABF,GOPTNW
00721                             XREF    HDRLEN,HKBRKC,HKCHRI,HKCHRO,HKCKDI,HRCKDO,HKCLS,HKCLS1
00722                             XREF    HKCLSA,HKDNCK,HKDPRM,HKEOF,HKFNLD,HKINLN,HKOPEN,HOOKS
00723                             XREF    INTCNV,INTIDX,ISCNTC,INTWDG
00724                             XREF    JOYIN
00725                             XREF    LDBUFR,LIST,LOADAD,LPTOUT
00726                             XREF    MAIN
00727                             XREF    NFUNTK,NNRMTK,NRTSH3,NRTSHK,NZLINK
00728                             XREF    OFFTK,ONTK
00729                             XREF    PINIT,POLCAT,POTVAL
00730                             XREF    READY,REASON,REDDY,RESLST,ROLTBL
00731                             XREF    SAMALP,SCROUT,SCRTCH,SNERR,SNGFLT
00732                             XREF    STKINI,STMDSP,STROUT,STRTAD,STUBO,SYNCHR
00733                             XREF    TEMPST
00734                             XREF    USRTAB
00735                             XREF    VIRQ
00736                             XREF    WRTLDR
00737                             XREF    XRRUN,XRSLWC
00738
00739            0001    A        IFEQ    REALIO
00744                       ENDC   IFE REALIO
00745
00746                             TTL    Equates
00747
00748                             XDEF   SCRADR
00749            0400    A SCRADR EQU    @2000    Address of screen memory (400 hex).
00750
00751            0001    A        IFNE   METTOY
00752                             XDEF   PIA0AD
00753            FF00    A PIA0AD EQU    @177400  PIA0, side A, data reg.  (FF00)
00754                             ENDC   IFN      METTOY
00755            0000    A        IFNE   GRPTEK
00758                       ENDC   IFN GRPTEK
00759                             XDEF   PIA0AC
00760            FF01    A PIA0AC EQU    PIA0AD+&1 PIA0, side A, control  reg.
00761                             XDEF   PIA0BD
00762            FF02    A PIA0BD EQU    PIA0AC+&1 PIA0, side B, data reg.
00763                             XDEF   PIA0BC

PAGE  002  ECBM64  .SA:1  ECBM64 Equates

00764            FF03    A PIA0BC EQU    PIA0BD+&1 PIA0, side B, control reg.
00765
00766            0001    A        IFNE   METTOY
00767                             XDEF   PIA1AD
00768            FF20    A PIA1AD EQU    @177440  PIA1, side A, data reg.  (FF20)
00769                             ENDC   IFN      METTOY
00770            0000    A        IFNE   GRPTEK
00773                        ENDC  IFN GRPTEK
00774                             XDEF   PIA1AC
00775            FF21    A PIA1AC EQU    PIA1AD+&1 PIA1, side A, control reg.
00776                             XDEF   PIA1BD
00777            FF22    A PIA1BD EQU    PIA1AC+&1 PIA1, side B, data reg.
00778                             XDEF   PIA1BC
00779            FF23    A PIA1BC EQU    PIA1BD+&1 PIA1, side B, conrtrol reg.
00780
00781            C000    A CARTRM EQU    @140000  Address of cartridge ROM.  (C000)
00782            8000    A EXTROM EQU    @100000  Address of extension ROM.  (8000)
00783
00784                             XDEF   SAM
00785            FFC0    A SAM    EQU    @177700  Address of SAM chip.  (FFC0)
00786
00787            C000    A DSKRUM EQU    @140000 The address of the disk ROM.  (C000)
00788
00789            BE7F    A BOOT64 EQU    $BE7F
00790            011A    A FLAG64 EQU    $11A
00791                             TTL    Power up and Reset code.
00792                             XDEF   POWRUP
00793            0000    P POWRUP EQU    *        DUMMY LABEL FOR 64K VERSION
00794                             XDEF   ZHRDIN
00795            0000    P ZHRDIN EQU    *
00796                             XDEF   INIT
00797P 0000 8E   0071    P INIT   LDX    #LORAM   INITIALISE DIRECT PAGE RAM
00798P 0003 CE   009D    A        LDU    #EXECAD
00799P 0006 C6   0E      A        LDB    #NLORAM
00800P 0008 BD   03B1    P        JSR    COPLOP
00801P 000B CE   0000    A        LDU    #VIRQ    INITIALISE RAM OFF DIRECT PAGE
00802P 000E C6   0E      A        LDB    #NMDRAM  UP TO 64K FLAG
00803P 0010 BD   03B1    P        JSR    COPLOP
00804P 0013 33   45      A        LEAU   5,U      SKIP PAST USED BYTES
00805P 0015 C6   0B      A        LDB    #NHIRAM
00806P 0017 BD   03B1    P        JSR    COPLOP
00807P 001A 8E   0000    A        LDX    #SNERR   X:=SNERR FOR INITIALISING THE DISPATCH
00808P 001D AF   43      A        STX    &3,U     INIT STUB 1 DISPATCH ADDRESS
00809P 001F AF   48      A        STX    &8,U
00810P 0021 8E   0000    A        LDX    #HOOKS
00811P 0024 CC   3900    A        LDD    #$3900+NRTSH3
00812P 0027 A7   80      A INIHKS STA    ,X+
00813P 0029 5A                    DECB
00814P 002A 26   FB   0027        BNE    INIHKS
00815P 002C BD   065C    P        JSR    GRNCHR  Clear the screen.
00816P 002F BD   00000   A        JSR    CLEARC  DESTROY OLD VARIABLES
00817P 0032 1C   AF      A        ANDCC  #$FF!X(F!+I) Allow the cartridge to interrupt now
00818                      *    before displaying the sign on message.
00819P 0034 8E   0097    P        LDX    #SIGNON-&1 Print the sign on message.
00820P 0037 BD   0000    A        JSR    STROUT
00821                             XDEF   FINIT
00822P 003A 86   55      A FINIT  LDA    #@125    Set the restart flag.
00823P 003C 97   71      A        STA    RSTFLG

PAGE  003  ECBM64  .SA:1  ECBM64 Power up and Reset code.

00824P 003E B7   011A    A        STA    FLAG64
00825P 0041 20   03   0046        BRA    BASRST
00826                      *
00827                      * Here to restart BASIC.
00828                      *
00829                             XDEF   ZSFTIN
00830P 0043 BD   065C    P ZSFTIN JSR    GRNCHR
00831                             XDEF   BASRST
00832P 0046 0F   E3      A BASRST CLR    DURCNT   Clear the PLAY note duration count
00833P 0048 0F   E4      A        CLR    DURCNT+&1 so interrupts don't think we are
00834                      *    still playing the note.
00835P 004A B6   FF03    A        LDA    PIA0BC   Enable the 60 hertz interrupt.
00836P 004D 8A   01      A        ORA    #&1
00837P 004F B7   FF03    A        STA    PIA0BC
00838P 0052 0F   6F      A        CLR    DEVNUM   Make sure output goes to screen and
00839                      *    input comes from keyboard.
00840P 0054 BD   0000    A        JSR    STKINI   Reset the stack and things.
00841P 0057 1C   AF      A        ANDCC  #$FF!X(F!+I) Enable interrupts.
00842P 0059 7E   0000    A GORDY  JMP    READY    Go say "OK".
00843
00844
00845                      *
00846                      * Here on a FIRQ to handle the cartridge interrupt.
00847                      *
00848                             XDEF   CARTRG
00849P 005C 7D   FF23    A CARTRG TST    PIA1BC   Did the cartridge cause the interrupt?
00850P 005F 2B   01   0062        BMI    GOCART   Yes.
00851P 0061 3B                    RTI             No, return from the interrupt.
00852
00853P 0062 BD   006A    P GOCART JSR    DELHAF   Delay for about a second
00854P 0065 0F   71      A        CLR    RSTFLG   Don't allow BASIC to be restarted.
00855P 0067 7E   C000    A        JMP    CARTRM   Go execute the cartrige program.
00856
00857                      *
00858                      * Delay for about one half second.
00859                      *
00860
00861                             XDEF   DELHAF
00862P 006A 9E   BA      A DELHAF LDX    DBLZER
00863P 006C 30   1F      A DELAY  LEAX   -&1,X
00864P 006E 26   FC   006C        BNE    DELAY
00865P 0070 39                    RTS

PAGE  004  ECBM64  .SA:1  ECBM64 Power up and Reset code.

00867                      *
00868                      * Tnis stuff gets block transferred into RAM during initialization.
00869                      *
00870
00871P 0071      0000    A LORAM  FDB    FCERR    EXECAD
00872P 0073 0C   A7      A        INC    TXTPTR+&1 CHRGET RAM code.
00R73P 0075 26   02   0079        BNE    CHRLOD
00874P 0077 0C   A6      A        INC    TXTPTR
00875P 0079 B6   0000    A CHRLOD LDA    >0       (Force extended addressing.)
00876P 007C 7E   070B    P        JMP    ROMLOC
00877
00878            000E    A NLORAM EQU    *-LORAM
00879
00880P 007F 7E   0000    A MIDRAM JMP    INTWDG   VIRQ WEDGE (AUTO-REPEAT & RS232)
00881P 0082 7E   005C    P        JMP    CARTRG   VFIRQ
00882P 0085      00      A        FCB    &0       TICKER (Overlays 8K version's USRJMP.)
00663P 0086      00      A        FCB    &0       (Was JMP FCERR for 8k version.)
00884P 0087      00      A        FCB    &0
00885P 0088      80      A        FCB    @200     RNDX
00886P 0089      4F      A        FCB    @117
00867P 008A      C7      A        FCB    @307
00868P 008B      52      A        FCB    @122
00889            0001    A        IFNE   ADDPRC
00890P 008C      59      A        FCB    @131
00691            000E    A NMDRAM EQU    *-MIDRAM
00892                             ENDC   IFN      ADDPRC
00893
00894P 008D      05      A HIRAM  FCB    &5        INTER-REPEAT DELAY
00895P 008E      00      A        FCB    NNRMTK    STUB0
00896P 008F      0000    A        FDB    RESLST
00897P 0091      0000    A        FDB    STMDSP
00898P 0093      00      A        FCB    NFUNTK
00899P 0094      0000    A        FDB    FUNLST
00900P 0096      0000    A        FDB    FUNDSP
00901
00902            000B    A NHIRAM EQU    *-HIRAM
00903
00904            0001    A        IFNE   METTOY
00905P 0098      28      A SIGNON FCC    /(C) 1983 DRAGON DATA LTD /
00906P 00B1      0D      A        FCB    CR
00907P 00B2      31      A        FCC    /16K BASIC INTERPRETER 1.0      /
00908P 00D1      0D      A        FCB    CR
00909P 00D2      28      A MICRO  FCC    /(C) 1983 BY MICROSOFT/
00910P 00E7      0D      A        FCB    CR
00911P 00E8      0D      A        FCB    CR
00912P 00E9      00      A        FCB    &0
00913                             ENDC   IFN      METTOY
00914
00915            0000    A        IFNE   GRPTEK
00927                       ENDC   IFN GRPTEK
00928
00929                             TTL    CHRINP - Character Input Routine
00930
00931                      *
00932                      * CHRINP inputs a character from the device specified by DEVNUM.
00933                      * The character is returned in A.
00934                      * All registers except A and CC are preserved.
00935                      * If end of file is hit, EOFFLG=.TRUE.=non-zero, and A is meaningless.

PAGE  005  ECBM64  .SA:1  ECBM64 CHRINP - Character Input Routine

00936                      *
00937                      * INCHR is called instead of CHRINP when a 7 bit code is wanted.
00938                      *
00939
00940                             XDEF   INCHR
00941P 00EA 8D   03   00EF INCHR  BSR    CHRINP   Read a character.
00942P 00EC 84   7F      A        ANDA   #@177    Clear the high order bit.
00943P 00EE 39                    RTS             Return with it
00944
00945
00946                             XDEF   CHRINP
00947P 00EF BD   0000    A CHRINP JSR    HKCHRI   RAM hook.
00948P 00F2 0F   70      A        CLR    EOFFLG   End of file flag:=.FALSE.
00949P 00F4 0D   6F      A        TST    DEVNUM   Check the device number.
00950P 00F6 27   25   011D        BEQ    KEYINP   Go handle the keyboard.
00951                      *    No, fall into CASINP to get char from
00952                      *    cassette.

PAGE  006  ECBM64  .SA:1  ECBM64 CHRINP - Character Input Routine

00954                      *
00955                      * CASINP reads a character from a cassette file.
00956                      * (Also used for downloading in the extended version.)
00957                      *
00958
00959P 00F8 0D   79      A CASINP TST    CBFCNT   Is the buffer empty?
00960P 00FA 26   03   00FF        BNE    NOTMT    No, go get a char from it.
00961P 00FC 03   70      A        COM    EOFFLG   Yes, end of file.
00962P 00FE 39                    RTS
00963
00964P 00FF 34   74      A NOTMT PSHS    U,Y,X,B Save registers.  (Save all because
00965                      *    of bossible LODBUF call.)
00966P 0101 9E   7A      A        LDX    CBFPTR   Get char from cassette buffer, update
00967P 0103 A6   80      A        LDA    ,X+      the pointer, and decrement the count.
00968P 0105 34   02      A        PSHS   A        (Save the char too.)
00969P 0107 9F   7A      A        STX    CBFPTR
00970P 0109 0A   79      A        DEC    CBFCNT
00971P 010B 26   09   0116        BNE    CASIRT   Buffer still not empty, just return.
00972P 010D 96   6F      A        LDA    DEVNUM   Doing a download?
00973P 010F 81   FD      A        CMPA   #-&3
00974P 0111 27   05   0118        BEQ    LODDNL   Yes, use different load buffer
00975                      *    routine.
00976P 0113 BD   044C    P        JSR    LODBUF   Reload the buffer.
00977P 0116 35   F6      A CASIRT PULS   D,X,Y,U,PC Get tne char into A, restore all regs
00978                      *    and return.
00979
00980P 0118 BD   0000    A LODDNL JSR    LDBUFR   Reload download buffer.
00981P 011B 20   F9   0116        BRA    CASIRT   Restore and return.

PAGE  007  ECBM64  .SA:1  ECBM64 CHRINP - Character Input Routine

00983                      *
00984                      * KEYINP reads a char from the keyboard.
00985                      *
00986
00987            0001    A        IFNE   REALIO
00988P 011D 34   14      A KEYINP PSHS   X,B      Save the registers.
00989P 011F BD   0000    A KEYILP JSR    CBLINK   Blink the cursor.
00990P 0122 BD   0000    A        JSR    POLCAT   Scan the keyboard.
00991P 0125 27   F8   011F        BEQ    KEYILP   No key, look again.
00992P 0127 C6   60      A        LDB    #@140    Have key, clear the cursor.
00993P 0129 E7   9F 0088 A        STB    [CURADR]
00994P 012D 35   94      A KEYFIN PULS   B,X,PC   Restore B and X and return with the
00995                      *    the char in A.
00996                             ENDC   IFN      REALIO
00997
00998            0001    A        IFEQ   REALIO
01001                       ENDC   IFE REALIO

PAGE  008  ECBM64  .SA:1  ECBM64 CHRINP - Character Input Routine

01003                             TTL    CHROUT - Output Character Routine
01004
01005                      *
01006                      * CHROUT sends the character in A to the device specified by DEVNUM.
01007                      * The output is suppressed if DEVNUM indicates that file input is
01008                      * in progress.  This is done so character echo, input prompts
01009                      * (such as double duestion mark for more input), etc is ignored
01010                      * while inputting file data or loading an ASCII program file.
01011                      *
01012                      * All registers except CC are preserved.
01013                      *
01014
01015                             XDEF   CHROUT
01016P 012F BD   0000    A CHROUT JSR    HKCHRO   RAM hook.
01017P 0132 34   04      A        PSHS   B        Save B.
01018P 0134 D6   6F      A        LDB    DEVNUM   Get the device number.
01019P 0136 C1   FD      A        CMPB   #-&3     Doing a download?
01020P 0138 26   02   013C        BNE    NOTDNL   No.
01021P 013A 35   84      A        PULS   B,PC     Yes, throw away the echo.
01022
01023P 013C 5C             NOTDNL INCB            See what it is.
01024P 013D 35   04      A        PULS   B        Restore B.
01025P 013F 102B FEBD    A        LBMI   LPTOUT   Send char to printer.
01026P 0143 26   2F   0174        BNE    SCROPT   Send char to screen.
01027
01028P 0145 34   16      A        PSHS   X,D      It's the cassette, save some regs.
01029P 0147 D6   78      A        LDB    CASOPN   Is the cassette
01030P 0149 5A                    DECB            open for input?
01031P 014A 27   0F   015B        BEQ    OUTRTS   Yes, throw this output away.
01032
01033                      *
01034                      * Output character to cassette file.
01035                      *
01036
01037P 014C D6   79      A CASOUT LDB    CBFCNT   Get the character count.
01038P 014E 5C                    INCB            Is the buffer full?
01039P 014F 26   02   0153        BNE    NOTFUL   No, go put the char in the buffer.
01040P 0151 8D   0A   015D        BSR    DMPBUF   Yes, write out the buffer.
01041P 0153 9E   7A      A NOTFUL LDX    CBFPTR   Get pointer into buffer.
01042P 0155 A7   80      A        STA    ,X+      Put the char away and increment the
01043P 0157 9F   7A      A        STX    CBFPTR   pointer.
01044P 0159 0C   79      A        INC    CBFCNT   Increment the count.
01045P 015B 35   96      A OUTRTS PULS   D,X,PC   Restore regs and return.
01046
01047                      *
01048                      * Here to dump the cassette buffer to tape.
01049                      *
01050
01051P 015D C6   01      A DMPBUF LDB    #&1      Set block type to data.
01052P 015F D7   7C      A WRTEOF STB    BLKTYP
01053P 0161 8E   0000    A        LDX    #CASBUF  Set address of data for WRTBLK.
01054P 0164 9F   7E      A        STX    CBUFAD
01055P 0166 D6   79      A        LDB    CBFCNT   Set the block length.
01056P 0168 D7   7D      A        STB    BLKLEN
01057P 016A 34   62      A        PSHS   U,Y,A    Save the rest.
01058P 016C BD   0576    P        JSR    WRTBLK   Write block out.
01059P 016F 35   62      A        PULS   A,Y,U    Restore regs.
01060P 0171 7E   0467    P        JMP    MRKMT    Mark the buffer as empty.

PAGE  009  ECBM64  .SA:1  ECBM64 CHROUT - Output Character Routine

01062                      *
01063                      * Ouput character to screen.
01064                      *
01065
01066            0174    P SCROPT EQU    *
01067            0001    A        IFNE   REALIO
01068P 0174 BD   0000    A        JSR    SAMALP   Switch to text mode.
01069P 0177 7E   0000    A        JMP    SCROUT   Go to the screen driver.
01070                             ENDC   IFN      REALIO
01071
01072            0001    A        IFEQ   REALIO
01104                       ENDC   IFE REALIO

PAGE  010  ECBM64  .SA:1  ECBM64 CHROUT - Output Character Routine

01106                             TTL    DEVPRM - Return Device Parameters
01107
01108                      *
01109                      * DEVPRM returns the following device parameters:
01110                      *
01111                      * DEVPOS - The position of the print head or it's equivalent.
01112                      * DEVWID - The line width of the device.
01113                      * DEVLCF - The column number where the last comma field starts.
01114                      * DEVCFW - The comma field width.
01115                      * SPCIO  -  .TRUE. for special I/O handling in PRINT and INPUT code.
01116                      *
01117                      * All registers except CC are preserved.
01118                      * On exit, Z=1 if the device has infinite width (DEVWID=0).
01119                      *
01120
01121                             XDEF   DEVPRM
01122P 017A BD   0000    A DEVPRM JSR    HKDPRM   RAM hook.
01123P 017D 34   16      A        PSHS   X,D      Save registers.
01124P 017F 0F   6E      A        CLR    SPCIO    Special I/O flag=.FALSE.
01125P 0181 96   6F      A        LDA    DEVNUM   Set the device number.
01126P 0183 27   09   018E        BEQ    SCRPRM   Go get the screen parms.
01127P 0185 4C                    INCA
01128P 0186 27   17   019F        BEQ    CASPRM   Go get cassette parms.
01129
01130                      *
01131                      * Get line printer parameters.
01132                      *
01133
01134P 0188 9E   99      A LPTPRM LDX    LPTCFW   Get comma field width and last comma
01135                      *    field.
01136P 018A DC   9B      A        LDD    LPTWID   Get width and current position.
01137P 018C 20   09   0197        BRA    DEVFIN   Go put it all away.
01138
01139                      *
01140                      * Get screen parms.
01141                      * The width, comma field width, and last comma field are fixed.
01142                      * The position is obtained by reading tne cursor address.
01143                      *
01144
01145P 018E D6   89      A SCRPRM LDB    CURADR+&1 Get low order of cursor address.
01146P 0190 C4   1F      A        ANDB   #&31     Determine the column number. This
01147                      *    only works because the line width
01148                      *    is a power of two.
01149P 0192 8E   1010    A        LDX    #&16*&256+&16 Field width and last comma field.
01150P 0195 86   20      A        LDA    #&32     Set up the width.
01151                             XDEF   DEVFIN
01152P 0197 9F   6A      A DEVFIN STX    DEVCFW   Put away comma field width and last
01153                      *    comma field.
01154P 0199 D7   6C      A        STB    DEVPOS   Put away the position.
01155P 019B 97   6D      A        STA    DEVWID   Put away the width and set the Z bit
01156                      *    for infinite width devices.
01157P 019D 35   96      A        PULS   D,X,PC   Restore and return.
01158
01159
01160                      *
01161                      * Get tne cassette parms.
01162                      * They are all fixed at values which are necessary for the special
01163                      * I/O code to work properly.  SPCIO gets set TRUE.

PAGE  011  ECBM64  .SA:1  ECBM64 DEVPRM - Return Device Parameters

01164                      *
01165
01166P 019F 03   6E      A CASPRM COM    SPCIO    Speciai I/O flag:=.TRUE.
01167P 01A1 8E   0100    A        LDX    #&256    Comma field width:=1, last comma
01168                      *    field:=0 but don't really care.
01169P 01A4 4F                    CLRA            Width:=infinite and position:=0.
01170P 01A5 5F                    CLRB
01171P 01A6 20   EF   0197        BRA    DEVFIN   Go put them away.

PAGE  012  ECBM64  .SA:1  ECBM64 DEVPRM - Return Device Parameters

01173                             TTL    INLIN - The line input routine.
01174
01175P 01A8 BD   065C    P INLCLS JSR    GRNCHR   Clear the screen and start over.
01176                             XDEF   INLIN
01177P 01AB BD   0000    A INLIN  JSR    HKINLN   RAM hook.
01178P 01AE 0F   87      A        CLR    INKCHR   Throw away INKEY's character.
01179P 01B0 8E   0000    A        LDX    #BUF     Point to the start of the line buffer.
01180P 01B3 C6   01      A        LDB    #&1      Init the character count.
01181P 01B5 BD   00EA    P INLINC JSR    INCHR    Read a character.
01182P 01B8 0D   70      A        TST    EOFFLG   End of file reached?
01183P 01BA 26   2B   01E7        BNE    INLDON   Yes, go finish up.
01184P 01BC 0D   6F      A        TST    DEVNUM   Reading from the keyboard?
01185P 01BE 26   23   01E3        BNE    NOEDIT   No, don't check for editing chars.
01186P 01C0 81   0C      A        CMPA   #@14     CLEAR key?
01187P 01C2 27   E4   01A8        BEQ    INLCLS   Yes, clear screen and start over.
01188P 01C4 81   08      A        CMPA   #CHRDEL  Character delete?
01189P 01C6 26   07   01CF        BNE    NTCDEL   No.
01190P 01C8 5A                    DECB            Yes, at beginning of line?
01191P 01C9 27   E0   01AB        BEQ    INLIN    Yes, just start over.
01192P 01CB 30   1F      A        LEAX   -&1,X    Backup the buffer pointer.
01193P 01CD 20   34   0203        BRA    ECHOIT   Output the CHRDEL to the screen to
01194                      *    backup the cursor and go back for
01195                      *    another char.
01196
01197P 01CF 81   15      A NTCDEL CMPA   #LINDEL  Is it a line delete?
01198P 01D1 26   0A   01DD        BNE    NTLDEL   No
01199P 01D3 5A             RUBLIN DECB            Yes, send CHRDELs to the screen
01200P 01D4 27   D5   01AB        BEQ    INLIN    until all characters have been erased.
01201P 01D6 86   08      A        LDA    #CHRDEL  Then go start all over.
01202P 01D8 BD   012F    P        JSR    CHROUT
01203P 01DB 20   F6   01D3        BRA    RUBLIN
01204
01205P 01DD 81   03      A NTLDEL CMPA   #BRKCHR  Break character? (Llke control-C)
01206P 01DF 1A   01               SEC             (Set the carry just in case.)
01207P 01E1 27   05   01E8        BEQ    FININL   Yes
01208
01209P 01E3 81   0D      A NOEDIT CMPA   #CR      Carriage return?
01210P 01E5 26   0D   01F4        BNE    NOTCR    No
01211P 01E7 4F             INLDON CLRA            (Clear carry.)  Clear control-C flag.
01212P 01E8 34   01      A FININL PSHS   CC       Save the control-C flag.
01213P 01EA BD   0000    A        JSR    CRDO     Start a new line.
01214P 01ED 6F   84      A        CLR    ,X       Put a zero in to mark the end.
01215P 01EF 8E   FFFF    A        LDX    #BUF-&1  Set up a pointer for CRUNCH.
01216P 01F2 35   81      A        PULS   CC,PC    Get the control-C flag and return.
01217
01218                      *
01219                      * The character is not a special char.  Weed out bad ones and store
01220                      * the good ones in the buffer.
01221                      *
01222P 01F4 81   20      A NOTCR  CMPA   #SPACE   Those below space and above lower
01223P 01F6 25   BD   01B5        BCS    INLINC   case z are thrown away.
01224P 01F8 81   7B      A        CMPA   #'z+&1
01225P 01FA 24   B9   01B5        BCC    INLINC
01226P 01FC C1   FA      A GOODCH CMPB   #BUFLEN  Would this char fill the buffer?
01227P 01FE 24   B5   01B5        BCC    INLINC   Yes, ignore it then because one
01228                      *    byte must be reserved for the zero
01229                      *    terminator inserted when a carriage
01230                      *    return is typed.

PAGE  013  ECBM64  .SA:1  ECBM64 INLIN - The line input routine.

01231P 0200 A7   80      A        STA    ,X+      No, store the character, bump the
01232P 0202 5C                    INCB            pointer, and increment the count.
01233P 0203 BD   012F    P ECHOIT JSR    CHROUT   Echo the char and go back for more.
01234P 0206 20   AD   01B5        BRA    INLINC
01235
01236                             TTL    OPNICK and OPNOCK
01237
01238                      *
01239                      * Make sure device specified by DEVNUM is open for input.
01240                      *
01241
01242                             XDEF   OPNICK
01243P 0208 BD   0000    A OPNICK JSR    HKCKDI   RAM hook.
01244P 020B 96   6F      A        LDA    DEVNUM   Get the device number.
01245P 020D 27   21   0230        BEQ    OKOPN    Keyboard is always open.
01246P 020F 4C                    INCA            Is is the printer?
01247P 0210 26   0C   021E        BNE    GOBMER   Yes, give Bad Mode error.
01248P 0212 96   78      A        LDA    CASOPN   Is the cassette open?
01249P 0214 26   05   021B        BNE    CHKMOD   Yes, do check the open mode.
01250                             XDEF   NOERR
01251P 0216 C6   00      A NOERR  LDB    #ERRNO   No, give Not Open error.
01252P 0218 7E   0000    A        JMP    ERROR
01253
01254P 021B 4A             CHKMOD DECA            Is it open for input?
01255P 021C 27   12   0230        BEQ    OKOPN    Yes, OK.
01256P 021E 7E   042D    P GOBMER JMP    BMERR    No, give Bad Mode error.
01257
01258
01259                      *
01260                      * Make sure device is open for output.
01261                      *
01262
01263                             XDEF   OPNOCK
01264P 0221 BD   0000    A OPNOCK JSR    HKCKDO   RAM hook.
01265P 0224 96   6F      A        LDA    DEVNUM   Get the device number.
01266P 0226 4C                    INCA
01267P 0227 26   07   0230        BNE    OKOPN    Screen and printer are always open.
01268P 0229 96   78      A        LDA    CASOPN   Is the casette open?
01269P 022B 27   E9   0216        BEQ    NOERR    No, give Not Open error.
01270P 022D 4A                    DECA            Yes, is it open for output?
01271P 022E 27   EE   021E        BEQ    GOBMER   No, give mode error.
01272P 0230 39             OKOPN  RTS             Yes, all is OK.
01273

PAGE  014  ECBM64  .SA:1  ECBM64 OPNICK and OPNOCK

01275                             TTL    The CLOSE code.
01276
01277                             XDEF   CLOSE
01278P 0231 27   0E   0241 CLOSE  BEQ    CLSALL   Nothing specified, close everything.
01279P 0233 BD   03BC    P        JSR    GETDNM   Read a device number.
01280P 0236 8D   10   0248 NXTCLO BSR    CLOSIT   Close this device.
01281P 0238 9D   A5      A        JSR    CHRGOT   Another number specified?
01282P 023A 27   2A   0266        BEQ    CLSRTS   No, all done.
01283P 023C BD   03B9    P        JSR    GETCDN   Yes, read comma and device number.
01284P 023F 20   F5   0236        BRA    NXTCLO   Go close it.
01285
01286                             XDEF   CLSALL
01287P 0241 BD   0000    A CLSALL JSR    HKCLSA   RAM hook.
01288                             XDEF   CLSCAS
01289P 0244 86   FF      A CLSCAS LDA    #-&1     Only thing requiring attention is
01290P 0246 97   6F      A        STA    DEVNUM   the cassette.
01291
01292                             XDEF   CLOSIT
01293P 0248 BD   0000    A CLOSIT JSR    HKCLS1   RAM hook.
01294P 024B 96   6F      A        LDA    DEVNUM   A:=device number.
01295P 024D 0F   6F      A        CLR    DEVNUM   Clear it so normal output occurs when
01296                      *    close is finished.
01297P 024F 4C                    INCA            Do nothing if it isn't the cassette.
01298P 0250 26   14   0266        BNE    CLSRTS
01299P 0252 96   78      A        LDA    CASOPN   Is the casette open for output?
01300P 0254 81   02      A        CMPA   #&2
01301P 0256 26   0C   0264        BNE    MRKCLS   No, just mark it as closed.
01302P 0258 96   79      A        LDA    CBFCNT   Yes, is there stuff in the buffer?
01303P 025A 27   03   025F        BEQ    EOFWRT   No.
01304P 025C BD   015D    P        JSR    DMPBUF   Yes, dump the buffer.
01305                             XDEF   EOFWRT
01306P 025F C6   FF      A EOFWRT LDB    #@377    Set block type to end of file.
01307P 0261 BD   015F    P        JSR    WRTEOF   Write an EOF block.
01308P 0264 0F   78      A MRKCLS CLR    CASOPN   Mark the cassette as closed.
01309P 0266 39             CLSRTS RTS
01310

PAGE  015  ECBM64  .SA:1  ECBM64 The CLOSE code.

01312                             TTL    CSAVE - Save program on cassette.
01313
01314                             XDEF   CSAVE
01315P 0267 81   4D      A CSAVE  CMPA   #'M      Is it CSAVEM?
01316P 0269 1027 FD93    A        LBEQ   CSAVEM   Yes, go handle it.
01317P 026D BD   038F    P        JSR    GETFLN   Read the filename.
01318P 0270 9D   A5      A        JSR    CHRGOT   End of statement?
01319P 0272 27   16   028A        BEQ    BCSAVE   Yes, do binary CSAVE.
01320P 0274 BD   0000    A        JSR    CHKCOM   No, must be followed bya comma and
01321P 0277                       SYNCHK 'A       an "A" for ASCII.
01322P 027C      E8   0266        BNE    CLSRTS   If statement doesn't end now let
01323                      *    NEWSTT give a syntax error.
01324P 027E 4F                    CLRA            Say it's a BASIC program.
01325P 027F BD     0473  P        JSR    OPNASC   Open ASCII, gapped output file.
01326P 0282 86     FF    A        LDA    #CASNUM  Make the listing go to cassette.
01327P 0284 97     6F    A        STA    DEVNUM
01328P 0286 4F                    CLRA            Make the LIST code see a terminator
01329                      *    so the whole program gets saved.
01330P 0287 7E     0000  A        JMP    LIST     The LIST code will do the rest.
01331                      *    When LIST is done it will close the
01332                      *    file.
01333
01334                      *
01335                      * Here to do binary CSAVE.
01336                      *
01337
01338P 028A 4F             BCSAVE CLRA            Say it's a BASIC program.
01339P 028B 9E   8A      A        LDX    DBLZER   Say not ASCII or gapped.
01340P 028D BD   0476    P        JSR    OPNCSO   Open cassette file for output.
01341P 0290 0F   78      A        CLR    CASOPN   Mark cassette as closed since OPNCSO
01342                      *    marked it as open.
01343P 0292 0C   7C      A        INC    BLKTYP   Set block type to data.
01344P 0294 BD   0000    A        JSR    WRTLDR   Turn on the cassette and write a
01345                      *    leader.
01346P 0297 9E   19      A        LDX    TXTTAB   Get the starting point.
01347
01346P 0299 9F   7E      A BCSLOP STX    CBUFAD   Store buffer address for BLKOUT.
01349P 029B 86   FF      A        LDA    #&255    Assume it's a full block.
01350P 029D 97   7D      A        STA    BLKLEN
01351P 029F DC   1B      A        LDD    VARTAB   How many more to write?
01352P 02A1 93   7E      A        SUBD   CBUFAD
01353P 02A3 27   0D   02B2        BEQ    FINSAV   All done.
01354P 02A5 1083 00FF    A        CMPD   #&255    Is it a full block?
01355P 02A9 24   02   02AD        BHS    FULBLK   Yes.
01356P 02AB D7   7D      A        STB    BLKLEN   No, set actual block length.
01357P 02AD BD   057E    P FULBLK JSR    BLKOUT   Output the block.
01358P 02B0 20   E7   0299        BRA    BCSLOP   So back for more.  BLKOUT set X
01359                      *    to [CBUFAD]+[BLKLEN].
01360
01361                             XDEF   FINSAV
01362P 02B2 00   7C      A FINSAV NEG    BLKTYP   Set block type to EOF.  (It was 1
01363                      *    for data, now -1 for eof.
01364P 02B4 0F   7D      A        CLR    BLKLEN   No data to go out.
01365P 02B6 7E   0579    P        JMP    BLKOFF   Write EOF block, turn off motor, and
01366                      *    return to NEWSTT.
01367

PAGE  016  ECBM64  .SA:1  ECBM64 CSAVE - Save program on cassette.

01369                             TTL    CLOAD - Load a program from cassette.
01370
01371                             XDEF   CLOAD
01372P 02B9 0F   78      A CLOAD  CLR    CASOPN   Force the cassette closed.  The
01373                      *    last block of an output file may
01374                      *    be lost but we don't have enough
01375                      *    bytes to flush the buffer and the
01376                      *    user has probably put the cassette
01377                      *    in play mode anyway.
01378P 02BB 81   4D      A        CMPA   #'M      Do they want to load a machine
01379                      *    language file?
01380P 02BD 1027 FD3F    A        LBEQ   CLOADM   Yes, go do it.
01381P 02C1 32   62      A        LEAS   &2,S     No, get rid of NEWSTT return address.
0182P  02C3 BD   03DC    P        JSR    FLNTRM   Read the filename.
01383P 02C6 BD   045F    P        JSR    OPNCSI   Open the cassette for input.
01384P 02C9 7D   0000    A        TST    GAPFLG   Is it a gapped file?
01365P 02CC 27   1D   02EB        BEQ    BCLOD    No, go do binary CLOAD.
01366
01387                      *
01388                      * Here to load ASCII file.
01389                      *
01390
01391P 02CE B6   0000    A        LDA    ASCFLG   Make sure it is ASCII.
01392P 02D1 27   1D   02F0        BEQ    BMERR1   If not give mode error.
01393P 02D3 BD   0000    A        JSR    SCRTCH   Get rid of the existing program.
01394P 02D6 86   FF      A        LDA    #CASNUM  Make program come from cassette.
01395P 02D8 97   6F      A        STA    DEVNUM
01396P 02DA 0C   78      A        INC    CASOPN   Mark the cassette as open for input.
01397P 02DC BD   044C    P        JSR    LODBUF   Load the buffer and let main do the
01396P 02DF 7E   0000    A        JMP    MAIN     actual loading.
01399
01400                      *
01401                      * Here when MAIN sees the end of file.
01402                      *
01403
01404                             XDEF   FINLOD
01405P 02E2 BD   0000    A FINLOD JSR    HKFNLD   RAM hook.
01406P 02E5 BD   0248    P        JSR    CLOSIT   Close the cassette file.
01407P 02E8 7E   0000    A        JMP    READY    Go print "OK".
01408
01409                      *
01410                      * Here to load a binary cassette file.
01411                      *
01412
01413P 02EB B6   0000    A BCLOD  LDA    FILTYP   It must be a BASIC program.
01414P 02EE 27   03   02F3        BEQ    DOBCLD   It is.
01415P 02F0 7E   042D    P BMERR1 JMP    BMERR    It isn't, give a mode error.
01416
01417P 02F3 BD   0000    A DOBCLD JSR    SCRTCH   Wipe out the existing program.
01416P 02F6 BD   0000    A        JSR    CSRDON   Start cassette and get into bit sync.
01419P 02F9 9E   19      A        LDX    TXTTAB   Set up first load address.
01420
01421P 02FB 9F   7E      A CLDLOP STX    CBUFAD   Set load address for BLKINV.
01422P 02FD DC   7E      A        LDD    CBUFAD   There must be another 256 bytes
01423P 02FF 4C                    INCA            available or we give an OM error.
01424P 0300 BD   0000    A        JSR    REASON   (Yes, it is possible that they won't
01425                      *    be able to load a program they saved
01426                      *    if it was a very tight fit, but they

PAGE  017  ECBM64  .SA:1  ECBM64 CLOAD - Load a program from cassette.

01427                      *    wouldn't be able to run it anyway.)
01428P 0303 BD   0523    P        JSR    BLKIN    Load the next block.
01429P 0306 26   13   031B        BNE    WIPER    An error occured.
01430P 0308 96   7C      A        LDA    BLKTYP   No error, get the block type.
01431P 030A 27   0F   031B        BEQ    WIPER    Can't have file header in middle of
01432                      *    file.
01433P 030C 2A   ED   02FB        BPL    CLDLOP   Data record so continue. Note that
01434                      *    X has load address for next block.
01435P 030E 9F   1B      A        STX    VARTAB   End of file, set end of program.
01436P 0310 8D   40   0352        BSR    GOCOFF   Turn off the motor.
01437P 0312 8E   FFFE    A        LDX    #REDDY-&2 Print "OK" since we won't be going
01438P 0315 BD   0000    A        JSR    STROUT   through READY.  (NOTE: REDDY-2 is
01439                      *   used to force a carriage return.)
01440P 0318 7E   0000    A        JMP    FINI     Go fix up the links, etc.  End up
01441                      *    at MAIN.
01442
01443P 031B BD   0000    A WIPER  JSR    SCRTCH   Error occured, wipe out wnatever did
01444                      *    load so garbage isn't left around.
01445P 031E 7E   0430    P GOIOER JMP    IOERR
01446

