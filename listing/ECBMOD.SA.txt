PAGE  001  ECBCOM  .SA:0  ECBMOD Extension ROM Direct Page RAM

00700                             OPT    L,LLE=120
00701                             NAM    ECBMOD
00702
00703                      **********************************************************************
00704                      *                                                                    *
00705                      *    Copyright 1982 by Microsoft Corporation, all rights reserved    *
00706                      *                                                                    *
00707                      **********************************************************************
00708
00709                             TTL    External Declarations
00710
00711                             XREF   ALPHLK,ASC2,ASCFLG
00712                             XREF   BOOT64,BITIN,BUF
00713                             XREF   CASBUF,CASOFF,CASON,CBIN,CBLINK,CBOUT,CHKCLS,CHKCOM,CHKOPN
00714                             XREF   CHR$DO,CLOADM,COMBYT,CONINT,CRDO,CSAVEM,CSFNAM,CSRDON
00715                             XREF   DBNCNT
00716                             XREF   ENDHKS,ERRAO,ERRBM,ERRDN,ERRIO,ERRNO,ERROR,EVLADR
00717                             XREF   FCERR,FILNAM,FILTYP,FINI,FNAMLN,FRESTR,FRMEVL,FRMNUM
00718                             XREF   FUNDSP,FUNLST
00719                             XREF   GAPFLG,GETBYT,GIVABF,GOPTNW
00720                             XREF   HDRLEN,HKBRKC,HRCHRI,HRCHRO,HKCKDI,HRCKDO,HKCLS,HKCLS1
00721                             XREF   HKCLSA,HKDNCK,HKDPRM,HKEOF,HKFNLD,HKINLN,HKOPEN,HOOKS
00722                             XREF   HRDINI
00723                             XREF   INTCNV,INTIDX,ISCNTC,INTWDG
00724                             XREF   JOYIN
00725                             XREF   LDBUFR,LIST,LOADAD,LPTOUT
00726                             XREF   MAIN
00727                             XREF   NFUNTK,NNRMTK,NRTSH3,NRTSHK,NZLINK
00728                             XREF   OFFTK,ONTK
00729                             XREF   PINIT,POLCAT,POTVAL
00730                             XREF   READY,REASON,REDDY,RESLST,ROLTBL
00731                             XREF   SAMALP,SCROUT,SCRTCH,SFTINI,SNERR,SNGFLT
00732                             XREF   STKINI,STMDSP,STROUT,STRTAD,STUBO,SYNCHR
00733                             XREF   TEMPST
00734                             XREF   USRTAB
00735                             XREF   VIRQ
00736                             XREF   WRTLDR
00737                             XREF   XRRUN,XRSLWC
00738
00739            0001    A        IFEQ   REALIO
00744                       ENDC   IFE REALIO
00745
00746                             TTL    Equates
00747
00748                             XDEF   SCRADR
00749            0400    A SCRADR EQU    @2000    Address of screen memory (400 hex).
00750
00751            0001    A        IFNE   METTOY
00752                             XDEF   PIA0AD
00753            FF00    A PIA0AD EQU    @177400  PIA0, side A, data reg.  (FF00)
00754                             ENDC   IFN      METTOY
00755            0000    A        IFNE   GRPTEK
00758                       ENDC   IFN GRPTEK
00759                             XDEF   PIA0AC
00760            FF01    A PIA0AC EQU    PIA0AD+&1 PIA0, side A, control reg.
00761                             XDEF   PIA0BD
00762            FF02    A PIA0BD EQU    PIA0AC+&1 PIA0, side B, data reg.
00763                             XDEF   PIA0BC

PAGE  002  ECBMOD  .SA:1 ECBMOD Equates

00764            FF03    A PIA0BC EQU    PIA0BD+&1 PIA0, side B, control reg.
00765
00766            0001    A        IFNE   METTOY
00767                             XDEF   PIA1AD
00768            FF20    A PIA1AD EQU    @177440  PIA1, side A, data reg.  (FF20)
00769                             ENDC   IFN      METTOY
00770            0000    A        IFNE   GRPTEK
00773                       ENDC   IFN GRPTEK
00774                             XDEF   PIA1AC
00775            FF21    A PIA1AC EQU    PIA1AD+&1 PIA1, side A, control reg.
00776                             XDEF   PIA1BD
00777            FF22    A PIA1BD EQU    PIA1AC+&1 PIA1, side B, data reg.
00778                             XDEF   PIA1BC
00779            FF23    A PIA1BC EQU    PIA1BD+&1 PIA1, side B, conrtrol reg.
00780
00781            C000    A CARTRM EQU    @140000  Address of cartridge ROM.  (C000)
00782            8000    A EXTROM EQU    @100000  Address of extension ROM.  (8000)
00783
00784                             XDEF   SAM
00785            FFC0    A SAM    EQU    @177700  Address of SAM chip.  (FFC0)
00786
00787            C000    A DSKROM EQU    @140000  The address of the disk ROM.  (C000)
00788
00789                             TTL    Power up and Reset code.
00790
00791                      *
00792                      * Here on RESET and power up after executing HRDINI routine.
00793                      *
00794
00795P 0000 10CE 00FA    A HRDRT1 LDS    #BUF+BUFLEN Set up a temporary stack.
00796            0001    A        IFNE   REALIO
00797P 0004 86   37      A        LDA    #@67     Enable the cartridge interrupt
00798P 0006 B7   FF23    A        STA    PIA1BC   at the PIA.
00799                             ENDC   IFN      REALIO
00800P 0009 96   71      A        LDA    RSTFLG   Is the restart flag set?
00801P 000B 81   55      A        CMPA   #@125
00802P 000D 26   10   001F        BNE    INIT     No, must go through initialization.
00803P 000F 9E   72      A        LDX    RSTVEC   Yes, does the restart vector point
00804P 0011 A6   84      A        LDA    ,X       to a NOP instruction?
00805P 0013 81   12      A        CMPA   #@22
00806P 0015 26   08   001F        BNE    INIT     No, must go through initialization.
00807                      *    This check is made so that if the
00808                      *    user pulls out a cartridge and hits
00809                      *    reset we won't jump to the restart
00810                      *    address where there is no longer
00811                      *    any code.
00812P 0017 6E   84      A        JMP    ,X       Restart the current program.
00813
00814                      *
00815                      * Here on reset and power up.
00816                      *
00817
00818                             XDEF   POWRUP
00819P 0019 31   8C E4     POWRUP LEAY   HRDRT1,PCR Set up return address for HRDINI.
00820P 001C 7E   0000    A        JMP    HRDINI   (Can't use stack since RAM is no
00821                      •    good until the SAM is initialized.)
00822                      *
00823                      * Here to perform BASIC initialization.

PAGE  003  ECBMOD  .SA:1  ECBMOD Power up and Reset code.

00824                      *
00825
00826                             XDEF   INIT
00827            001F    P INIT   EQU    *
00828            0001    A        IFNE   REALIO
00829P 001F  8E  0401    A        LDX    #SCRADR+&1 Clear RAM from 0 to the start of the
00630P 0022  6F  83      A CLRRAM CLR    ,--X     screen memory.
00831P 0024  30  01      A        LEAX   &1,X     (This roundabout method saves bytes
00832P 0026  26  FA   0022        BNE    CLRRAM   over the more obvious way.)
00833P 0028  BD  06DC    P        JSR    GRNCHR   Clear the screen and make X point to
00834                      *    the first byte following the screen
00835                      *    memory.
00836                             ENDC   IFN      REALIO
00837             0001   A        IFEQ   REALIO
00839                       ENDC   IFE REALIO
00840P 002B  6F   80     A        CLR    ,X+      Put a zero below TXTTAB and set it
00841P 002D  9F   19     A        STX    TXTTAB   up.
00842
00843                      *
00844                      * Here to find the top of RAM.
00845                      *
00846
00847            0001    A        IFNE   REALIO
00848P 002F A6   02      A MEMLOP LDA    &2,X     Get byte from memory.
00849P 0031 43                    COMA            Invert all  the bits.
00850P 0032 A7   02      A        STA    &2,X     Store the complement.
00851P 0034 A1   02      A        CMPA   &2,X     Did it store OK?
00852P 0036 26   06   003E        BNE    HAVEND   No, this byte is not useable RAM.
00853P 0038 30   01      A        LEAX   &1,X     Yes, bump the address.
00854P 003A 63   01      A        COM    &1,X     Restore the original contents.
00655P 003C 20   F1   002F        BRA    MEMLOP   Look at the next byte.
00856                             ENDC   IFN      REALIO
00857
00658            0001    A        IFEQ   REALIO
00861                       ENDC   IFE REALIO
00862P 003E 9F   74      A HAVEND STX    ENDMEM   Set pointer to end of memory.  Don't
00863                      *    use last good byte so VAL trick will
00864                      *    work OK in the degenerate case.
00865P 0040 9F   27      A        STX    MEMSIZ   Mark end of BASIC's memory.
00666P 0042 9F   23      A        STX    FRETOP   This is the end of string space also.
00867P 0044 30   89 FF38 A        LEAX   -STRSPC,X Set the bottom of string space.
00868P 0048 9F   21      A        STX    STKTOP   This is the top of the stack.
00869P 004A 1F   14      A        TFR    X,S      Switch from temp stack to BASIC's
00870                      *    real stack.
00871P 004C BD   0000    A        JSR    SFTINI   Init the I/O driver routines.
00872            0001    A        IFNE   REALIO
00873P 004F 8E   00EC    P        LDX    #LORAM   Initialize direct page RAM.
00874P 0052 CE   009D    A        LDU    #EXECAD
00875P 0055 C6   0E      A        LDB    #NLORAM
00676P 0057 BD   0431    P        JSR    COPLOP
00877P 005A CE   0000    A        LDU    #VIRQ    Initialize RAM off the direct page.
00878P 005D C6   1E      A        LDB    #NHIRAM
00879P 005F BD   0431    P        JSR    COPLOP
00880P 0062 8E   0000    A        LDX    #SNERR   X:=SNERR for intializing the dispatch
00881                      *    addresses of stub 1.
00882                             ENDC   IFN      REALIO
00863            0001    A        IFEQ   REALIO
00890                       ENDC   IFE REALIO

PAGE  004  ECBMOD  .SA:1  ECBMOD Power up and Reset code.

00891P 0065 AF   43      A        STX    &3, U    Init the stub 1 dispatch addresses.
00892P 0067 AF   48      A        STX    &8,U
00893            0001    A        IFNE   REALIO
00894P 0069 8E   0000    A        LDX    #HOOKS   Initialize the extension hooks by
00895                      *    putting in RTS instructions.
00896P 006C CC   3900    A        LDD    #$3900+NRTSH3 A:=RTS opcode,
00897                      *    B:=number of bytes
00898                      *    to initialize.
00899                      *    (Add $Z since NRTSHK is external.)
00900P 006F A7   80      A INIHKS STA    ,X+      (Note that putting RTS instructions
00901P 0071 5A                    DECB            into all three bytes of each hook is
00902P 0072 26   FB   006F        BNE    INIHKS   OK and saves bytes here.)
00903P 0074 B7   0000    A        STA    NZLINK   Make NZLINK nonzero for CHEAD.
00904                             ENDC   IFN      REALIO
00905P 0077 BD   0000    A        JSR    SCRTCH   Set up everthing else.
00906P 007A BD   0000    A        JSR    XRRUN    Set up the PLAY and DRAW defaults.
00907P 007D 8E   0000    A        LDX    #USRTAB  Put the address of USRTAB into
00908P 0080 9F   B0      A        STX    USTBAD   USTBAD so USRTAB can be referenced
00909                      *    indirectly through USTBAD.
00910P 0082 CE   0000    A        LDU    #FCERR   Init all USRTAB entries so they
00911P 0085 C6   0A      A        LDB    #&10     dispatch to FCERR unless explicitly
00912P 0087 EF   81      A FCUSLP STU    ,X++     defined by the user.
00913P 0089 5A                    DECB
00914P 008A 26   FB   0087        BNE    FCUSLP
00915            0001    A        IFNE   REALIO
00916P 008C BD   0000    A        JSR    PINIT    Init for graphics code.
00917P 008F B6   FF03    A        LDA    PIA0BC   Enable the 60 Hertz interrupt.
00918P 0092 8A   01      A        ORA    #&1
00919P 0094 B7   FF03    A        STA    PIA0BC
00920P 0097 8E   444B    A        LDX    #'D*&256+'K Is there a disk ROM in the machine?
00921P 009A BC   C000    A        CMPX   DSKROM
00922P 009D 1027 BF61    A        LBEQ   DSKROM+&2 Yes, go to its initialization code.
00923                             ENDC   IFN      REALIO

PAGE  005  ECBMOD  .SA:1  ECBMOD Power up and Reset code.

00925P 00A1 1C   AF      A        ANDCC  #$FF!X(F!+I) Allow the cartridge to interrupt now
00926                      *    before displaying the sign on message.
00927P 00A3 8E   0117    P        LDX    #SIGNON-&1 Print the sign on message.
00928P 00A6 BD   0000    A        JSR    STROUT
00929P 00A9 8E   00B4    P        LDX    #BASRST  Set the restart vector.
00930P 00AC 9F   72      A        STX    RSTVEC
00931                             XDEF   FINIT
00932P 00AE 86   55      A FINIT  LDA    #@125    Set the restart flag.
00933P 00B0 97   71      A        STA    RSTFLG
00934P 00B2 20   17   00CB        BRA    GORDY    Go to command level and say "OK".
00935
00936                      *
00937                      * Here to restart BASIC.
00938                      *
00939
00940                             XDEF   BASRST
00941P 00B4 12             BASRST NOP             The NOP required of all restart entry
00942                      *    points.
00943P 00B5 0F   E3      A        CLR    DURCNT   Clear the PLAY note duration count
00944P 00B7 0F   E4      A        CLR    DURCNT+&1 so interrupts don't think we are
00945                      *    still playing the note.
00946P 00B9 B6   FF03    A        LDA    PIA0BC   Enable the 60 hertz interrupt.
00947P 00BC 8A   01      A        ORA    #&1
00948P 00BE B7   FF03    A        STA    PIA0BC
00949P 00C1 0F   6F      A        CLR    DEVNUM   Make sure output goes to screen and
00950                      *    input comes from keyboard.
00951P 00C3 BD   0000    A        JSR    STKINI   Reset the stack and things.
00952P 00C6 1C   AF      A        ANDCC  #$FF!X(F!+I) Enable interrupts.
00953P 00C8 BD   06DC    P        JSR    GRNCHR   Clear the screen.
00954P 00CB 7E   0000    A GORDY  JMP    READY    Go say "OK".
00955
00956
00957                      *
00958                      * Here on a FIRQ to handle the cartridge interrupt.
00959                      *
00960
00961P 00CE 7D   FF23    A CARTRG TST    PIA1BC   Did the cartridge cause the interrupt?
00962P 00D1 2B   01   00D4        BMI    GOCART   Yes.
00963P 00D3 3B                    RTI             No, return from the interrupt.
00964
00965P 00D4 BD   00E5    P GOCART JSR    DELHAF   Delay for about a second to let the
00966P 00D7 BD   00E5    p        JSR    DELHAF   user finish installing the cartridge.
00967P 00DA 31   8C 03            LEAY   <HRDRT2,PCR Init the hardware.  HRDINI leaves the
00968P 00DD 7E   0000    A        JMP    HRDINI   cartridge interrupt disabled.
00969P 00E0 0F   71      A HRDRT2 CLR    RSTFLG   Don't allow BASIC to be restarted.
00970P 00E2 7E   C000    A        JMP    CARTRM   Go execute the cartrige program.
00971
00972                      *
00973                      * Delay for about one half second.
00974                      *
00975
00976                             XDEF   DELHAF
00977P 00E5 9E   8A      A DELHAF LDX    DBLZER
00978P 00E7 30   1F      A DELAY  LEAX   -&1,X
00979P 00E9 26   FC   00E7        BNE    DELAY
00980P 00EB 39                    RTS

PAGE  006  ECBMOD  .SA:1  ECBMOD Power up and Reset code.

00982                      *
0098                       * This stuff gets block transferred into RAM during initialization.
00984                      *
00985
00986P 00EC      0000    A LORAM  FDB    BOOT64   EXECAD FOR 64K INITIALISATION
00987P 00EE 0C   A7      A        INC    TXTPTR+&1 CHRGET RAM code.
00988P 00F0 26   02   00F4        BNE    CHRLOD
00989P 00F2 0C   A6      A        INC    TXTPTR
00990P 00F4 B6   0000    A CHRLOD LDA    >0       (Force extended addressing.)
00991P 00F7 7E   078B    P        JMP    ROMLOC
00992
00993            000E    A NLORAM EQU    *-LORAM
00994
00995P 00FA 7E   0000    A HIRAM  JMP    XRSLWC   VIRQ
00996P 00FD 7E   00CE    P        JMP    CARTRG   VFIRQ
00997P 0100      00      A        FCB    &0       TICKER (Overlays 8K version's USRJMP.)
00998P 0101      00      A        FCB    &0       (Was JMP FCERR for 8k version.)
00999P 0102      00      A        FCB    &0
01000P 0103      80      A        FCB    @200     RNDX
01001P 0104      4F      A        FCB    @117
01002P 0105      C7      A        FCB    @307
01003P 0106      52      A        FCB    @122
01004            0001    A        IFNE   ADDPRC
01005P 0107      59      A        FCB    @131
01006                             ENDC   IFN      ADDPRC
01007P 0108      00      A        FCB    &0       ALPHLK in Color Computer.
01008P 0109      0000    A        FDB    &0       DBNCNT in Color Computer.
01009P 010B      00      A        FCB    &0       The RAM hook FPWRT used to be here
01010P 010C      00      A        FCB    &0       and was set uo with a JMP SNERR
01011P 010D      05      A        FCB    &5       INTER-REPEAT DELAY
01012P 010E      00      A        FCB    NNRMTK   STUB0
01013P 010F      0000    A        FDB    RESLST
01014P 0111      0000    A        FDB    STMDSP
01015P 0113      00      A        FCB    NFUNTK
01016P 0114      0000    A        FDB    FUNLST
01017P 0116      0000    A        FDB    FUNDSP
01018
01019            001E    A NHIRAM EQU    *-HIRAM
01020
01021            0001    A        IFNE   METTOY
01022P 0118      28      A SIGNON FCC    /(C) 1982 DRAGON DATA LTD /
01023P 0131      0D      A        FCB    CR
01024P 0132      31      A        FCC    /16K BASIC INTERPRETER 1.0      /
01025P 0151      0D      A        FCB    CR
01026P 0152      28      A MICRO  FCC    /(C) 1982 BY MICROSOFT/
01027P 0167      0D      A        FCB    CR
01028P 0168      0D      A        FCB    CR
01029P 0169      00      A        FCB    &0
01030                             ENDC   IFN      METTOY
01031
01032            0000    A        IFNE     GRPTEK
01044                       ENDC   IFN GRPTEK
01045
01046                             TTL    CHRINP - Character Input Routine
01047
01048                      *
01049                      * CHRINP inputs a character from the device specified by DEVNUM.
01050                      * The character is returned in A.

PAGE  007  ECBMOD  .SA:1  ECBMOD CHRINP - Character Input Routine

01051                      * All registers except A and CC are preserved.
01052                      * If end of file is hit, EOFFLG=.TRUE.=non-zero, and A is meaningless.
01053                      *
01054                      * INCHR is called instead of CHRINP when a 7 bit code  is wanted.
01055                      *
01056
01057                             XDEF   INCHR
01058P 016A 8D   03   016F INCHR  BSR    CHRINP   Read a character.
01059P 016C 84   7F      A        ANDA   #@177    Clear the high order bit.
01060P 016E 39                    RTS             Return with it
01061
01062
01063                             XDEF   CHRINP
01064P 016F BD   0000    A CHRINP JSR    HKCHRI   RAM hook.
01065P 0172 0F   70      A        CLR    EOFFLG   End of file flag:=.FALSE.
01066P 0174 0D   6F      A        TST    DEVNUM   Check the device number.
01067P 0176 27   25   019D        BEQ    KEYINP   Go handle the keyboard.
01068                      *    No, fall into CASINP to get char from
01069                      *    cassette.

PAGE  008  ECBMOD  .SA:1  ECBMOD CHRINP - Character Input Routine

01071                      *
01072                      * CASINP reads a character from a cassette file.
01073                      * (Also used for downloading in the extended version.)
01074                      *
01075
01076P 0178 0D   79      A CASINP TST    CBFCNT   Is the buffer empty?
01077P 017A 26   03   017F        BNE    NOTMT    No, go get a char from it.
01078P 017C 03   70      A        COM    EOFFLG   Yes, end of file.
01079P 017E 39                    RTS
01080
01081P 017F 34   74      A NOTMT  PSHS   U,Y,X,B  Save registers.  (Save all because
0082                       *    of possible LODBUF call.)
01083P 0181 9E   7A      A        LDX    CBFPTR   Get char from cassette buffer, update
01084P 0183 A6   80      A        LDA    ,X+      the pointer, and decrement the count.
01085P 0185 34   02      A        PSHS   A        (Save the char too.)
01086P 0187 9F   7A      A        STX    CBFPTR
01087P 0189 0A   79      A        DEC    CBFCNT
01088P 018B 26   09   0196        BNE    CASIRT   Buffer still not empty, just return.
01089P 018D 96   6F      A        LDA    DEVNUM   Doing a download?
01090P 018F 81   FD      A        CMPA   #-&3
01091P 0191 27   05   0198        BEQ    LODDNL   Yes, use different load buffer
01092                      *    routine.
01093P 0193 BD   04CC    P        JSR    LODBUF   Reload the buffer.
010S4P 0196 35   F6      A CASIRT PULS   D,X,Y,U,PC Get the char into A, restore all regs
01095                      *    and return.
01096
01097P 0198 BD   0000    A LODDNL JSR    LDBUFR   Reload download buffer.
01098P 019B 20   F9   0196        BRA    CASIRT   Restore and return.

PAGE  009  ECBMOD  .SA:1  ECBMOD CHRINP - Character Input Routine

01100                      *
01101                      * KEYINP reads a char from the keyboard.
01102                      *
01103
01104            0001    A        IFNE   REALIO
01105P 019D 34   14      A KEYINP PSHS   X,B      Save the registers.
01106P 019F BD   0000    A KEYILP JSR    CBLINK   Blink the cursor.
01107P 01A2 BD   0000    A        JSR    POLCAT   Scan the keyboard.
01108P 01A5 27   F8   019F        BEQ    KEYILP   No key, look again.
01109P 01A7 C6   60      A        LDB    #@140    Have key, clear the cursor.
01110P 01A9 E7   9F 0088 A        STB    [CURADR]
01111P 01AD 35   94      A KEYFIN PULS   B,X,PC   Restore B and X and return with the
01112                      *    the char in A.
01113                             ENDC   IFN      REALIO
01114
01115            0001    A        IFEQ   REALIO
01118                       ENDC   IFE REALIO

PAGE  010  ECBMOD  .SA:1  ECBMOD CHRINP - Character Input Routine

01120                             TTL    CHROUT - Output Character Routine
01121
01122                      *
01123                      * CHROUT sends the character in A to the device specified by DEVNUM.
01124                      * The output is suppressed if DEVNUM indicates that file input is
01125                      * in progress.  This is done so character echo, input prompts
01126                      * (such as double question mark for more input), etc is ignored
01127                      * while inputting file data or loading an ASCII program file.
01128                      *
01129                      * All registers except CC are preserved.
01130                      *
01131
01132                             XDEF   CHROUT
01133P 01AF BD   0000    A CHROUT JSR    HKCHRO   RAM hook.
01134P 01B2 34   04      A        PSHS   B        Save B.
01135P 01B4 D6   6F      A        LDB    DEVNUM   Get the device number.
01136P 01B6 C1   FD      A        CMPB   #-&3     Doing a download?
01137P 01B8 26   02   01BC        BNE    NOTDNL   No.
01138P 01BA 35   84      A        PULS   B,PC     Yes, throw away the echo.
01139
01140P 01BC 5C             NOTDNL INCB            See what it is.
01141P 01BD 35   04      A        PULS   B        Restore B.
01142P 01BF 102B FE3D    A        LBMI   LPTOUT   Send char to printer.
01143P 01C3 26   2F   01F4        BNE    SCROPT   Send char to screen.
01144
01145P 01C5 34   16      A        PSHS   X,D      It's the cassette, save some regs.
01146P 01C7 D6   78      A        LDB    CASOPN   Is the cassette
01147P 01C9 5A                    DECB            open for input?
01148P 01CA 27   0F   01DB        BEQ    OUTRTS   Yes, throw this output away.
01149
01150                      *
01151                      * Output character to cassette file.
01152                      *
01153
01154P 01CC D6   79      A CASOUT LDB    CBFCNT   Get the character count.
01155P 01CE 5C                    INCB            Is the buffer full?
01156P 01CF 26   02   01D3        BNE    NOTFUL   No, go put the char in the buffer.
01157P 01D1 8D   0A   01DD        BSR    DMPBUF   Yes, write out the buffer.
01158P 01D3 9E   7A      A NOTFUL LDX    CBFPTR   Get pointer into buffer.
01159P 01D5 A7   80      A        STA    ,X+      Put the char away and increment the
01160P 01D7 9F   7A      A        STX    CBFPTR   pointer.
01161P 01D9 0C   79      A        INC    CBFCNT   Increment the count.
01162P 01DB 35   96      A OUTRTS PULS   D,X,PC   Restore regs and return.
01163
01164                      *
01165                      * Here to dump the cassette buffer to tape.
01166                      *
01167
01168P 01DD C6   01      A DMPBUF LDB    #&1      Set block type to data.
01169P 01DF D7   7C      A WRTEOF STB    BLKTYP
01170P 01E1 8E   0000    A        LDX    #CASBUF  Set address of data for WRTBLK.
01171P 01E4 9F   7E      A        STX    CBUFAD
01172P 01E6 D6   79      A        LDB    CBFCNT   Set the block length.
01173P 01E8 D7   7D      A        STB    BLKLEN
01174P 01EA 34   62      A        PSHS   U,Y,A    Save the rest.
01175P 01EC BD   05F6    P        JSR    WRTBLK   Write block out.
01176P 01EF 35   62      A        PULS   A,Y,U    Restore regs.
01177P 01F1 7E   04E7    P        JMP    MRKMT    Mark the buffer as empty.

PAGE  011  ECBMOD  .SA:1  ECBMOD CHROUT - Output Character Routine

01179                      *
01180                      * Ouput character to screen.
01181                      *
01182
01183            01F4    P SCROPT EQU    *
01184            0001    A        IFNE   REALIO
01185P 01F4 BD   0000    A        JSR    SAMALP   Switch to text mode.
01186P 01F7 7E   0000    A        JMP    SCROUT   Go to the screen driver.
01187                             ENDC   IFN      REALIO
01188
01189            0001    A        IFEQ   REALIO
01221                       ENDC    IFE REALIO

PAGE  012  ECBMOD  .SA:1  ECBMOD CHROUT - Output Character Routine

01223                             TTL    DEVPRM - Return Device Parameters
01224
01225                      *
01226                      * DEVPRM returns the following device parameters:
01227                      *
01228                      * DEVPOS - The position of the print head or it's equivalent.
01229                      * DEVWID - The line width of the device.
01230                      * DEVLCF - The column number where the last comma field starts.
01231                      * DEVCFW - The comma field width.
01232                      * SPCIO  - .TRUE. for special I/O handling in PRINT and INPUT code.
01233                      *
01234                      * All registers except CC are preserved.
01235                      * On exit, Z=1 if the device has infinite width (DEVWID=0).
01236                      *
01237
01238                             XDEF   DEVPRM
01239P 01FA BD   0000    A DEVPRM JSR    HKDPRM   RAM hook.
01240P 01FD 34   16      A        PSHS   X,D      Save registers.
0124IP 01FF 0F   6E      A        CLR    SPCIO    Special I/O flag:=.FALSE.
01242P 0201 96   6F      A        LDA    DEVNUM   Get the device number.
01243P 0203 27   09   020E        BEQ    SCRPRM   Go get the screen parms.
01244P 0205 4C                    INCA
01245P 0206 27   17   021F        BEQ    CASPRM   Go get cassette parms.
01246
01247                      *
01248                      * Get line printer parameters.
01249                      *
01250
01231P 0208 9E   99      A LPTPRM LDX    LPTCFW   Get comma field width and last comma
01252                      *    field.
01253P 020A DC   9B      A        LDD    LPTWID   Get width and current position.
012542 020C 20   09   0217        BRA    DEVFIN   Go out it all away.
01255
01256                      *
01257                      * Get screen parms.
01258                      * The width, comma field width, and last comma field are fixed.
01259                      * The position is obtained by reading the cursor address.
01260                      *
01261
01262P 020E D6   89      A SCRPRM LDB    CURADR+&1 Get low order of cursor address.
012632 0210 C4   1F      A        ANDB   #&31     Determine the column number. This
01264                      *    only works because the line width
01265                      *    is a power of two.
012662 0212 8E   1010    A        LDX    #&16*&256+&16 Field width and last comma field.
012672 0215 86   20      A        LDA    #&32     Set up the width.
01268                             XDEF   DEVFIN
012652 0217 9F   6A      A DEVFIN STX    DEVCFW   Put away comma field width and last
01270                      *    comma field.
01271P 0219 D7   6C      A        STB    DEVPOS   Put away the position.
012722 021B 97   6D      A        STA    DEVWID   Put away the width and set the Z bit
01273                      *    for infinite width devices.
012742 021D 35   96      A        PULS   D,X,PC   Restore and return.
01275
01276
01277                      *
01278                      * Get the cassette parms.
01279                      * They are all fixed at values which are necessary for the special
01280                      * I/O code to work properly. SPCIO gets set TRUE.

PAGE  013  ECBMOD  .SA:1  ECBMOD DEVPRM - Return Device Parameters

01281                      *
01282
01283P 021F 03   6E      A CASPRM COM    SPCIO    Special I/O flag:=.TRUE.
01284P 0221 8E   0100    A        LDX    #&256    Comma field width:=1, last comma
01285                      *    field:=0 but don't really care.
01286P 0224 4F                    CLRA            Width:=infinite and position:=0.
01287P 0225 5F                    CLRB
01288P 0226 20   EF   0217        BRA    DEVFIN   Go put them away.

PAGE  014  ECBMOD  .SA:1  ECBMOD DEVPRM - Return Device Parameters

01290                             TTL    INLIN - The line input routine.
01291
01292P 0228 BD   06DC    P INLCLS JSR    GRNCHR   Clear the screen and start over.
01293                             XDEF   INLIN
01294P 022B BD   0000    A INLIN  JSR    HKINLN   RAM hook.
01295P 022E 0F   87      A        CLR    INKCHR   Throw away INKEY's character.
01296P 0230 8E   0000    A        LDX    #BUF     Point to the start of the line buffer.
01297P 0233 C6   01      A        LDB    #&1      Init the character count.
01298P 0235 BD   016A    A INLINC JSR    INCHR    Read a character.
01299P 0238 0D   70      A        TST    EOFFLG   End of file reached?
01300P 023A 26   2B   0267        BNE    INLDON   Yes, go finish up.
01301P 023C 0D   6F      A        TST    DEVNUM   Reading from the keyboard?
01302P 023E 26   23   0263        BNE    NOEDIT   No, don't check for editing chars.
01303P 0240 81   0C      A        CMPA   #@14     CLEAR key?
01304P 0242 27   E4   0228        BEQ    INLCLS   Yes, clear screen and start over.
01305P 0244 81   08      A        CMPA   #CHRDEL  Character delete?
01306P 0246 26   07   024F        BNE    NTCDEL   No.
01307P 0248 5A                    DECB            Yes, at beginning of line?
01308P 0249 27   E0   022B        BEQ    INLIN    Yes, just start over.
01309P 024B 30   1F      A        LEAX   -&1,X    Backup the buffer pointer.
01310P 024D 20   34   0283        BRA    ECHOIT   Output the CHRDEL to the screen to
01311                      *    backup the cursor and go back for
01312                      *    another char.
01313
01314P 024F 81   15      A NTCDEL CMPA   #LINDEL  Is it a line delete?
01315P 0251 26   0A   025D        BNE    NTLDEL   No
01316P 0253 5A             RUBLIN DECB            Yes, send CHRDELs to the screen
01317P 0254 27   D5   022B        BEQ    INLIN    until all characters have been erased.
01318P 0256 86   08      A        LDA    #CHRDEL  Then go start all over.
01319P 0258 BD   01AF    P        JSR    CHROUT
01320P 025B 20   F6   0253        BRA    RUBLIN
01321
01322P 025D 81   03      A NTLDEL CMPA   #BRKCHR  Break character? (Like control-C)
01323P 025F 1A   01               SEC             (Set the carry just in case.)
01324P 0261 27   05   0268        BEQ    FININL   Yes
01325
01326P 0263 81   0D      A NOEDIT CMPA   #CR      Carriage return?
01327P 0265 26   0D   0274        BNE    NOTCR    No
01328P 0267 4F             INLDON CLRA            (Clear carry.)  Clear control-C flag.
01329P 0268 34   01      A FININL PSHS   CC       Save the control-C flag.
01330P 026A BD   0000    A        JSR    CRDO     Start a new line.
01331P 026D 6F   84      A        CLR    ,X       Put a zero in to mark the end.
01332P 026F 8E   FFFF    A        LDX    #BUF-&1  Set up a pointer for CRUNCH.
01333P 0272 35   81      A        PULS   CC,PC    Get the control-C flag and return.
01334
01335                      *
01336                      * The character is not a special char.  Weed out bad ones and store
01337                      * the good ones in the buffer.
01338                      *
01339P 0274 81   20      A NOTCR  CMPA   #SPACE   Those below space and above lower
01340P 0276 25   BD   0235        BCS    INLINC   case z are thrown away.
01341P 0278 81   7B      A        CMPA   #'z+&1
01342P 027A 24   B9   0235        BCC    INLINC
01343P 027C C1   FA      A GOODCH CMPB   #BUFLEN  Would this char fill the buffer?
01344P 027E 24   B5   0235        BCC    INLINC   Yes, ignore it then because one
01345                      *    byte must be reserved for the zero
01346                      *    terminator inserted when a carriage
01347                      *    return is typed.

PAGE  015  ECBMOD  .SA:1  ECBMOD INLIN - The line input routine.

01348P 0280 A7   80      A        STA    ,X+      No, store the character, bump the
01349P 0282 5C                    INCB            pointer, and increment the count.
01350P 0283 BD   01AF    P ECHOIT JSR    CHROUT   Echo the char and go back for more.
01351P 0286 20   AD   0235        BRA    INLINC
01352
01353                             TTL    OPNICK and OPNOCK
01354
01355                      *
01356                      * Make sure device specified by DEVNUM is open for input.
01357                      *
01358
01359                             XDEF   OPNICK
01360P 0288 BD   0000    A OPNICK JSR    HKCKDI   RAM hook.
01361P 028B 96   6F      A        LDA    DEVNUM   Get the device number.
01362P 028D 27   21   02B0        BEQ    OKOPN    Keyboard is always open.
01363P 028F 4C                    INCA            Is is the printer?
01364P 0290 26   0C   029E        BNE    GOBMER   Yes, give Bad Mode error.
01365P 0292 96   78               LDA    CASOPN   Is the cassette open?
01366P 0294 26   05   029B        BNE    CHKMOD   Yes, go check the open mode.
01367                             XDEF   NOERR
01368P 0296 C6   00      A NOERR  LDB    #ERRNO   No, give Not Open error.
01369P 0298 7E   0000    A        JMP    ERROR
01370
01371P 029B 4A             CHKMOD DECA            Is it open for input?
01372P 029C 27   12   02B0        BEQ    OKOPN    Yes, OK.
01373P 029E 7E   04AD    P GOBMER JMP    BMERR    No, give Bad Mode error.
01374
01375
01376                      *
01377                      * Make sure device is open for output.
01378                      *
01379
01380                             XDEF   OPNOCK
01381P 02A1 BD   0000    A OPNOCK JSR    HKCKDO   RAM hook.
01382P 02A4 96   6F      A        LDA    DEVNUM   Get the device number.
01583P 02A6 4C                    INCA
01384P 02A7 26   07   02B0        BNE    OKOPN    Screen and printer are always open.
01385P 02A9 96   78      A        LDA    CASOPN   Is the casette open?
01386P 02AB 27   E9   0296        BEQ    NOERR    No, give Not Open error.
01587P 02AD 4A                    DECA            Yes, is it open for output?
01388P 02AE 27   EE   029E        BEQ    GOBMER   No, give mode error.
01389P 02B0 39             OKOPN  RTS             Yes, all is OK.
01390

PAGE  016  ECBMOD  .SA:1  ECBMOD OPNICK and OPNOCK

01392                             TTL    The CLOSE code.
01393
01394                             XDEF   CLOSE
01395  02B1 27   0E   02C1 CLOSE  BEQ    CLSALL   Nothing specified, close everything.
01396P 02B3 BD   043C    P        JSR    GETDNM   Read a device number.
01397P 02B6 BD   10   02C8 NXTCLO BSR    CLOSIT   Close this device.
01398P 02B8 9D   A5      A        JSR    CHRGOT   Another number specified?
01399P 02BA 27   2A   02E6        BEQ    CLSRTS   No, all done.
01400P 02BC BD   0439    P        JSR    GETCDN   Yes, read comma and device number.
01401P 02BF 20   F5   02B6        BRA    NXTCLO   So close it.
01402
01403                             XDEF   CLSALL
01404P 02C1 BD   0000    A CLSALL JSR    HKCLSA   RAM hook.
01405                             XDEF   CLSCAS
01406P 02C4 86   FF      A CLSCAS LDA    #-&1     Only thing requiring attention is
01407P 02C6 97   6F      A        STA    DEVNUM   the cassette.
01406
01409                             XDEF   CLOSIT
01410P 02C8 BD   0000    A CLOSIT JSR    HKCLS1   RAM hook.
01411P 02CB 96   6F      A        LDA    DEVNUM   A:=device number.
01412P 02CD 0F   6F      A        CLR    DEVNUM   Clear it so normal output occurs when
01413                      *    close is finished.
01414P 02CF 4C                    INCA            Do nothing if it isn't the cassette.
01415P 02D0 26   14   02E6        BNE    CLSRTS
01416P 02D2 96   78      A        LDA    CASOPN   Is the casette open for output?
01417P 02D4 81   02      A        CMPA   #&2
014l8P 02D6 26   0C   02E4        BNE    MRKCLS   No, just mark it as closed.
01419P 02D8 96   79      A        LDA    CBFCNT   Yes, is there stuff in the buffer?
01420P 02DA 27   03   02DF        BEQ    EOFWRT   No.
01421P 02DC BD   01DD    P        JSR    DMPBUF   Yes, dump the buffer.
01422                             XDEF   EOFWRT
01423P 02DF C6   FF      A EOFWRT LDB    #@377    Set block type to end of flle.
01424P 02E1 BD   01DF    P        JSR    WRTEOF   Write an EOF block.
01425P 02E4 0F   78      A MRKCLS CLR    CASOPN   Mark the cassette as closed.
01426P 02E6 39             CLSRTS RTS
01427

PAGE  017  ECBMOD  .SA:1  ECBMOD The CLOSE code.

01429                             TTL    CSAVE - Save program on cassette.
01430
01431                             XDEF   CSAVE
01432P 02E7 81   4D      A CSAVE  CMPA   #'M      Is it CSAVEM?
01433P 02E9 1027 FD13    A        LBEQ   CSAVEM   Yes, go handle it.
01434P 02ED BD   040F    P        JSR    GETFLN   Read the filename.
01435P 02F0 9D   A5      A        JSR    CHRGOT   End of statement?
01436P 02F2 27   16   030A        BEQ    BCSAVE   Yes, do binary CSAVE.
0l437P 02F4 BD   0000    A        JSR    CHKCOM   No, must be followed bya comma and
01438P 02F7                       SYNCHK 'A       an "A" for ASCII.
01439P 02FC 26   E8   02E6        BNE    CLSRTS   If statement doesn't end now let
01440                      *    NEWSTT give a syntax error.
01441P 02FE 4F                    CLRA            Say it's a BASIC program.
01442P 02FF BD   04F3    P        JSR    OPNASC   Open ASCII, gapped output file.
01443P 0302 86   FF      A        LDA    #CASNUM  Make the listing go to cassette.
01444P 0304 97   6F      A        STA    DEVNUM
01445P 0306 4F                    CLRA            Make the LIST code see a terminator
01446                      *    so the whole program gets saved.
01447P 0307 7E   0000    A        JMP    LIST     The LIST code will do the rest,
01448                      *    When LIST is done it will close the
0i449                      *    file.
01450
01451                      *
01452                      * Here to do binary CSAVE.
01453                      *
01454
01455P 030A 4F             BCSAVE CLRA            Say it's a BASIC program.
01456P 030B 9E   8A      A        LDX    DBLZER   Say not ASCII or gapped.
01457P 030D BD   04F6    P        JSR    OPNCSO   Open cassette file for output.
01458P 0310 0F   78      A        CLR    CASOPN   Mark cassette as closed since OPNCSO
01459                      *    marked it as open.
01460P 0312 0C   7C      A        INC    BLKTYP   Set block type to data.
01461P 0314 BD   0000    A        JSR    WRTLDR   Turn on the cassette and write a
01462                      *    leader.
01463P 0317 9E   19      A        LDX    TXTTAB   Get the starting point.
01464
01465P 0319 9F   7E      A BCSLOP STX    CBUFAD   Store buffer address for BLKOUT.
01466P 031B 86   FF      A        LDA    #&255    Assume it's a full block.
01467P 031D 97   7D      A        STA    BLKLEN
01468P 031F DC   1B      A        LDD    VARTAB   How many more to write?
01469P 0321 93   7E      A        SUBD   CBUFAD
01470P 0323 27   0D   0332        BEQ    FINSAV   All done.
01471P 0325 1083 00FF    A        CMPD   #&255    Is it a full block?
01472P 0329 24   02   032D        BHS    FULBLK   Yes.
01473P 032B D7   7D      A        STB    BLKLEN   No, set actual block length.
01474P 032D BD   05FE    P FULBLK JSR    BLKOUT   Output the block.
01475P 0330 20   E7   0319        BRA    BCSLOP   Go back for more.  BLKOUT set X
01476                      *    to [CBUFAD]+[BLKLEN].
01477
01478                             XDEF   FINSAV
01479P 0332 00   7C      A FINSAV NEG    BLKTYP   Set block type to EOF.  (It was 1
01480                      *    for data, now -1 for eof.
01481P 0334 0F   7D      A        CLR    BLKLEN   No data to go out.
01482P 0336 7E   05F9    P        JMP    BLKOFF   Write EOF block, turn off motor, and
01483                      *    return to NEWSTT.
01484

PAGE  018  ECBMOD  .SA:1  ECBMOD CSAVE - Save program on cassette.

01486                             TTL    CLOAD - Load a program from cassette.
01487
01488                             XDEF   CLOAD
01489P 0339 0F   78      A CLOAD  CLR    CASOPN   Force the cassette closed.  The
01490                      * last block of an output file may
01491                      * be lost but we don't have enough
01492                      * bytes to flush the buffer and tne
01493                      * user has probably put the cassette
01494                      * in play mode anyway.
01495P 033B 81   4D      A        CMPA   #'M      Do they want to load a machine
01496                      *    language file?
01497P 033D 1027 FCBF    A        LBEQ   CLOADM   Yes, go do it.
01498P 0341 32   62      A        LEAS   &2,S     No, get rid of NEWSTT return address.
01499P 0343 BD   045C    P        JSR    FLNTRM   Read the filename.
01500P 0346 BD   04DF    P        JSR    OPNCSI   Open the cassette for input.
01501P 0349 7D   0000    A        TST    GAPFLG   Is it a gapped file?
01502P 034C 27   1D   036B        BEQ    BCLOD    No, go do binary CLOAD.
01503
01504                      *
01505                      * Here to load ASCII file.
01506                      *
01507
01508P 034E B6   0000    A        LDA    ASCFLG   Make sure it is ASCII.
01509P 0351 27   1D   0370        BEQ    BMERR1   If not give mode error.
01510P 0353 BD   0000    A        JSR    SCRTCH   Get rid of the existing program.
01511P 0356 86   FF      A        LDA    #CASNUM  Make program come from cassette.
01512P 0358 97   6F      A        STA    DEVNUM
01513P 035A 0C   78      A        INC    CASOPN   Mark the cassette as open for input.
01514P 035C BD   04CC    P        JSR    LODBUF   Load the buffer and let main do the
01515P 035F 7E   0000    A        JMP    MAIN     actual loading.
01516
01517                      *
01518                      *  Here when MAIN sees the end of file.
01519                      *
01520
01521                             XDEF   FINLOD
01522P 0362 BD   0000    A FINLOD JSR    HKFNLD   RAM hook.
01523P 0365 BD   02C8    P        JSR    CLOSIT   Close the cassette file.
01524P 0368 7E   0000    A        JMP    READY    Go print "OK".
01525
01526                      *
01527                      * Here to load a binary cassette file.
01528                      *
01529
01530P 036B B6   0000    A BCLOD  LDA    FILTYP   It must be a BASIC program.
01531P 036E 27   03   0373        BEQ    DOBCLD   It is.
01532P 0370 7E   04AD    P BMERR1 JMP    BMERR    It isn't, give a mode error.
01533
01534P 0373 BD   0000    A DOBCLD JSR    SCRTCH   Wipe out the existing program.
01535P 0376 BD   0000    A        JSR    CSRDUN   Start cassette and get into bit sync.
01536P 0379 9E   19      A        LDX    TXTTAB   Set up first load address.
01537
01536P 037B 9F   7E      A CLDLOP STX    CBUFAD   Set load address for BLKINV.
01539P 037D DC   7E      A        LDD    CBUFAD   There must be another 256 bytes
01540P 037F 4C                    INCA            available or we give an OM error.
01541P 0380 BD   0000    A        JSR    REASON   (Yes, it is possble that they won't
01542                      *    be able to load a program they saved
01543                      *    if it was a very tight fit, but they

PAGE  019  ECBMOD  .SA:1  ECBMOD CLOAD - Load a program from cassette.

01544                      *    wouldn't be able to run it anyway.)
01545P 0383 BD   05A3    P        JSR    BLKIN    Load the next block.
01546P 0386 26   13   039B        BNE    WIPER    An error occured.
01547P 0388 96   7C      A        LDA    BLKTYP   No error, get the block type.
01548P 038A 27   0F   039B        BEQ    WIPER    Can't have file header in middle of
01549                      *    file.
01550P 038C 2A   ED   037B        BPL    CLDLOP   Data record so continue.  Note that
01551                      *    X has load address for next block.
01552P 038E 9F   1B      A        STX    VARTAB   End of file, set end of program.
01553P 0390 8D   40   03D2        BSR    GOCOFF   Turn off the motor.
01554P 0392 8E   FFFE    A        LDX    #REDDY-&2 Print "OK" since we won't be going
01555P 0395 BD   0000    A        JSR    STROUT   through READY.  (NOTE: REDDY-2 is
01556                      *    used to force a carriage return.)
01557P 0398 7E   0000    A        JMP    FINI     Go fix up the links,etc. End up
01558                      *    at MAIN.
01559
01560P 039B BD   0000    A WIPER  JSR    SCRTCH   Error occured, wipe out whatever did
01561                      *    load so garbage isn't left around.
01562P 039E 7E   04B0    P GOIOER JMP    IOERR
01563

PAGE  020  ECBMOD  .SA:1  ECBMOD CLOAD — Load a program from cassette.

01565                      *
01566                      * Here to load an ungapped machine langauge file.
01567                      *
01568
01569                             XDEF   MLDUNG
01570P 03A1 9E   8A      A MLDUNG LDX    DBLZER   Assume no load offset specified.
01571P 03A3 9D   A5      A        JSR    CHRGOT   End of statement?
01572P 03A5 27   06   03AD        BEQ    ZEROFF   Yes, use tne default offset of zero.
01573P 03A7 BD   0000    A        JSR    CHKCOM   No, eat the comma and evaluate
01574P 03AA BD   0000    A        JSR    EVLADR   the specified offset.
01575P 03AD B6   0000    A ZEROFF LDA    FILTYP   Is the file a machine language file?
01576P 03B0 81   02      A        CMPA   #&2
01577P 03B2 26   BC   0370        BNE    BMERR1   No, give file mode error.
01578P 03B4 FC   0000    A        LDD    STRTAD   Yes, add tne load offset to the
01579P 03B7 33   8B      A        LEAU   D,X      execution address and save it for
01580P 03B9 DF   9D      A        STU    EXECAD   the EXEC statement.
01581P 03BB FC   0000    A        LDD    LOADAD   Add the load offset to the load
01582P 03BE 30   8B      A        LEAX   D,X      address of the file.
01583P 03C0 9F   7E      A        STX    CBUFAD   Save the effective load address.
01584P 03C2 BD   0000    A        JSR    CSRDON   Turn on tne cassette and sync up.
01565P 03C5 BD   05A3    P MLDCLP JSR    BLKIN    Read tne next block of the file.
01586P 03C8 26   D4   039E        BNE    GOIOER   Bad read.
01587P 03CA 9F   7E      A        STX    CBUFAD   Update the load address.
01588P 03CC 0D   7C      A        TST    BLKTYP   What type of block was read?
01589P 03CE 27   CE   039E        BEQ    GOIOER   Can't have header in middle of file.
01590P 03D0 2A   F3   03C5        BPL    MLDCLP   A data record, go read more.
01591P 03D2 7E   0000    A GOCOFF JMP    CASOFF   End of file, turn off cassette and
01592                      *    return  to NEWSTT.

PAGE  021  ECBMOD  .SA:1  ECBMOD CLOAD - Load a program from cassette.

01594                             TTL    The EXEC statement.
01595
01596                      *
01597                      * The EXEC statement causes processor control to be transferred to
01596                      * the specified address.  If no address is specified the address
01599                      * contained in EXECAD is used.
01600                      *
01601
01602                             XDEF   EXEC
01603P 03D5 27   05   03DC EXEC   BEQ    EXECDO   Use EXECAD if nothing specified.
01604P 03D7 BD   0000    A        JSR    EVLADR   Evaluate the execution address.
01605P 03DA 9F   9D      A        STX    EXECAD   Put it away.
01606P 03DC 6E   9F 009D A EXECDO JMP    [EXECADJ Go to it.
01607

PAGE  022  ECBMOD  .SA:1  ECBMOD The EXEC statement.

01609                             TTL    Miscellaneous
01610
01611                      *
01612                      * Check for BREAK and others.
01513                      * Don't do it if cassette I/O is in progress.
01614                      *
01515
01616                             XDEF   BRKCHK
01617P 03E0 BD   0000    A BRKCHK JSR    HKBRKC   RAM hook.
01618P 03E3 96   6F      A        LDA    DEVNUM
01619P 03E5 4C                    INCA
01620P 03E6 27   50   0438        BEQ    COPRTS   Cassette, don't check for BREAK.
01621P 03E8 7E   0000    A        JMP    ISCNTC   Not cassette, go poll keyboard.
01622
01623
01524                      *
01625                      * Here when the PRINT code sees an @ sign directly after the
01626                      * PRINT token.
01627                      *
01626
01629                             XDEF   PATDO
01630P 03EB BD   0000    A PATDO  JSR    INTIDX   D:=screen address.
01631P 03EE 83   01FF    A        SUBD   #&511    Make sure it's in range.
01532P 03F1 1022 FC0B    A        LBHI   FCERR    It isn't.
01633P 03F5 C3   05FF    A        ADDD   #SCRADR+&511 It is, set the new cursor position.
01634P 03F8 DD   88      A        STD    CURADR
01535P 03FA 39             PATRTS RTS
01636
01637
01638                      *
01639                      * INKEY$ returns a single byte string containing the key code of
01640                      * an active key or the null string if no key is active.
01641                      *
01542
01643                             XDEF   INKEY$
01544P 03FB 96   87      A INKEY$ LDA    INKCHR   Is there a char in the single char
01645                      *    buffer?
01646P 03FD 26   03   0402        BNE    NOPOLL   Yes, use it rather than poll for one.
01647P 03FF BD   0000    A        JSR    POLCAT   No, scan the keyboard.
01648P 0402 0F   87      A NOPOLL CLR    INKCHR   Mark Pufber as empty.
01649P 0404 97   53      A        STA    FACLO    Save the key code.
01650P 0406 1026 FBF6    A        LBNE   CHR$DO   Go put it away.
01651P 040A 97   56      A        STA    DSCTMP   No key seen, return the null string.
01652P 040C 7E   0000    A        JMP    GOPTNW
01653
01654                             TTL    Get Filename.
01555
01656                             XDEF   GETFLN
01657P 040F 8E   0000    A GETFLN LDX    #FNAMLN  Set the filename length to zero and
01658P 0412 6F   80      A        CLR    ,X+      blank fill the filename buffer.
01659P 0414 86   20      A        LDA    #SPACE
01650P 0416 A7   80      A BLNKFL STA    ,X+
01661P 0418 8C   0008    A        CMPX   #FILNAM+&8
01562P 041B 26   F9   0416        BNE    BLNKFL
01663
01654P 041D 9D   A5      A        JSR    CHRGOT   Does the statement end here?
01665P 041F 27   17   0438        BEQ    COPRTS   Yes, no filename specified so use
01666                      *    none.

