PAGE  001  ECBCOM  .SA:0  ECBMOD Extension ROM Direct Page RAM

00700                             OPT    L,LLE=120
00701                             NAM    ECBMOD
00702
00703                      **********************************************************************
00704                      *                                                                    *
00705                      *    Copyright 1982 by Microsoft Corporation, all rights reserved    *
00706                      *                                                                    *
00707                      **********************************************************************
00708
00709                             TTL    External Declarations
00710
00711                             XREF   ALPHLK,ASC2,ASCFLG
00712                             XREF   BOOT64,BITIN,BUF
00713                             XREF   CASBUF,CASOFF,CASON,CBIN,CBLINK,CBOUT,CHKCLS,CHKCOM,CHKOPN
00714                             XREF   CHR$DO,CLOADM,COMBYT,CONINT,CRDO,CSAVEM,CSFNAM,CSRDON
00715                             XREF   DBNCNT
00716                             XREF   ENDHKS,ERRAO,ERRBM,ERRDN,ERRIO,ERRNO,ERROR,EVLADR
00717                             XREF   FCERR,FILNAM,FILTYP,FINI,FNAMLN,FRESTR,FRMEVL,FRMNUM
00718                             XREF   FUNDSP,FUNLST
00719                             XREF   GAPFLG,GETBYT,GIVABF,GOPTNW
00720                             XREF   HDRLEN,HKBRKC,HRCHRI,HRCHRO,HKCKDI,HRCKDO,HKCLS,HKCLS1
00721                             XREF   HKCLSA,HKDNCK,HKDPRM,HKEOF,HKFNLD,HKINLN,HKOPEN,HOOKS
00722                             XREF   HRDINI
00723                             XREF   INTCNV,INTIDX,ISCNTC,INTWDG
00724                             XREF   JOYIN
00725                             XREF   LDBUFR,LIST,LOADAD,LPTOUT
00726                             XREF   MAIN
00727                             XREF   NFUNTK,NNRMTK,NRTSH3,NRTSHK,NZLINK
00728                             XREF   OFFTK,ONTK
00729                             XREF   PINIT,POLCAT,POTVAL
00730                             XREF   READY,REASON,REDDY,RESLST,ROLTBL
00731                             XREF   SAMALP,SCROUT,SCRTCH,SFTINI,SNERR,SNGFLT
00732                             XREF   STKINI,STMDSP,STROUT,STRTAD,STUBO,SYNCHR
00733                             XREF   TEMPST
00734                             XREF   USRTAB
00735                             XREF   VIRQ
00736                             XREF   WRTLDR
00737                             XREF   XRRUN,XRSLWC
00738
00739            0001    A        IFEQ   REALIO
00744                       ENDC   IFE REALIO
00745
00746                             TTL    Equates
00747
00748                             XDEF   SCRADR
00749            0400    A SCRADR EQU    @2000    Address of screen memory (400 hex).
00750
00751            0001    A        IFNE   METTOY
00752                             XDEF   PIA0AD
00753            FF00    A PIA0AD EQU    @177400  PIA0, side A, data reg.  (FF00)
00754                             ENDC   IFN      METTOY
00755            0000    A        IFNE   GRPTEK
00758                       ENDC   IFN GRPTEK
00759                             XDEF   PIA0AC
00760            FF01    A PIA0AC EQU    PIA0AD+&1 PIA0, side A, control reg.
00761                             XDEF   PIA0BD
00762            FF02    A PIA0BD EQU    PIA0AC+&1 PIA0, side B, data reg.
00763                             XDEF   PIA0BC

PAGE  002  ECBMOD  .SA:1 ECBMOD Equates

00764            FF03    A PIA0BC EQU    PIA0BD+&1 PIA0, side B, control reg.
00765
00766            0001    A        IFNE   METTOY
00767                             XDEF   PIA1AD
00768            FF20    A PIA1AD EQU    @177440  PIA1, side A, data reg.  (FF20)
00769                             ENDC   IFN      METTOY
00770            0000    A        IFNE   GRPTEK
00773                       ENDC   IFN GRPTEK
00774                             XDEF   PIA1AC
00775            FF21    A PIA1AC EQU    PIA1AD+&1 PIA1, side A, control reg.
00776                             XDEF   PIA1BD
00777            FF22    A PIA1BD EQU    PIA1AC+&1 PIA1, side B, data reg.
00778                             XDEF   PIA1BC
00779            FF23    A PIA1BC EQU    PIA1BD+&1 PIA1, side B, conrtrol reg.
00780
00781            C000    A CARTRM EQU    @140000  Address of cartridge ROM.  (C000)
00782            8000    A EXTROM EQU    @100000  Address of extension ROM.  (8000)
00783
00784                             XDEF   SAM
00785            FFC0    A SAM    EQU    @177700  Address of SAM chip.  (FFC0)
00786
00787            C000    A DSKROM EQU    @140000  The address of the disk ROM.  (C000)
00788
00789                             TTL    Power up and Reset code.
00790
00791                      *
00792                      * Here on RESET and power up after executing HRDINI routine.
00793                      *
00794
00795P 0000 10CE 00FA    A HRDRT1 LDS    #BUF+BUFLEN Set up a temporary stack.
00796            0001    A        IFNE   REALIO
00797P 0004 86   37      A        LDA    #@67     Enable the cartridge interrupt
00798P 0006 B7   FF23    A        STA    PIA1BC   at the PIA.
00799                             ENDC   IFN      REALIO
00800P 0009 96   71      A        LDA    RSTFLG   Is the restart flag set?
00801P 000B 81   55      A        CMPA   #@125
00802P 000D 26   10   001F        BNE    INIT     No, must go through initialization.
00803P 000F 9E   72      A        LDX    RSTVEC   Yes, does the restart vector point
00804P 0011 A6   84      A        LDA    ,X       to a NOP instruction?
00805P 0013 81   12      A        CMPA   #@22
00806P 0015 26   08   001F        BNE    INIT     No, must go through initialization.
00807                      *    This check is made so that if the
00808                      *    user pulls out a cartridge and hits
00809                      *    reset we won't jump to the restart
00810                      *    address where there is no longer
00811                      *    any code.
00812P 0017 6E   84      A        JMP    ,X       Restart the current program.
00813
00814                      *
00815                      * Here on reset and power up.
00816                      *
00817
00818                             XDEF   POWRUP
00819P 0019 31   8C E4     POWRUP LEAY   HRDRT1,PCR Set up return address for HRDINI.
00820P 001C 7E   0000    A        JMP    HRDINI   (Can't use stack since RAM is no
00821                      â€¢    good until the SAM is initialized.)
00822                      *
00823                      * Here to perform BASIC initialization.

PAGE  003  ECBMOD  .SA:1  ECBMOD Power up and Reset code.

00824                      *
00825
00826                             XDEF   INIT
00827            001F    P INIT   EQU    *
00828            0001    A        IFNE   REALIO
00829P 001F  8E  0401    A        LDX    #SCRADR+&1 Clear RAM from 0 to the start of the
00630P 0022  6F  83      A CLRRAM CLR    ,--X     screen memory.
00831P 0024  30  01      A        LEAX   &1,X     (This roundabout method saves bytes
00832P 0026  26  FA   0022        BNE    CLRRAM   over the more obvious way.)
00833P 0028  BD  06DC    P        JSR    GRNCHR   Clear the screen and make X point to
00834                      *    the first byte following the screen
00835                      *    memory.
00836                             ENDC   IFN      REALIO
00837             0001   A        IFEQ   REALIO
00839                       ENDC   IFE REALIO
00840P 002B  6F   80     A        CLR    ,X+      Put a zero below TXTTAB and set it
00841P 002D  9F   19     A        STX    TXTTAB   up.
00842
00843                      *
00844                      * Here to find the top of RAM.
00845                      *
00846
00847            0001    A        IFNE   REALIO
00848P 002F A6   02      A MEMLOP LDA    &2,X     Get byte from memory.
00849P 0031 43                    COMA            Invert all  the bits.
00850P 0032 A7   02      A        STA    &2,X     Store the complement.
00851P 0034 A1   02      A        CMPA   &2,X     Did it store OK?
00852P 0036 26   06   003E        BNE    HAVEND   No, this byte is not useable RAM.
00853P 0038 30   01      A        LEAX   &1,X     Yes, bump the address.
00854P 003A 63   01      A        COM    &1,X     Restore the original contents.
00655P 003C 20   F1   002F        BRA    MEMLOP   Look at the next byte.
00856                             ENDC   IFN      REALIO
00857
00658            0001    A        IFEQ   REALIO
00861                       ENDC   IFE REALIO
00862P 003E 9F   74      A HAVEND STX    ENDMEM   Set pointer to end of memory.  Don't
00863                      *    use last good byte so VAL trick will
00864                      *    work OK in the degenerate case.
00865P 0040 9F   27      A        STX    MEMSIZ   Mark end of BASIC's memory.
00666P 0042 9F   23      A        STX    FRETOP   This is the end of string space also.
00867P 0044 30   89 FF38 A        LEAX   -STRSPC,X Set the bottom of string space.
00868P 0048 9F   21      A        STX    STKTOP   This is the top of the stack.
00869P 004A 1F   14      A        TFR    X,S      Switch from temp stack to BASIC's
00870                      *    real stack.
00871P 004C BD   0000    A        JSR    SFTINI   Init the I/O driver routines.
00872            0001    A        IFNE   REALIO
00873P 004F 8E   00EC    P        LDX    #LORAM   Initialize direct page RAM.
00874P 0052 CE   009D    A        LDU    #EXECAD
00875P 0055 C6   0E      A        LDB    #NLORAM
00676P 0057 BD   0431    P        JSR    COPLOP
00877P 005A CE   0000    A        LDU    #VIRQ    Initialize RAM off the direct page.
00878P 005D C6   1E      A        LDB    #NHIRAM
00879P 005F BD   0431    P        JSR    COPLOP
00880P 0062 8E   0000    A        LDX    #SNERR   X:=SNERR for intializing the dispatch
00881                      *    addresses of stub 1.
00882                             ENDC   IFN      REALIO
00863            0001    A        IFEQ   REALIO
00890                       ENDC   IFE REALIO

PAGE  004  ECBMOD  .SA:1  ECBMOD Power up and Reset code.

00891P 0065 AF   43      A        STX    &3, U    Init the stub 1 dispatch addresses.
00892P 0067 AF   48      A        STX    &8,U
00893            0001    A        IFNE   REALIO
00894P 0069 8E   0000    A        LDX    #HOOKS   Initialize the extension hooks by
00895                      *    putting in RTS instructions.
00896P 006C CC   3900    A        LDD    #$3900+NRTSH3 A:=RTS opcode,
00897                      *    B:=number of bytes
00898                      *    to initialize.
00899                      *    (Add $Z since NRTSHK is external.)
00900P 006F A7   80      A INIHKS STA    ,X+      (Note that putting RTS instructions
00901P 0071 5A                    DECB            into all three bytes of each hook is
00902P 0072 26   FB   006F        BNE    INIHKS   OK and saves bytes here.)
00903P 0074 B7   0000    A        STA    NZLINK   Make NZLINK nonzero for CHEAD.
00904                             ENDC   IFN      REALIO
00905P 0077 BD   0000    A        JSR    SCRTCH   Set up everthing else.
00906P 007A BD   0000    A        JSR    XRRUN    Set up the PLAY and DRAW defaults.
00907P 007D 8E   0000    A        LDX    #USRTAB  Put the address of USRTAB into
00908P 0080 9F   B0      A        STX    USTBAD   USTBAD so USRTAB can be referenced
00909                      *    indirectly through USTBAD.
00910P 0082 CE   0000    A        LDU    #FCERR   Init all USRTAB entries so they
00911P 0085 C6   0A      A        LDB    #&10     dispatch to FCERR unless explicitly
00912P 0087 EF   81      A FCUSLP STU    ,X++     defined by the user.
00913P 0089 5A                    DECB
00914P 008A 26   FB   0087        BNE    FCUSLP
00915            0001    A        IFNE   REALIO
00916P 008C BD   0000    A        JSR    PINIT    Init for graphics code.
00917P 008F B6   FF03    A        LDA    PIA0BC   Enable the 60 Hertz interrupt.
00918P 0092 8A   01      A        ORA    #&1
00919P 0094 B7   FF03    A        STA    PIA0BC
00920P 0097 8E   444B    A        LDX    #'D*&256+'K Is there a disk ROM in the machine?
00921P 009A BC   C000    A        CMPX   DSKROM
00922P 009D 1027 BF61    A        LBEQ   DSKROM+&2 Yes, go to its initialization code.
00923                             ENDC   IFN      REALIO

PAGE  005  ECBMOD  .SA:1  ECBMOD Power up and Reset code.

00925P 00A1 1C   AF      A        ANDCC  #$FF!X(F!+I) Allow the cartridge to interrupt now
00926                      *    before displaying the sign on message.
00927P 00A3 8E   0117    P        LDX    #SIGNON-&1 Print the sign on message.
00928P 00A6 BD   0000    A        JSR    STROUT
00929P 00A9 8E   00B4    P        LDX    #BASRST  Set the restart vector.
00930P 00AC 9F   72      A        STX    RSTVEC
00931                             XDEF   FINIT
00932P 00AE 86   55      A FINIT  LDA    #@125    Set the restart flag.
00933P 00B0 97   71      A        STA    RSTFLG
00934P 00B2 20   17   00CB        BRA    GORDY    Go to command level and say "OK".
00935
00936                      *
00937                      * Here to restart BASIC.
00938                      *
00939
00940                             XDEF   BASRST
00941P 00B4 12             BASRST NOP             The NOP required of all restart entry
00942                      *    points.
00943P 00B5 0F   E3      A        CLR    DURCNT   Clear the PLAY note duration count
00944P 00B7 0F   E4      A        CLR    DURCNT+&1 so interrupts don't think we are
00945                      *    still playing the note.
00946P 00B9 B6   FF03    A        LDA    PIA0BC   Enable the 60 hertz interrupt.
00947P 00BC 8A   01      A        ORA    #&1
00948P 00BE B7   FF03    A        STA    PIA0BC
00949P 00C1 0F   6F      A        CLR    DEVNUM   Make sure output goes to screen and
00950                      *    input comes from keyboard.
00951P 00C3 BD   0000    A        JSR    STKINI   Reset the stack and things.
00952P 00C6 1C   AF      A        ANDCC  #$FF!X(F!+I) Enable interrupts.
00953P 00C8 BD   06DC    P        JSR    GRNCHR   Clear the screen.
00954P 00CB 7E   0000    A GORDY  JMP    READY    Go say "OK".
00955
00956
00957                      *
00958                      * Here on a FIRQ to handle the cartridge interrupt.
00959                      *
00960
00961P 00CE 7D   FF23    A CARTRG TST    PIA1BC   Did the cartridge cause the interrupt?
00962P 00D1 2B   01   00D4        BMI    GOCART   Yes.
00963P 00D3 3B                    RTI             No, return from the interrupt.
00964
00965P 00D4 BD   00E5    P GOCART JSR    DELHAF   Delay for about a second to let the
00966P 00D7 BD   00E5    p        JSR    DELHAF   user finish installing the cartridge.
00967P 00DA 31   8C 03            LEAY   <HRDRT2,PCR Init the hardware.  HRDINI leaves the
00968P 00DD 7E   0000    A        JMP    HRDINI   cartridge interrupt disabled.
00969P 00E0 0F   71      A HRDRT2 CLR    RSTFLG   Don't allow BASIC to be restarted.
00970P 00E2 7E   C000    A        JMP    CARTRM   Go execute the cartrige program.
00971
00972                      *
00973                      * Delay for about one half second.
00974                      *
00975
00976                             XDEF   DELHAF
00977P 00E5 9E   8A      A DELHAF LDX    DBLZER
00978P 00E7 30   1F      A DELAY  LEAX   -&1,X
00979P 00E9 26   FC   00E7        BNE    DELAY
00980P 00EB 39                    RTS

PAGE  006  ECBMOD  .SA:1  ECBMOD Power up and Reset code.

00982                      *
0098                       * This stuff gets block transferred into RAM during initialization.
00984                      *
00985
00986P 00EC      0000    A LORAM  FDB    BOOT64   EXECAD FOR 64K INITIALISATION
00987P 00EE 0C   A7      A        INC    TXTPTR+&1 CHRGET RAM code.
00988P 00F0 26   02   00F4        BNE    CHRLOD
00989P 00F2 0C   A6      A        INC    TXTPTR
00990P 00F4 B6   0000    A CHRLOD LDA    >0       (Force extended addressing.)
00991P 00F7 7E   078B    P        JMP    ROMLOC
00992
00993            000E    A NLORAM EQU    *-LORAM
00994
00995P 00FA 7E   0000    A HIRAM  JMP    XRSLWC   VIRQ
00996P 00FD 7E   00CE    P        JMP    CARTRG   VFIRQ
00997P 0100      00      A        FCB    &0       TICKER (Overlays 8K version's USRJMP.)
00998P 0101      00      A        FCB    &0       (Was JMP FCERR for 8k version.)
00999P 0102      00      A        FCB    &0
01000P 0103      80      A        FCB    @200     RNDX
01001P 0104      4F      A        FCB    @117
01002P 0105      C7      A        FCB    @307
01003P 0106      52      A        FCB    @122
01004            0001    A        IFNE   ADDPRC
01005P 0107      59      A        FCB    @131
01006                             ENDC   IFN      ADDPRC
01007P 0108      00      A        FCB    &0       ALPHLK in Color Computer.
01008P 0109      0000    A        FDB    &0       DBNCNT in Color Computer.
01009P 010B      00      A        FCB    &0       The RAM hook FPWRT used to be here
01010P 010C      00      A        FCB    &0       and was set uo with a JMP SNERR
01011P 010D      05      A        FCB    &5       INTER-REPEAT DELAY
01012P 010E      00      A        FCB    NNRMTK   STUB0
01013P 010F      0000    A        FDB    RESLST
01014P 0111      0000    A        FDB    STMDSP
01015P 0113      00      A        FCB    NFUNTK
01016P 0114      0000    A        FDB    FUNLST
01017P 0116      0000    A        FDB    FUNDSP
01018
01019            001E    A NHIRAM EQU    *-HIRAM
01020
01021            0001    A        IFNE   METTOY
01022P 0118      28      A SIGNON FCC    /(C) 1982 DRAGON DATA LTD /
01023P 0131      0D      A        FCB    CR
01024P 0132      31      A        FCC    /16K BASIC INTERPRETER 1.0      /
01025P 0151      0D      A        FCB    CR
01026P 0152      28      A MICRO  FCC    /(C) 1982 BY MICROSOFT/
01027P 0167      0D      A        FCB    CR
01028P 0168      0D      A        FCB    CR
01029P 0169      00      A        FCB    &0
01030                             ENDC   IFN      METTOY
01031
01032            0000    A        IFNE     GRPTEK
01044                       ENDC   IFN GRPTEK
01045
01046                             TTL    CHRINP - Character Input Routine
01047
01048                      *
01049                      * CHRINP inputs a character from the device specified by DEVNUM.
01050                      * The character is returned in A.

PAGE  007  ECBMOD  .SA:1  ECBMOD CHRINP - Character Input Routine

01051                      * All registers except A and CC are preserved.
01052                      * If end of file is hit, EOFFLG=.TRUE.=non-zero, and A is meaningless.
01053                      *
01054                      * INCHR is called instead of CHRINP when a 7 bit code  is wanted.
01055                      *
01056
01057                             XDEF   INCHR
01058P 016A 8D   03   016F INCHR  BSR    CHRINP   Read a character.
01059P 016C 84   7F      A        ANDA   #@177    Clear the high order bit.
01060P 016E 39                    RTS             Return with it
01061
01062
01063                             XDEF   CHRINP
01064P 016F BD   0000    A CHRINP JSR    HKCHRI   RAM hook.
01065P 0172 0F   70      A        CLR    EOFFLG   End of file flag:=.FALSE.
01066P 0174 0D   6F      A        TST    DEVNUM   Check the device number.
01067P 0176 27   25   019D        BEQ    KEYINP   Go handle the keyboard.
01068                      *    No, fall into CASINP to get char from
01069                      *    cassette.

PAGE  008  ECBMOD  .SA:1  ECBMOD CHRINP - Character Input Routine

01071                      *
01072                      * CASINP reads a character from a cassette file.
01073                      * (Also used for downloading in the extended version.)
01074                      *
01075
01076P 0178 0D   79      A CASINP TST    CBFCNT   Is the buffer empty?
01077P 017A 26   03   017F        BNE    NOTMT    No, go get a char from it.
01078P 017C 03   70      A        COM    EOFFLG   Yes, end of file.
01079P 017E 39                    RTS
01080
01081P 017F 34   74      A NOTMT  PSHS   U,Y,X,B  Save registers.  (Save all because
0082                       *    of possible LODBUF call.)
01083P 0181 9E   7A      A        LDX    CBFPTR   Get char from cassette buffer, update
01084P 0183 A6   80      A        LDA    ,X+      the pointer, and decrement the count.
01085P 0185 34   02      A        PSHS   A        (Save the char too.)
01086P 0187 9F   7A      A        STX    CBFPTR
01087P 0189 0A   79      A        DEC    CBFCNT
01088P 018B 26   09   0196        BNE    CASIRT   Buffer still not empty, just return.
01089P 018D 96   6F      A        LDA    DEVNUM   Doing a download?
01090P 018F 81   FD      A        CMPA   #-&3
01091P 0191 27   05   0198        BEQ    LODDNL   Yes, use different load buffer
01092                      *    routine.
01093P 0193 BD   04CC    P        JSR    LODBUF   Reload the buffer.
010S4P 0196 35   F6      A CASIRT PULS   D,X,Y,U,PC Get the char into A, restore all regs
01095                      *    and return.
01096
01097P 0198 BD   0000    A LODDNL JSR    LDBUFR   Reload download buffer.
01098P 019B 20   F9   0196        BRA    CASIRT   Restore and return.

PAGE  009  ECBMOD  .SA:1  ECBMOD CHRINP - Character Input Routine

01100                      *
01101                      * KEYINP reads a char from the keyboard.
01102                      *
01103
01104            0001    A        IFNE   REALIO
01105P 019D 34   14      A KEYINP PSHS   X,B      Save the registers.
01106P 019F BD   0000    A KEYILP JSR    CBLINK   Blink the cursor.
01107P 01A2 BD   0000    A        JSR    POLCAT   Scan the keyboard.
01108P 01A5 27   F8   019F        BEQ    KEYILP   No key, look again.
01109P 01A7 C6   60      A        LDB    #@140    Have key, clear the cursor.
01110P 01A9 E7   9F 0088 A        STB    [CURADR]
01111P 01AD 35   94      A KEYFIN PULS   B,X,PC   Restore B and X and return with the
01112                      *    the char in A.
01113                             ENDC   IFN      REALIO
01114
01115            0001    A        IFEQ   REALIO
01118                       ENDC   IFE REALIO

PAGE  010  ECBMOD  .SA:1  ECBMOD CHRINP - Character Input Routine

01120                             TTL    CHROUT - Output Character Routine
01121
01122                      *
01123                      * CHROUT sends the character in A to the device specified by DEVNUM.
01124                      * The output is suppressed if DEVNUM indicates that file input is
01125                      * in progress.  This is done so character echo, input prompts
01126                      * (such as double question mark for more input), etc is ignored
01127                      * while inputting file data or loading an ASCII program file.
01128                      *
01129                      * All registers except CC are preserved.
01130                      *
01131
01132                             XDEF   CHROUT
01133P 01AF BD   0000    A CHROUT JSR    HKCHRO   RAM hook.
01134P 01B2 34   04      A        PSHS   B        Save B.
01135P 01B4 D6   6F      A        LDB    DEVNUM   Get the device number.
01136P 01B6 C1   FD      A        CMPB   #-&3     Doing a download?
01137P 01B8 26   02   01BC        BNE    NOTDNL   No.
01138P 01BA 35   84      A        PULS   B,PC     Yes, throw away the echo.
01139
01140P 01BC 5C             NOTDNL INCB            See what it is.
01141P 01BD 35   04      A        PULS   B        Restore B.
01142P 01BF 102B FE3D    A        LBMI   LPTOUT   Send char to printer.
01143P 01C3 26   2F   01F4        BNE    SCROPT   Send char to screen.
01144
01145P 01C5 34   16      A        PSHS   X,D      It's the cassette, save some regs.
01146P 01C7 D6   78      A        LDB    CASOPN   Is the cassette
01147P 01C9 5A                    DECB            open for input?
01148P 01CA 27   0F   01DB        BEQ    OUTRTS   Yes, throw this output away.
01149
01150                      *
01151                      * Output character to cassette file.
01152                      *
01153
01154P 01CC D6   79      A CASOUT LDB    CBFCNT   Get the character count.
01155P 01CE 5C                    INCB            Is the buffer full?
01156P 01CF 26   02   01D3        BNE    NOTFUL   No, go put the char in the buffer.
01157P 01D1 8D   0A   01DD        BSR    DMPBUF   Yes, write out the buffer.
01158P 01D3 9E   7A      A NOTFUL LDX    CBFPTR   Get pointer into buffer.
01159P 01D5 A7   80      A        STA    ,X+      Put the char away and increment the
01160P 01D7 9F   7A      A        STX    CBFPTR   pointer.
01161P 01D9 0C   79      A        INC    CBFCNT   Increment the count.
01162P 01DB 35   96      A OUTRTS PULS   D,X,PC   Restore regs and return.
01163
01164                      *
01165                      * Here to dump the cassette buffer to tape.
01166                      *
01167
01168P 01DD C6   01      A DMPBUF LDB    #&1      Set block type to data.
01169P 01DF D7   7C      A WRTEOF STB    BLKTYP
01170P 01E1 8E   0000    A        LDX    #CASBUF  Set address of data for WRTBLK.
01171P 01E4 9F   7E      A        STX    CBUFAD
01172P 01E6 D6   79      A        LDB    CBFCNT   Set the block length.
01173P 01E8 D7   7D      A        STB    BLKLEN
01174P 01EA 34   62      A        PSHS   U,Y,A    Save the rest.
01175P 01EC BD   05F6    P        JSR    WRTBLK   Write block out.
01176P 01EF 35   62      A        PULS   A,Y,U    Restore regs.
01177P 01F1 7E   04E7    P        JMP    MRKMT    Mark the buffer as empty.

PAGE  011  ECBMOD  .SA:1  ECBMOD CHROUT - Output Character Routine

01179                      *
01180                      * Ouput character to screen.
01181                      *
01182
01183            01F4    P SCROPT EQU    *
01184            0001    A        IFNE   REALIO
01185P 01F4 BD   0000    A        JSR    SAMALP   Switch to text mode.
01186P 01F7 7E   0000    A        JMP    SCROUT   Go to the screen driver.
01187                             ENDC   IFN      REALIO
01188
01189            0001    A        IFEQ   REALIO
01221                       ENDC    IFE REALIO

