       NAM    TXRPU    - PRINT USING for TCC Extension ROM.

**********************************************************************
*                                                                    *
*    Copyright 1982 by Microsoft Corporation, all rights reserved    *
*                                                                    *
**********************************************************************

       TTL    External Declarations

       XREF   CHKCOM,CHKSTR,CHROUT,CRDO
       XREF   DIV10
       XREF   FADDH,FBUFFR,FCERR,FDCEND,FMULT,FOUT,FOUTBL,FOUTCP,FRETMP
       XREF   FRMCHK,FRMEVL,FRMNUM
       XREF   LEFTUS
       XREF   MUL10
       XREF   N.0999,N.9999,N.MIL
       XREF   OUTSPC
       XREF   QINT
       XREF   STROUT,STRPRT,SYNCHR
       XREF   USINTK

       TTL    Equates

*
* The PRINT USING mask (PUMASK) bit definitions.
*

SCIFLG EQU    &1       Bit 0 - Scientific notation.
TRLFLG EQU    &4       Bit 2 - Trailing sign.
PLSFLG EQU    @10      Bit 3 - Print "+" instead of space
*      for positive numbers.
DOLFLG EQU    @20      Bit 4 - Floating dollar sign.
ASTFLG EQU    @40      Bit 5 - Asterisk fill.
COMFLG EQU    @100     Bit 6 - Insert commas.

FLTMON EQU    '$       Character to use for floating money
*    sign. Can be changed to a yen sign
*    for example.
MLCSTR EQU    '%       Character indicating a multi-char
*    string field. (For compatibility
*    with TRS-80 Model I Level II BASIC.

       TTL    The PRINT USING driver.

*
* Entered at PUTEST.
*

*
* Here to handle a string field.
*

SMSTRF LDA    #&1      Single char string field.
       STA    FLDWID
ISSTRF DECB            Decrement using string char count.
       JSR    PLSPRT   Print possible preceding plus.
       JSR    CHRGOT   End of value list reached?
       LBEQ   FLDFIN   Yes, PRINT USING is finished.
       STB    USSCNT   No, save using string char count.
       JSR    FRMEVL   Evaluate next value in the value list.
       JSR    CHKSTR   It must be a string to go into this
*    string field.
       LDX    FACMO    X:=pointer to the string descriptor.
       STX    DSCPNT   Set up DSCPNT for LEFT$ code.
       LDB    FLDWID   B:=width of string field.
       JSR    LEFTUS   Get leftmost B chars or whole string
*    if it's shorter than the field.
       JSR    STRPRT   Print the string.
       LDX    FACMO    See if spaces are needed to fill out
       LDS    FLDWID   the field.
       SUBB   ,X
UPRTSP DECB            More spaces to print?
       LBMI   FNSTRF   No, string field is finished.
       JSR    OUTSPC   Yes, print another one.
       BRA    UPRTSP   See if more.

*
* Here when MLCSTR is seen which indicates the start of a multi-char
* string field if it is followed by a variable number of spaces and
* another MLCSTR.
*

BGSTRF STB    USSCNT   Save the using string char count.
       STX    TEMPX1   Save the using string pointer.
       LDA    #&2      The field width is 2 for the MLCSTRs
       STA    FLDWID   plus the number of enclosed spaces.
LPSTRF LDA    ,X       Get next using string char.
       CMPA   #MLCSTR  End of the string field?
       BEQ    ISSTRF   Yes, go print the string.
       CMPA   #'       No, an enclosed space?
       BNE    NOSTRF   No, it isn't really a string field.
       INC    FLDWID   Yes, increment the field width.
       LEAX   &1,X     Point to the next using string char.
       DECB            Decrement using string char count.
       BNE    LPSTRF   Is there are more chars in the using
*    string then go scan them. Otherwise
*    the closing MLCSTR wasn't found and
*    therefore we aren't really looking
â€¢    at a string field.
NOSTRF LDX    TEMPX1   It isn't a string field so restore the
       LDB    USSCNT   using string pointer and char count.
       LDA    #MLCSTR  Just print the MLCSTR since it doesn't
*    belong to a field.
NEWUCH JSR    PLSPRT   Print possible preceding plus since
*    it didn't start a numeric field.
       JSR    CHROUT   Now print the current char since it
*    isn't part of a field.
       BRA    PRCCHR   Go look at the next using string char.

*
* The entry point of the PRINT USING driver.
*

       XDEF   PUDRVR
PUDRVR JSR    FRMCHK   Evaluate the using string.  FRMCHK
*    is called instead of FRMEVL because
*    TXTPTR is pointing to the USINTK
*    rather than the first char of the
*    string formula.
       JSR    CHKSTR   Make sure it is a string.
       LDB    #SEMCOL  It must be delimited by a semi-colon.
       JSR    SYNCHR
       LDX    FACMO    A pointer to the descriptor of the
       STX    USDPTR   using string is saved because calls
*    to FRMEVL might cause garbage
*    collection to occur.
       BRA    INIUS    Don't look at USLFG.

REUSST LDA    USFLG    Was a value from the value list
*    printed on the last scan of the using
*    string?
       BEQ    PUFCER   If not give Function Call error.
       LDX    USDPTR   X:=pointer to using string descriptor.
INIUS  CLR    USFLG    Say no values printed this scan.
       LDB    ,X       B:=length of using string.
       BNE    NTNLUS   If the using string is null give a
PUFCER JMP    FCERR    Function Call error.

NTNLUS LDX    &2,X     X:=pointer to using string characters.
PRCCHR CLR    PUMASK   Turn off all print using flag bits.
PLSFIN CLR    FLDWID   Field width for strings:=0.  Number
*    of digits before decimal point for
*    numbers:=0.
       LDA    ,X+      A:=char from using string.
       CMPA   #'!      A single char string field?
       LBEQ   SMSTRF   Yes, go handle it.
       CMPA   #'#      Start of a numeric field?
       BEQ    NUMNUM   Yes.
       DECB            No, all other possibilities require
*    at least two chars.
       BNE    TWOLFT   There are two chars.
       JSR    PLSPRT   This isn't a field so print preceding
*    plus if there was one.
       JSR    CHROUT   Print the current char.
FINUSI JSR    CHRGOT   We have reached the end of the using
*    string.  Are there more values?
       BNE    REUSST   Yes, go reuse the using string.
       LDA    USFLG    No, did the value list end with a
*    semicolon or comma?
FLDFIN BNE    FREUST   Yes, don't do CRLF.
       JSR    CRDO     No, finish up with a CRLF.
FREUST LDX    USDPTR   Free up the using string's temporary.
       JMP    FRETMP   and return.

TWOLFT CMPA   #'+      If plus then force out possible pre-
       BNE    NTPLUS   ceding plus and set the plus flag.
       JSR    PLSPRT
       LDA    #PLSFLG
       STA    PUMASK
       BRA    PLSFIN   Go look at next char.

NTPLUS CMPA   #'.      Numeric field with no digits before
       BEQ    DOTNUM   the decimal point?
       CMPA   #MLCSTR  A multi-char string field?
       LBEQ   BGSTRF   Go scan it.
       CMPA   ,X       Is the current char the same as the
*    next char?
GONWUC BNE    NEWUCH   No, so it isn't "$$", "**", or "**$".
*    all other possiblilities have been
*    checked so the current char isn't
*    part of a field.
       CMPA   #FLTMON  Yes, is the floating dollar sign?
       BEQ    DOLRNM   Yes.
       CMPA   #'*      No, how about asterisk fill or aster-
*    isk fill with floating dollar sign?
       BNE    GONWUC   No, it isn't a field.
       LDA    PUMASK   Set the asterisk fill flag.
       ORA    #ASTFLG
       STA    PUMASK
       CMPB   #&2      Are there enough chars for "**$"?
       BCS    NTBOTH   No.
       LDA    &1,X     Yes, check for the "$".
       CMPA   #FLTMON
       BNE    NTBOTH   It is some oher char.
       DECB            It is "**$" so decrement using string
       LEAX   &1,X     char count and advance the pointer.
       INC    FLDWID   Tne "$" makes room for another digit.
DOLRNM LDA    PUMASK   Set the floating dollar sign flag.
       ORA    #DOLFLG
       STA    PUMASK
NTBOTH LEAX   &1,X     Point beyond the second char (or
*    third for "**$").
       INC   FLDWID    Increment the digit count.
