       NAM    TXRPU    - PRINT USING for TCC Extension ROM.

**********************************************************************
*                                                                    *
*    Copyright 1982 by Microsoft Corporation, all rights reserved    *
*                                                                    *
**********************************************************************

       TTL    External Declarations

       XREF   CHKCOM,CHKSTR,CHROUT,CRDO
       XREF   DIV10
       XREF   FADDH,FBUFFR,FCERR,FDCEND,FMULT,FOUT,FOUTBL,FOUTCP,FRETMP
       XREF   FRMCHK,FRMEVL,FRMNUM
       XREF   LEFTUS
       XREF   MUL10
       XREF   N.0999,N.9999,N.MIL
       XREF   OUTSPC
       XREF   QINT
       XREF   STROUT,STRPRT,SYNCHR
       XREF   USINTK

       TTL    Equates

*
* The PRINT USING mask (PUMASK) bit definitions.
*

SCIFLG EQU    &1       Bit 0 - Scientific notation.
TRLFLG EQU    &4       Bit 2 - Trailing sign.
PLSFLG EQU    @10      Bit 3 - Print "+" instead of space
*      for positive numbers.
DOLFLG EQU    @20      Bit 4 - Floating dollar sign.
ASTFLG EQU    @40      Bit 5 - Asterisk fill.
COMFLG EQU    @100     Bit 6 - Insert commas.

FLTMON EQU    '$       Character to use for floating money
*    sign. Can be changed to a yen sign
*    for example.
MLCSTR EQU    '%       Character indicating a multi-char
*    string field. (For compatibility
*    with TRS-80 Model I Level II BASIC.

       TTL    The PRINT USING driver.

*
* Entered at PUTEST.
*

*
* Here to handle a string field.
*

SMSTRF LDA    #&1      Single char string field.
       STA    FLDWID
ISSTRF DECB            Decrement using string char count.
       JSR    PLSPRT   Print possible preceding plus.
       JSR    CHRGOT   End of value list reached?
       LBEQ   FLDFIN   Yes, PRINT USING is finished.
       STB    USSCNT   No, save using string char count.
       JSR    FRMEVL   Evaluate next value in the value list.
       JSR    CHKSTR   It must be a string to go into this
*    string field.
       LDX    FACMO    X:=pointer to the string descriptor.
       STX    DSCPNT   Set up DSCPNT for LEFT$ code.
       LDB    FLDWID   B:=width of string field.
       JSR    LEFTUS   Get leftmost B chars or whole string
*    if it's shorter than the field.
       JSR    STRPRT   Print the string.
       LDX    FACMO    See if spaces are needed to fill out
       LDS    FLDWID   the field.
       SUBB   ,X
UPRTSP DECB            More spaces to print?
       LBMI   FNSTRF   No, string field is finished.
       JSR    OUTSPC   Yes, print another one.
       BRA    UPRTSP   See if more.

*
* Here when MLCSTR is seen which indicates the start of a multi-char
* string field if it is followed by a variable number of spaces and
* another MLCSTR.
*

BGSTRF STB    USSCNT   Save the using string char count.
       STX    TEMPX1   Save the using string pointer.
       LDA    #&2      The field width is 2 for the MLCSTRs
       STA    FLDWID   plus the number of enclosed spaces.
LPSTRF LDA    ,X       Get next using string char.
       CMPA   #MLCSTR  End of the string field?
       BEQ    ISSTRF   Yes, go print the string.
       CMPA   #'       No, an enclosed space?
       BNE    NOSTRF   No, it isn't really a string field.
       INC    FLDWID   Yes, increment the field width.
       LEAX   &1,X     Point to the next using string char.
       DECB            Decrement using string char count.
       BNE    LPSTRF   Is there are more chars in the using
*    string then go scan them. Otherwise
*    the closing MLCSTR wasn't found and
*    therefore we aren't really looking
â€¢    at a string field.
NOSTRF LDX    TEMPX1   It isn't a string field so restore the
       LDB    USSCNT   using string pointer and char count.
       LDA    #MLCSTR  Just print the MLCSTR since it doesn't
*    belong to a field.
NEWUCH JSR    PLSPRT   Print possible preceding plus since
*    it didn't start a numeric field.
       JSR    CHROUT   Now print the current char since it
*    isn't part of a field.
       BRA    PRCCHR   Go look at the next using string char.

*
* The entry point of the PRINT USING driver.
*

       XDEF   PUDRVR
PUDRVR JSR    FRMCHK   Evaluate the using string.  FRMCHK
*    is called instead of FRMEVL because
*    TXTPTR is pointing to the USINTK
*    rather than the first char of the
*    string formula.
       JSR    CHKSTR   Make sure it is a string.
       LDB    #SEMCOL  It must be delimited by a semi-colon.
       JSR    SYNCHR
       LDX    FACMO    A pointer to the descriptor of the
       STX    USDPTR   using string is saved because calls
*    to FRMEVL might cause garbage
*    collection to occur.
       BRA    INIUS    Don't look at USLFG.

REUSST LDA    USFLG    Was a value from the value list
*    printed on the last scan of the using
*    string?
       BEQ    PUFCER   If not give Function Call error.
       LDX    USDPTR   X:=pointer to using string descriptor.
INIUS  CLR    USFLG    Say no values printed this scan.
       LDB    ,X       B:=length of using string.
       BNE    NTNLUS   If the using string is null give a
PUFCER JMP    FCERR    Function Call error.

NTNLUS LDX    &2,X     X:=pointer to using string characters.
PRCCHR CLR    PUMASK   Turn off all print using flag bits.
PLSFIN CLR    FLDWID   Field width for strings:=0.  Number
*    of digits before decimal point for
*    numbers:=0.
       LDA    ,X+      A:=char from using string.
       CMPA   #'!      A single char string field?
       LBEQ   SMSTRF   Yes, go handle it.
       CMPA   #'#      Start of a numeric field?
       BEQ    NUMNUM   Yes.
       DECB            No, all other possibilities require
*    at least two chars.
       BNE    TWOLFT   There are two chars.
       JSR    PLSPRT   This isn't a field so print preceding
*    plus if there was one.
       JSR    CHROUT   Print the current char.
FINUSI JSR    CHRGOT   We have reached the end of the using
*    string.  Are there more values?
       BNE    REUSST   Yes, go reuse the using string.
       LDA    USFLG    No, did the value list end with a
*    semicolon or comma?
FLDFIN BNE    FREUST   Yes, don't do CRLF.
       JSR    CRDO     No, finish up with a CRLF.
FREUST LDX    USDPTR   Free up the using string's temporary.
       JMP    FRETMP   and return.

TWOLFT CMPA   #'+      If plus then force out possible pre-
       BNE    NTPLUS   ceding plus and set the plus flag.
       JSR    PLSPRT
       LDA    #PLSFLG
       STA    PUMASK
       BRA    PLSFIN   Go look at next char.

NTPLUS CMPA   #'.      Numeric field with no digits before
       BEQ    DOTNUM   the decimal point?
       CMPA   #MLCSTR  A multi-char string field?
       LBEQ   BGSTRF   Go scan it.
       CMPA   ,X       Is the current char the same as the
*    next char?
GONWUC BNE    NEWUCH   No, so it isn't "$$", "**", or "**$".
*    all other possiblilities have been
*    checked so the current char isn't
*    part of a field.
       CMPA   #FLTMON  Yes, is the floating dollar sign?
       BEQ    DOLRNM   Yes.
       CMPA   #'*      No, how about asterisk fill or aster-
*    isk fill with floating dollar sign?
       BNE    GONWUC   No, it isn't a field.
       LDA    PUMASK   Set the asterisk fill flag.
       ORA    #ASTFLG
       STA    PUMASK
       CMPB   #&2      Are there enough chars for "**$"?
       BCS    NTBOTH   No.
       LDA    &1,X     Yes, check for the "$".
       CMPA   #FLTMON
       BNE    NTBOTH   It is some oher char.
       DECB            It is "**$" so decrement using string
       LEAX   &1,X     char count and advance the pointer.
       INC    FLDWID   Tne "$" makes room for another digit.
DOLRNM LDA    PUMASK   Set the floating dollar sign flag.
       ORA    #DOLFLG
       STA    PUMASK
NTBOTH LEAX   &1,X     Point beyond the second char (or
*    third for "**$").
       INC   FLDWID    Increment the digit count.

*
* Scan the leading digits (before decimal point) of a numeric field.
*

NUMNUM CLR    DPWID    Number of trailing (after decimal
*    point) :=0.
NUMLOP INC    FLDWID   Increment the leading (before decimal
*    point) digit count.
       DECB            More chars in the using string?
       BEQ    ENDNUS   No, end of numeric field.
       LDA    ,X+      Yes, get the next char.
       CMPA   #'.      Is it the decimal point?
       BEQ    AFTDOT   Yes, go scan the trailing digit specs.
       CMPA   #'#      No, is it another leading digit?
       BEQ    NUMLOP   Yes, scan the next char.
       CMPA   #COMMA   Do they want a comma every 3 digits?
       BNE    FINNUM   No, no more leading digit specs.
       LDA    PUMASK   Yes, set the comma flag.
       ORA    #COMFLG
       STA    PUMASK
       BRA    NUMLOP   Scan for more leading digits.

DOTNUM LDA    ,X       Is this dp (decimal point) the start
       CMPA   #'#      of a numeric field?
       LBNE   NEWUCH   No, go print the ".".
       LDA    #&1      Yes, init count of trailing digits.
       STA    DPWID    The decimal point is included in this
*    COUNT.
       LEAX   &1,X     Point past the decimal point.
AFTDOT INC    DPWID    Increment trailing digit count.
       DECB            More chars in using string?
       BEQ    ENDNUS   No, it's the end of the numeric field.
       LDA    ,X+      Yes, do we have another digit spec?
       CMPA   #'#
       BEQ    AFTDOT   Yes, look for more.
*    NO, NOW LOOK FOR SCIENTIFIC NOTATION
*    SPEC.
FINNUM CMPA   #'^      ^^^ indicates scientific notation.
       BNE    ENDNUS
       CMPA   ,X
       BNE    ENDNUS
       CMPA   &1,X
       BNE    ENDNUS
       CMPA   &2,X
       BNE    ENDNUS
       CMPB   #&4      Make sure the four chars just checked
*    actually belong to the using string
*    by ensuring that the using string
*    contains enough characters.
       BCS    ENDNUS   It doesn't so we were looking at chars
*    that don't belong to the using string.
*    therefore we don't have scientific
*    notation spec.
       SUBB   #&4      It does, so we do have scientific
       LEAX   &4,X     notation.  Fix up the using string
*    count and pointer.
       INC    PUMASK   Set the scientific notation flag.
*    (Bit 0 of PUMASK.)

ENDNUS LEAX   -&1,X    Back up using string pointer so
*    we can check for trailing sign spec.
       INC    FLDWID   Increment the leading digit count
*    in case there was a leading sign spec.
       LDA    PUMASK   Was there a leading sign spec?
       BITA   #PLSFLG
       BNE    ENDNUM   Yes, so there can't be a trailing sign.
       DEC    FLDWID   No, adjust the field width back.
       TSTB            At the end of the using string?
       BEQ    ENDNUM   Yes, so can't have trailing sign.
       LDA    ,X       No, check for trailing sign.
       SUBA   #'-      If there is one it is a "+" or "-".
       BEQ    SGNTRL   Have trailing minus.
       CMPA   #'+-'-
       BNE    ENDNUM   Don't have trailing sign.
       LDA    #PLSFLG  Have trailing plus, set the plus flag.
SGNTRL ORA    #TRLFLG  Set the trailing sign flag.
       ORA    PUMASK
       STA    PUMASK
       DECB            Decrement length of using string for
*  trailing sign.
ENDNUM JSR    CHRGOT   Any more values?
       LBEQ   FLDFIN   No, print using check out time.
       STB    USSCNT   Yes, save using string char count.
       JSR    FRMNUM   Evaluate a numeric formula.
       LDA    FLDWID   If the total field width is too big
       ADDA   DPWID    then give a Function Call error.
       CMPA   #&14+&3*ADDPRC
       LBHI   FCERR
       JSR    PUFOUT   Convert the number into ASCII in
*    FBUFFR.
       LEAX   -&1,X
       JSR    STROUT   Actually print the number.
