       NAM    ECBM64

**********************************************************************
*                                                                    *
*    Copyright 1982 by Microsoft Corporation, all rights reserved    *
*                                                                    *
**********************************************************************

       TTL     External Declarations

       XREF    ALPHLK,ASC2,ASCFLG
       XREF    BITIN,BUF
       XREP    CASBUF,CASOFF,CASON,CBIN,CBLINK,CBOUT,CHKCLS,CHKCOM,CHKOPN
       XREF    CHR$DO,CLOADM,COMBYT,CONINT,CRDO,CSAVEM,CSFNAM,CSRDON
       XREF    CLEARC
       XREF    DBNCNT
       XREF    ENDHKS,ERRAO,ERRBM,ERRDN,ERRIO,ERRNO,ERROR,EVLADR
       XREF    FCERR,FILNAM,FILTYP,FINI,FNAMLN,FRESTR,FRMEVL,FRMNUM
       XREF    FUNDSP,FUNLST
       XREF    GAPFLG,GETBYT,GIVABF,GOPTNW
       XREF    HDRLEN,HKBRKC,HKCHRI,HKCHRO,HKCKDI,HRCKDO,HKCLS,HKCLS1
       XREF    HKCLSA,HKDNCK,HKDPRM,HKEOF,HKFNLD,HKINLN,HKOPEN,HOOKS
       XREF    INTCNV,INTIDX,ISCNTC,INTWDG
       XREF    JOYIN
       XREF    LDBUFR,LIST,LOADAD,LPTOUT
       XREF    MAIN
       XREF    NFUNTK,NNRMTK,NRTSH3,NRTSHK,NZLINK
       XREF    OFFTK,ONTK
       XREF    PINIT,POLCAT,POTVAL
       XREF    READY,REASON,REDDY,RESLST,ROLTBL
       XREF    SAMALP,SCROUT,SCRTCH,SNERR,SNGFLT
       XREF    STKINI,STMDSP,STROUT,STRTAD,STUBO,SYNCHR
       XREF    TEMPST
       XREF    USRTAB
       XREF    VIRQ
       XREF    WRTLDR
       XREF    XRRUN,XRSLWC

       IFEQ    REALIO
 ENDC   IFE REALIO

       TTL    Equates

       XDEF   SCRADR
SCRADR EQU    @2000    Address of screen memory (400 hex).

       IFNE   METTOY
       XDEF   PIA0AD
PIA0AD EQU    @177400  PIA0, side A, data reg.  (FF00)
       ENDC   IFN      METTOY
       IFNE   GRPTEK
 ENDC   IFN GRPTEK
       XDEF   PIA0AC
PIA0AC EQU    PIA0AD+&1 PIA0, side A, control  reg.
       XDEF   PIA0BD
PIA0BD EQU    PIA0AC+&1 PIA0, side B, data reg.
       XDEF   PIA0BC
PIA0BC EQU    PIA0BD+&1 PIA0, side B, control reg.

       IFNE   METTOY
       XDEF   PIA1AD
PIA1AD EQU    @177440  PIA1, side A, data reg.  (FF20)
       ENDC   IFN      METTOY
       IFNE   GRPTEK
  ENDC  IFN GRPTEK
       XDEF   PIA1AC
PIA1AC EQU    PIA1AD+&1 PIA1, side A, control reg.
       XDEF   PIA1BD
PIA1BD EQU    PIA1AC+&1 PIA1, side B, data reg.
       XDEF   PIA1BC
PIA1BC EQU    PIA1BD+&1 PIA1, side B, conrtrol reg.

CARTRM EQU    @140000  Address of cartridge ROM.  (C000)
EXTROM EQU    @100000  Address of extension ROM.  (8000)

       XDEF   SAM
SAM    EQU    @177700  Address of SAM chip.  (FFC0)

DSKRUM EQU    @140000 The address of the disk ROM.  (C000)

BOOT64 EQU    $BE7F
FLAG64 EQU    $11A
       TTL    Power up and Reset code.
       XDEF   POWRUP
POWRUP EQU    *        DUMMY LABEL FOR 64K VERSION
       XDEF   ZHRDIN
ZHRDIN EQU    *
       XDEF   INIT
INIT   LDX    #LORAM   INITIALISE DIRECT PAGE RAM
       LDU    #EXECAD
       LDB    #NLORAM
       JSR    COPLOP
       LDU    #VIRQ    INITIALISE RAM OFF DIRECT PAGE
       LDB    #NMDRAM  UP TO 64K FLAG
       JSR    COPLOP
       LEAU   5,U      SKIP PAST USED BYTES
       LDB    #NHIRAM
       JSR    COPLOP
       LDX    #SNERR   X:=SNERR FOR INITIALISING THE DISPATCH
       STX    &3,U     INIT STUB 1 DISPATCH ADDRESS
       STX    &8,U
       LDX    #HOOKS
       LDD    #$3900+NRTSH3
INIHKS STA    ,X+
       DECB
       BNE    INIHKS
       JSR    GRNCHR  Clear the screen.
       JSR    CLEARC  DESTROY OLD VARIABLES
       ANDCC  #$FF!X(F!+I) Allow the cartridge to interrupt now
*    before displaying the sign on message.
       LDX    #SIGNON-&1 Print the sign on message.
       JSR    STROUT
       XDEF   FINIT
FINIT  LDA    #@125    Set the restart flag.
       STA    RSTFLG
       STA    FLAG64
       BRA    BASRST
*
* Here to restart BASIC.
*
       XDEF   ZSFTIN
ZSFTIN JSR    GRNCHR
       XDEF   BASRST
BASRST CLR    DURCNT   Clear the PLAY note duration count
       CLR    DURCNT+&1 so interrupts don't think we are
*    still playing the note.
       LDA    PIA0BC   Enable the 60 hertz interrupt.
       ORA    #&1
       STA    PIA0BC
       CLR    DEVNUM   Make sure output goes to screen and
*    input comes from keyboard.
       JSR    STKINI   Reset the stack and things.
       ANDCC  #$FF!X(F!+I) Enable interrupts.
GORDY  JMP    READY    Go say "OK".


*
* Here on a FIRQ to handle the cartridge interrupt.
*
       XDEF   CARTRG
CARTRG TST    PIA1BC   Did the cartridge cause the interrupt?
       BMI    GOCART   Yes.
       RTI             No, return from the interrupt.

GOCART JSR    DELHAF   Delay for about a second
       CLR    RSTFLG   Don't allow BASIC to be restarted.
       JMP    CARTRM   Go execute the cartrige program.

*
* Delay for about one half second.
*

       XDEF   DELHAF
DELHAF LDX    DBLZER
DELAY  LEAX   -&1,X
       BNE    DELAY
       RTS

*
* Tnis stuff gets block transferred into RAM during initialization.
*

LORAM  FDB    FCERR    EXECAD
       INC    TXTPTR+&1 CHRGET RAM code.
       BNE    CHRLOD
       INC    TXTPTR
CHRLOD LDA    >0       (Force extended addressing.)
       JMP    ROMLOC

NLORAM EQU    *-LORAM

MIDRAM JMP    INTWDG   VIRQ WEDGE (AUTO-REPEAT & RS232)
       JMP    CARTRG   VFIRQ
       FCB    &0       TICKER (Overlays 8K version's USRJMP.)
       FCB    &0       (Was JMP FCERR for 8k version.)
       FCB    &0
       FCB    @200     RNDX
       FCB    @117
       FCB    @307
       FCB    @122
       IFNE   ADDPRC
       FCB    @131
NMDRAM EQU    *-MIDRAM
       ENDC   IFN      ADDPRC

HIRAM  FCB    &5        INTER-REPEAT DELAY
       FCB    NNRMTK    STUB0
       FDB    RESLST
       FDB    STMDSP
       FCB    NFUNTK
       FDB    FUNLST
       FDB    FUNDSP

NHIRAM EQU    *-HIRAM

       IFNE   METTOY
SIGNON FCC    /(C) 1983 DRAGON DATA LTD /
       FCB    CR
       FCC    /16K BASIC INTERPRETER 1.0      /
       FCB    CR
MICRO  FCC    /(C) 1983 BY MICROSOFT/
       FCB    CR
       FCB    CR
       FCB    &0
       ENDC   IFN      METTOY

       IFNE   GRPTEK
 ENDC   IFN GRPTEK

       TTL    CHRINP - Character Input Routine

*
* CHRINP inputs a character from the device specified by DEVNUM.
* The character is returned in A.
* All registers except A and CC are preserved.
* If end of file is hit, EOFFLG=.TRUE.=non-zero, and A is meaningless.
*
* INCHR is called instead of CHRINP when a 7 bit code is wanted.
*

       XDEF   INCHR
INCHR  BSR    CHRINP   Read a character.
       ANDA   #@177    Clear the high order bit.
       RTS             Return with it


       XDEF   CHRINP
CHRINP JSR    HKCHRI   RAM hook.
       CLR    EOFFLG   End of file flag:=.FALSE.
       TST    DEVNUM   Check the device number.
       BEQ    KEYINP   Go handle the keyboard.
*    No, fall into CASINP to get char from
*    cassette.

*
* CASINP reads a character from a cassette file.
* (Also used for downloading in the extended version.)
*

CASINP TST    CBFCNT   Is the buffer empty?
       BNE    NOTMT    No, go get a char from it.
       COM    EOFFLG   Yes, end of file.
       RTS

NOTMT PSHS    U,Y,X,B Save registers.  (Save all because
*    of bossible LODBUF call.)
       LDX    CBFPTR   Get char from cassette buffer, update
       LDA    ,X+      the pointer, and decrement the count.
       PSHS   A        (Save the char too.)
       STX    CBFPTR
       DEC    CBFCNT
       BNE    CASIRT   Buffer still not empty, just return.
       LDA    DEVNUM   Doing a download?
       CMPA   #-&3
       BEQ    LODDNL   Yes, use different load buffer
*    routine.
       JSR    LODBUF   Reload the buffer.
CASIRT PULS   D,X,Y,U,PC Get tne char into A, restore all regs
*    and return.

LODDNL JSR    LDBUFR   Reload download buffer.
       BRA    CASIRT   Restore and return.

*
* KEYINP reads a char from the keyboard.
*

       IFNE   REALIO
KEYINP PSHS   X,B      Save the registers.
KEYILP JSR    CBLINK   Blink the cursor.
       JSR    POLCAT   Scan the keyboard.
       BEQ    KEYILP   No key, look again.
       LDB    #@140    Have key, clear the cursor.
       STB    [CURADR]
KEYFIN PULS   B,X,PC   Restore B and X and return with the
*    the char in A.
       ENDC   IFN      REALIO

       IFEQ   REALIO
 ENDC   IFE REALIO

       TTL    CHROUT - Output Character Routine

*
* CHROUT sends the character in A to the device specified by DEVNUM.
* The output is suppressed if DEVNUM indicates that file input is
* in progress.  This is done so character echo, input prompts
* (such as double duestion mark for more input), etc is ignored
* while inputting file data or loading an ASCII program file.
*
* All registers except CC are preserved.
*

       XDEF   CHROUT
CHROUT JSR    HKCHRO   RAM hook.
       PSHS   B        Save B.
       LDB    DEVNUM   Get the device number.
       CMPB   #-&3     Doing a download?
       BNE    NOTDNL   No.
       PULS   B,PC     Yes, throw away the echo.

NOTDNL INCB            See what it is.
       PULS   B        Restore B.
       LBMI   LPTOUT   Send char to printer.
       BNE    SCROPT   Send char to screen.

       PSHS   X,D      It's the cassette, save some regs.
       LDB    CASOPN   Is the cassette
       DECB            open for input?
       BEQ    OUTRTS   Yes, throw this output away.

*
* Output character to cassette file.
*

CASOUT LDB    CBFCNT   Get the character count.
       INCB            Is the buffer full?
       BNE    NOTFUL   No, go put the char in the buffer.
       BSR    DMPBUF   Yes, write out the buffer.
NOTFUL LDX    CBFPTR   Get pointer into buffer.
       STA    ,X+      Put the char away and increment the
       STX    CBFPTR   pointer.
       INC    CBFCNT   Increment the count.
OUTRTS PULS   D,X,PC   Restore regs and return.

*
* Here to dump the cassette buffer to tape.
*

DMPBUF LDB    #&1      Set block type to data.
WRTEOF STB    BLKTYP
       LDX    #CASBUF  Set address of data for WRTBLK.
       STX    CBUFAD
       LDB    CBFCNT   Set the block length.
       STB    BLKLEN
       PSHS   U,Y,A    Save the rest.
       JSR    WRTBLK   Write block out.
       PULS   A,Y,U    Restore regs.
       JMP    MRKMT    Mark the buffer as empty.
