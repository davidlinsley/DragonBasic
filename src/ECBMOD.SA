

       NAM    ECBMOD

**********************************************************************
*                                                                    *
*    Copyright 1982 by Microsoft Corporation, all rights reserved    *
*                                                                    *
**********************************************************************

       TTL    External Declarations

       XREF   ALPHLK,ASC2,ASCFLG
       XREF   BOOT64,BITIN,BUF
       XREF   CASBUF,CASOFF,CASON,CBIN,CBLINK,CBOUT,CHKCLS,CHKCOM,CHKOPN
       XREF   CHR$DO,CLOADM,COMBYT,CONINT,CRDO,CSAVEM,CSFNAM,CSRDON
       XREF   DBNCNT
       XREF   ENDHKS,ERRAO,ERRBM,ERRDN,ERRIO,ERRNO,ERROR,EVLADR
       XREF   FCERR,FILNAM,FILTYP,FINI,FNAMLN,FRESTR,FRMEVL,FRMNUM
       XREF   FUNDSP,FUNLST
       XREF   GAPFLG,GETBYT,GIVABF,GOPTNW
       XREF   HDRLEN,HKBRKC,HRCHRI,HRCHRO,HKCKDI,HRCKDO,HKCLS,HKCLS1
       XREF   HKCLSA,HKDNCK,HKDPRM,HKEOF,HKFNLD,HKINLN,HKOPEN,HOOKS
       XREF   HRDINI
       XREF   INTCNV,INTIDX,ISCNTC,INTWDG
       XREF   JOYIN
       XREF   LDBUFR,LIST,LOADAD,LPTOUT
       XREF   MAIN
       XREF   NFUNTK,NNRMTK,NRTSH3,NRTSHK,NZLINK
       XREF   OFFTK,ONTK
       XREF   PINIT,POLCAT,POTVAL
       XREF   READY,REASON,REDDY,RESLST,ROLTBL
       XREF   SAMALP,SCROUT,SCRTCH,SFTINI,SNERR,SNGFLT
       XREF   STKINI,STMDSP,STROUT,STRTAD,STUBO,SYNCHR
       XREF   TEMPST
       XREF   USRTAB
       XREF   VIRQ
       XREF   WRTLDR
       XREF   XRRUN,XRSLWC

       IFEQ   REALIO
 ENDC   IFE REALIO

       TTL    Equates

       XDEF   SCRADR
SCRADR EQU    @2000    Address of screen memory (400 hex).

       IFNE   METTOY
       XDEF   PIA0AD
PIA0AD EQU    @177400  PIA0, side A, data reg.  (FF00)
       ENDC   IFN      METTOY
       IFNE   GRPTEK
 ENDC   IFN GRPTEK
       XDEF   PIA0AC
PIA0AC EQU    PIA0AD+&1 PIA0, side A, control reg.
       XDEF   PIA0BD
PIA0BD EQU    PIA0AC+&1 PIA0, side B, data reg.
       XDEF   PIA0BC
PIA0BC EQU    PIA0BD+&1 PIA0, side B, control reg.

       IFNE   METTOY
       XDEF   PIA1AD
PIA1AD EQU    @177440  PIA1, side A, data reg.  (FF20)
       ENDC   IFN      METTOY
       IFNE   GRPTEK
 ENDC   IFN GRPTEK
       XDEF   PIA1AC
PIA1AC EQU    PIA1AD+&1 PIA1, side A, control reg.
       XDEF   PIA1BD
PIA1BD EQU    PIA1AC+&1 PIA1, side B, data reg.
       XDEF   PIA1BC
PIA1BC EQU    PIA1BD+&1 PIA1, side B, conrtrol reg.

CARTRM EQU    @140000  Address of cartridge ROM.  (C000)
EXTROM EQU    @100000  Address of extension ROM.  (8000)

       XDEF   SAM
SAM    EQU    @177700  Address of SAM chip.  (FFC0)

DSKROM EQU    @140000  The address of the disk ROM.  (C000)

       TTL    Power up and Reset code.

*
* Here on RESET and power up after executing HRDINI routine.
*

HRDRT1 LDS    #BUF+BUFLEN Set up a temporary stack.
       IFNE   REALIO
       LDA    #@67     Enable the cartridge interrupt
       STA    PIA1BC   at the PIA.
       ENDC   IFN      REALIO
       LDA    RSTFLG   Is the restart flag set?
       CMPA   #@125
       BNE    INIT     No, must go through initialization.
       LDX    RSTVEC   Yes, does the restart vector point
       LDA    ,X       to a NOP instruction?
       CMPA   #@22
       BNE    INIT     No, must go through initialization.
*    This check is made so that if the
*    user pulls out a cartridge and hits
*    reset we won't jump to the restart
*    address where there is no longer
*    any code.
       JMP    ,X       Restart the current program.

*
* Here on reset and power up.
*

       XDEF   POWRUP
POWRUP LEAY   HRDRT1,PCR Set up return address for HRDINI.
       JMP    HRDINI   (Can't use stack since RAM is no
â€¢    good until the SAM is initialized.)
*
* Here to perform BASIC initialization.
*

       XDEF   INIT
INIT   EQU    *
       IFNE   REALIO
       LDX    #SCRADR+&1 Clear RAM from 0 to the start of the
CLRRAM CLR    ,--X     screen memory.
       LEAX   &1,X     (This roundabout method saves bytes
       BNE    CLRRAM   over the more obvious way.)
       JSR    GRNCHR   Clear the screen and make X point to
*    the first byte following the screen
*    memory.
       ENDC   IFN      REALIO
       IFEQ   REALIO
 ENDC   IFE REALIO
       CLR    ,X+      Put a zero below TXTTAB and set it
       STX    TXTTAB   up.

*
* Here to find the top of RAM.
*

       IFNE   REALIO
MEMLOP LDA    &2,X     Get byte from memory.
       COMA            Invert all  the bits.
       STA    &2,X     Store the complement.
       CMPA   &2,X     Did it store OK?
       BNE    HAVEND   No, this byte is not useable RAM.
       LEAX   &1,X     Yes, bump the address.
       COM    &1,X     Restore the original contents.
       BRA    MEMLOP   Look at the next byte.
       ENDC   IFN      REALIO

       IFEQ   REALIO
 ENDC   IFE REALIO
HAVEND STX    ENDMEM   Set pointer to end of memory.  Don't
*    use last good byte so VAL trick will
*    work OK in the degenerate case.
       STX    MEMSIZ   Mark end of BASIC's memory.
       STX    FRETOP   This is the end of string space also.
       LEAX   -STRSPC,X Set the bottom of string space.
       STX    STKTOP   This is the top of the stack.
       TFR    X,S      Switch from temp stack to BASIC's
*    real stack.
       JSR    SFTINI   Init the I/O driver routines.
       IFNE   REALIO
       LDX    #LORAM   Initialize direct page RAM.
       LDU    #EXECAD
       LDB    #NLORAM
       JSR    COPLOP
       LDU    #VIRQ    Initialize RAM off the direct page.
       LDB    #NHIRAM
       JSR    COPLOP
       LDX    #SNERR   X:=SNERR for intializing the dispatch
*    addresses of stub 1.
       ENDC   IFN      REALIO
       IFEQ   REALIO
 ENDC   IFE REALIO
       STX    &3, U    Init the stub 1 dispatch addresses.
       STX    &8,U
       IFNE   REALIO
       LDX    #HOOKS   Initialize the extension hooks by
*    putting in RTS instructions.
       LDD    #$3900+NRTSH3 A:=RTS opcode,
*    B:=number of bytes
*    to initialize.
*    (Add $Z since NRTSHK is external.)
INIHKS STA    ,X+      (Note that putting RTS instructions
       DECB            into all three bytes of each hook is
       BNE    INIHKS   OK and saves bytes here.)
       STA    NZLINK   Make NZLINK nonzero for CHEAD.
       ENDC   IFN      REALIO
       JSR    SCRTCH   Set up everthing else.
       JSR    XRRUN    Set up the PLAY and DRAW defaults.
       LDX    #USRTAB  Put the address of USRTAB into
       STX    USTBAD   USTBAD so USRTAB can be referenced
*    indirectly through USTBAD.
       LDU    #FCERR   Init all USRTAB entries so they
       LDB    #&10     dispatch to FCERR unless explicitly
FCUSLP STU    ,X++     defined by the user.
       DECB
       BNE    FCUSLP
       IFNE   REALIO
       JSR    PINIT    Init for graphics code.
       LDA    PIA0BC   Enable the 60 Hertz interrupt.
       ORA    #&1
       STA    PIA0BC
       LDX    #'D*&256+'K Is there a disk ROM in the machine?
       CMPX   DSKROM
       LBEQ   DSKROM+&2 Yes, go to its initialization code.
       ENDC   IFN      REALIO
       ANDCC  #$FF!X(F!+I) Allow the cartridge to interrupt now
*    before displaying the sign on message.
       LDX    #SIGNON-&1 Print the sign on message.
       JSR    STROUT
       LDX    #BASRST  Set the restart vector.
       STX    RSTVEC
       XDEF   FINIT
FINIT  LDA    #@125    Set the restart flag.
       STA    RSTFLG
       BRA    GORDY    Go to command level and say "OK".

*
* Here to restart BASIC.
*

       XDEF   BASRST
BASRST NOP             The NOP required of all restart entry
*    points.
       CLR    DURCNT   Clear the PLAY note duration count
       CLR    DURCNT+&1 so interrupts don't think we are
*    still playing the note.
       LDA    PIA0BC   Enable the 60 hertz interrupt.
       ORA    #&1
       STA    PIA0BC
       CLR    DEVNUM   Make sure output goes to screen and
*    input comes from keyboard.
       JSR    STKINI   Reset the stack and things.
       ANDCC  #$FF!X(F!+I) Enable interrupts.
       JSR    GRNCHR   Clear the screen.
GORDY  JMP    READY    Go say "OK".


*
* Here on a FIRQ to handle the cartridge interrupt.
*

CARTRG TST    PIA1BC   Did the cartridge cause the interrupt?
       BMI    GOCART   Yes.
       RTI             No, return from the interrupt.

GOCART JSR    DELHAF   Delay for about a second to let the
       JSR    DELHAF   user finish installing the cartridge.
       LEAY   <HRDRT2,PCR Init the hardware.  HRDINI leaves the
       JMP    HRDINI   cartridge interrupt disabled.
HRDRT2 CLR    RSTFLG   Don't allow BASIC to be restarted.
       JMP    CARTRM   Go execute the cartrige program.

*
* Delay for about one half second.
*

       XDEF   DELHAF
DELHAF LDX    DBLZER
DELAY  LEAX   -&1,X
       BNE    DELAY
       RTS

*
* This stuff gets block transferred into RAM during initialization.
*

LORAM  FDB    BOOT64   EXECAD FOR 64K INITIALISATION
       INC    TXTPTR+&1 CHRGET RAM code.
       BNE    CHRLOD
       INC    TXTPTR
CHRLOD LDA    >0       (Force extended addressing.)
       JMP    ROMLOC

NLORAM EQU    *-LORAM

HIRAM  JMP    XRSLWC   VIRQ
       JMP    CARTRG   VFIRQ
       FCB    &0       TICKER (Overlays 8K version's USRJMP.)
       FCB    &0       (Was JMP FCERR for 8k version.)
       FCB    &0
       FCB    @200     RNDX
       FCB    @117
       FCB    @307
       FCB    @122
       IFNE   ADDPRC
       FCB    @131
       ENDC   IFN      ADDPRC
       FCB    &0       ALPHLK in Color Computer.
       FDB    &0       DBNCNT in Color Computer.
       FCB    &0       The RAM hook FPWRT used to be here
       FCB    &0       and was set uo with a JMP SNERR
       FCB    &5       INTER-REPEAT DELAY
       FCB    NNRMTK   STUB0
       FDB    RESLST
       FDB    STMDSP
       FCB    NFUNTK
       FDB    FUNLST
       FDB    FUNDSP

NHIRAM EQU    *-HIRAM

       IFNE   METTOY
SIGNON FCC    /(C) 1982 DRAGON DATA LTD /
       FCB    CR
       FCC    /16K BASIC INTERPRETER 1.0      /
       FCB    CR
MICRO  FCC    /(C) 1982 BY MICROSOFT/
       FCB    CR
       FCB    CR
       FCB    &0
       ENDC   IFN      METTOY

       IFNE     GRPTEK
 ENDC   IFN GRPTEK

       TTL    CHRINP - Character Input Routine

*
* CHRINP inputs a character from the device specified by DEVNUM.
* The character is returned in A.
* All registers except A and CC are preserved.
* If end of file is hit, EOFFLG=.TRUE.=non-zero, and A is meaningless.
*
* INCHR is called instead of CHRINP when a 7 bit code  is wanted.
*

       XDEF   INCHR
INCHR  BSR    CHRINP   Read a character.
       ANDA   #@177    Clear the high order bit.
       RTS             Return with it


       XDEF   CHRINP
CHRINP JSR    HKCHRI   RAM hook.
       CLR    EOFFLG   End of file flag:=.FALSE.
       TST    DEVNUM   Check the device number.
       BEQ    KEYINP   Go handle the keyboard.
*    No, fall into CASINP to get char from
*    cassette.

*
* CASINP reads a character from a cassette file.
* (Also used for downloading in the extended version.)
*

CASINP TST    CBFCNT   Is the buffer empty?
       BNE    NOTMT    No, go get a char from it.
       COM    EOFFLG   Yes, end of file.
       RTS

NOTMT  PSHS   U,Y,X,B  Save registers.  (Save all because
*    of possible LODBUF call.)
       LDX    CBFPTR   Get char from cassette buffer, update
       LDA    ,X+      the pointer, and decrement the count.
       PSHS   A        (Save the char too.)
       STX    CBFPTR
       DEC    CBFCNT
       BNE    CASIRT   Buffer still not empty, just return.
       LDA    DEVNUM   Doing a download?
       CMPA   #-&3
       BEQ    LODDNL   Yes, use different load buffer
*    routine.
       JSR    LODBUF   Reload the buffer.
CASIRT PULS   D,X,Y,U,PC Get the char into A, restore all regs
*    and return.

LODDNL JSR    LDBUFR   Reload download buffer.
       BRA    CASIRT   Restore and return.

*
* KEYINP reads a char from the keyboard.
*

       IFNE   REALIO
KEYINP PSHS   X,B      Save the registers.
KEYILP JSR    CBLINK   Blink the cursor.
       JSR    POLCAT   Scan the keyboard.
       BEQ    KEYILP   No key, look again.
       LDB    #@140    Have key, clear the cursor.
       STB    [CURADR]
KEYFIN PULS   B,X,PC   Restore B and X and return with the
*    the char in A.
       ENDC   IFN      REALIO

       IFEQ   REALIO
 ENDC   IFE REALIO

       TTL    CHROUT - Output Character Routine

*
* CHROUT sends the character in A to the device specified by DEVNUM.
* The output is suppressed if DEVNUM indicates that file input is
* in progress.  This is done so character echo, input prompts
* (such as double question mark for more input), etc is ignored
* while inputting file data or loading an ASCII program file.
*
* All registers except CC are preserved.
*

       XDEF   CHROUT
CHROUT JSR    HKCHRO   RAM hook.
       PSHS   B        Save B.
       LDB    DEVNUM   Get the device number.
       CMPB   #-&3     Doing a download?
       BNE    NOTDNL   No.
       PULS   B,PC     Yes, throw away the echo.

NOTDNL INCB            See what it is.
       PULS   B        Restore B.
       LBMI   LPTOUT   Send char to printer.
       BNE    SCROPT   Send char to screen.

       PSHS   X,D      It's the cassette, save some regs.
       LDB    CASOPN   Is the cassette
       DECB            open for input?
       BEQ    OUTRTS   Yes, throw this output away.

*
* Output character to cassette file.
*

CASOUT LDB    CBFCNT   Get the character count.
       INCB            Is the buffer full?
       BNE    NOTFUL   No, go put the char in the buffer.
       BSR    DMPBUF   Yes, write out the buffer.
NOTFUL LDX    CBFPTR   Get pointer into buffer.
       STA    ,X+      Put the char away and increment the
       STX    CBFPTR   pointer.
       INC    CBFCNT   Increment the count.
OUTRTS PULS   D,X,PC   Restore regs and return.

*
* Here to dump the cassette buffer to tape.
*

DMPBUF LDB    #&1      Set block type to data.
WRTEOF STB    BLKTYP
       LDX    #CASBUF  Set address of data for WRTBLK.
       STX    CBUFAD
       LDB    CBFCNT   Set the block length.
       STB    BLKLEN
       PSHS   U,Y,A    Save the rest.
       JSR    WRTBLK   Write block out.
       PULS   A,Y,U    Restore regs.
       JMP    MRKMT    Mark the buffer as empty.

*
* Ouput character to screen.
*

SCROPT EQU    *
       IFNE   REALIO
       JSR    SAMALP   Switch to text mode.
       JMP    SCROUT   Go to the screen driver.
       ENDC   IFN      REALIO

       IFEQ   REALIO
 ENDC    IFE REALIO

       TTL    DEVPRM - Return Device Parameters

*
* DEVPRM returns the following device parameters:
*
* DEVPOS - The position of the print head or it's equivalent.
* DEVWID - The line width of the device.
* DEVLCF - The column number where the last comma field starts.
* DEVCFW - The comma field width.
* SPCIO  - .TRUE. for special I/O handling in PRINT and INPUT code.
*
* All registers except CC are preserved.
* On exit, Z=1 if the device has infinite width (DEVWID=0).
*

       XDEF   DEVPRM
DEVPRM JSR    HKDPRM   RAM hook.
       PSHS   X,D      Save registers.
       CLR    SPCIO    Special I/O flag:=.FALSE.
       LDA    DEVNUM   Get the device number.
       BEQ    SCRPRM   Go get the screen parms.
       INCA
       BEQ    CASPRM   Go get cassette parms.

*
* Get line printer parameters.
*

LPTPRM LDX    LPTCFW   Get comma field width and last comma
*    field.
       LDD    LPTWID   Get width and current position.
       BRA    DEVFIN   Go out it all away.

*
* Get screen parms.
* The width, comma field width, and last comma field are fixed.
* The position is obtained by reading the cursor address.
*

SCRPRM LDB    CURADR+&1 Get low order of cursor address.
       ANDB   #&31     Determine the column number. This
*    only works because the line width
*    is a power of two.
       LDX    #&16*&256+&16 Field width and last comma field.
       LDA    #&32     Set up the width.
       XDEF   DEVFIN
DEVFIN STX    DEVCFW   Put away comma field width and last
*    comma field.
       STB    DEVPOS   Put away the position.
       STA    DEVWID   Put away the width and set the Z bit
*    for infinite width devices.
       PULS   D,X,PC   Restore and return.


*
* Get the cassette parms.
* They are all fixed at values which are necessary for the special
* I/O code to work properly. SPCIO gets set TRUE.
*

CASPRM COM    SPCIO    Special I/O flag:=.TRUE.
       LDX    #&256    Comma field width:=1, last comma
*    field:=0 but don't really care.
       CLRA            Width:=infinite and position:=0.
       CLRB
       BRA    DEVFIN   Go put them away.

       TTL    INLIN - The line input routine.

INLCLS JSR    GRNCHR   Clear the screen and start over.
       XDEF   INLIN
INLIN  JSR    HKINLN   RAM hook.
       CLR    INKCHR   Throw away INKEY's character.
       LDX    #BUF     Point to the start of the line buffer.
       LDB    #&1      Init the character count.
INLINC JSR    INCHR    Read a character.
       TST    EOFFLG   End of file reached?
       BNE    INLDON   Yes, go finish up.
       TST    DEVNUM   Reading from the keyboard?
       BNE    NOEDIT   No, don't check for editing chars.
       CMPA   #@14     CLEAR key?
       BEQ    INLCLS   Yes, clear screen and start over.
       CMPA   #CHRDEL  Character delete?
       BNE    NTCDEL   No.
       DECB            Yes, at beginning of line?
       BEQ    INLIN    Yes, just start over.
       LEAX   -&1,X    Backup the buffer pointer.
       BRA    ECHOIT   Output the CHRDEL to the screen to
*    backup the cursor and go back for
*    another char.

NTCDEL CMPA   #LINDEL  Is it a line delete?
       BNE    NTLDEL   No
RUBLIN DECB            Yes, send CHRDELs to the screen
       BEQ    INLIN    until all characters have been erased.
       LDA    #CHRDEL  Then go start all over.
       JSR    CHROUT
       BRA    RUBLIN

NTLDEL CMPA   #BRKCHR  Break character? (Like control-C)
       SEC             (Set the carry just in case.)
       BEQ    FININL   Yes

NOEDIT CMPA   #CR      Carriage return?
       BNE    NOTCR    No
INLDON CLRA            (Clear carry.)  Clear control-C flag.
FININL PSHS   CC       Save the control-C flag.
       JSR    CRDO     Start a new line.
       CLR    ,X       Put a zero in to mark the end.
       LDX    #BUF-&1  Set up a pointer for CRUNCH.
       PULS   CC,PC    Get the control-C flag and return.

*
* The character is not a special char.  Weed out bad ones and store
* the good ones in the buffer.
*
NOTCR  CMPA   #SPACE   Those below space and above lower
       BCS    INLINC   case z are thrown away.
       CMPA   #'z+&1
       BCC    INLINC
GOODCH CMPB   #BUFLEN  Would this char fill the buffer?
       BCC    INLINC   Yes, ignore it then because one
*    byte must be reserved for the zero
*    terminator inserted when a carriage
*    return is typed.
       STA    ,X+      No, store the character, bump the
       INCB            pointer, and increment the count.
ECHOIT JSR    CHROUT   Echo the char and go back for more.
       BRA    INLINC

       TTL    OPNICK and OPNOCK

*
* Make sure device specified by DEVNUM is open for input.
*

       XDEF   OPNICK
OPNICK JSR    HKCKDI   RAM hook.
       LDA    DEVNUM   Get the device number.
       BEQ    OKOPN    Keyboard is always open.
       INCA            Is is the printer?
       BNE    GOBMER   Yes, give Bad Mode error.
       LDA    CASOPN   Is the cassette open?
       BNE    CHKMOD   Yes, go check the open mode.
       XDEF   NOERR
NOERR  LDB    #ERRNO   No, give Not Open error.
       JMP    ERROR

CHKMOD DECA            Is it open for input?
       BEQ    OKOPN    Yes, OK.
GOBMER JMP    BMERR    No, give Bad Mode error.


*
* Make sure device is open for output.
*

       XDEF   OPNOCK
OPNOCK JSR    HKCKDO   RAM hook.
       LDA    DEVNUM   Get the device number.
       INCA
       BNE    OKOPN    Screen and printer are always open.
       LDA    CASOPN   Is the casette open?
       BEQ    NOERR    No, give Not Open error.
       DECA            Yes, is it open for output?
       BEQ    GOBMER   No, give mode error.
OKOPN  RTS             Yes, all is OK.

