       NAM    IODRVR
       OPT    REL,LLE=120
       TTL    I/O DRIVER EQUATES
*
* I/O DEVICE ADDRESS EQUATES
*
* CONVENTIONS USED:
*
* DDR = DATA DIRECTION REGISTER
* PDR = PERIPHERAL DATA REGISTER
* CR  = CONTROL REGISTER
* A   = A-SIDE OF PIA
* B   = B-SIDE OF PIA
* E.G.  P0CRA = CONTROL REGISTER FOR A-SIDE OF PIA SELECTED BY P0
* PIA ADDRESS EQUATES FOLLOW
       XREF   VFIRQ,VIRQ,VNMI,VSWI,VSWI2,VSWI3,XRSLWC,FCERR
*
* P0 PIA
*
P0DDRA EQU    $FF00
P0PDRA EQU    P0DDRA
P0CRA  EQU    P0DDRA+1
P0DDRB EQU    P0DDRA+2
P0PDRB EQU    P0DDRB
P0CRB  EQU    P0DDRB+1
*
* RS232  6551 CHIP
*
RSTXD  EQU    $FF04
RSRXD  EQU    RSTXD
RSSTAT EQU    $FF05
RSCMD  EQU    $FF06
RSCNT  EQU    $FF07
*
* P1 PIA
*
P1DDRA EQU    $FF20
P1PDRA EQU    P1DDRA
P1CRA  EQU    P1DDRA+1
P1DDRB EQU    P1DDRA+2
P1PDRB EQU    P1DDRB
P1CRB  EQU    P1DDRB+1
*
* SAM CHIP EQUATES
*
SAMCR  EQU    $FFC0    BASE ADDRESS OF SAM CONTROL REGISTER
SAMF1S EQU    $FFC9    F1 SET ADDRESS
SAMMOS EQU    $FFDB    M0 SET ADDRESS
SAMM1S EQU    $FFDD    M1 SET ADDRESS
SAMTYC EQU    $FFDE    MAP TYPE CLEAR ADDRESS
SAMTYS EQU    $FFDF    "   "    SET     "
*
* ADDRESSES OF I/O DRIVER RAMS FOLLOW
*
PWIDTH EQU    $82      PULSE WIDTH COUNTER
BITCNT EQU    $83      BIT COUNTER (SYNC BITS NORMALLY)
BPFLAG EQU    $84      BIT PHASE FLAG
LSTSIN EQU    $85      LAST SINE TABLE ENTRY TO BE OUTPUT
CURADR EQU    $88      CURRENT CURSOR ADDRESS IN 88,89
CBLCNT EQU    $8F      CURRENT CURSOR BLINK COUNT
LDRCNT EQU    $90      COUNT OF NUMBER OF LEADER BYTES
MIN0WD EQU    $92      MINIMUM CYCLE WIDTH OF 1200 HZ (IN PWIDTHS)
MIN0PW EQU    $93      "    PULSE   "   "    "  "   "     "
MAX0PW EQU    $94      MAXIMUM   "     "   "    "      "     "
MODLAY EQU    $95      CASSETTE MOTOR DELAY VALUE
KBDLAY EQU    $97      KEYBOARD DEBOUNCE DELAY VALUE
LPTCFW EQU    $99      LINE PRINTER COMMA FIELD WIDTH
LPTLCF EQU    $9A      "     "    LAST COMMA FIELD
LPTWID EQU    $98      "     "    WIDTH
LPTPOS EQU    $9C      "     "    CURRENT CHARACTER POSITION
LSTKEY EQU    $011D    ASCII OF KEY CURRENTLY PRESSED
CNTDWN EQU    $011E    COUNTDOWN TO KEYBOARD REPEAT
RPTDLY EQU    $011F    INTER-REPEAT INTERRUPT COUNT
AUTOLF EQU    $0148    BUFFER FULL AUTO LINE FEED FLAG
ALLOCK EQU    $0149    ALPHA LOCK FLAG
EOLSEQ EQU    $014A    LINE PRINTER EOL TERMINATOR SEQUENCE
KBROLL EQU    $0151    KEYBOARD ROLLOVER PATTERN TABLE
POTVAL EQU    $015A    START ADDRESS OF JOYSTICK READINGS
LDELAY EQU    $03FD    DELAY AFTER END OF PRINTING LINE
PRNFLG EQU    $03FF    SERIAL OR PARRALLEL PRINT FLAG
*
* CONSTANT VALUES FOLLOW
*
ON     EQU    $FF      ON VALUE
TRUE   EQU    ON       TRUE VALUE
OFF    EQU    $00      OFF VALUE
FALSE  EQU    OFF      FALSE VALUE
* CHARACTER CONSTANTS
SP     EQU    $20      SPACE
CR     EQU    $0D      CARRIAGE RETURN
LF     EQU    $0A      LINE FEED
BS     EQU    $08      BACK SPACE
INVSP  EQU    $60      INVERTED SPACE
SHIFT0 EQU    $12      SHIFTED 0 SPECIAL CASE
*
* MISC CONSTANTS
*
SYNCNT EQU    $60      NUMBER OF BITS TO MAKE UP VALID SYNC DETECT
HOMPOS EQU    $0400    HOME POSITION OF SCREEN VIDEO RAM
EOSPOS EQU    $05FF    END      "    "     "     "    "
BLPOS  EQU    $05E0    START OF LAST LINE ON SCREEN
LWIDTH EQU    $84      LINE WIDTH OF PRINTER
LCFW   EQU    $10      COMMA FIELD WIDTH
LLCF   EQU    LWIDTH-LCFW LAST COMMA FIELD
COLS   EQU    $08      NUMBER OF COLUMNS IN KB MATRIX
MSEC10 EQU    $045E    10 MILLISECOND DELAY VALUE
CBLVAL EQU    $32      CURSOR BLINK RATE CONSTANT
*
* END OF EQUATES
*
* START ADDRESS OF ROUTINES FOLLOWS
*
       TTL    I/O DRIVER SUBROUTINES
* I/O DRIVER SUBROUTINES FOLLOW:
*
* HDRINI - HARDWARE INITIALISATION ROUTINE
*
       RMB    $07      WASTE BYTES TO KEEP ADDRESSING COMPATABLE
       XDEF   OEMMEM
OEMMEM EQU    *
       XDEF   ZHRDIN
ZHRDIN EQU    *
HDRINI LDD    #$0034   A = DD BITS, B = CR BITS
       LDX    #P0DDRA  SET UP BASE ADDRESS OF P0PIA
       STA    1,X      RESET P0CRA
       STA    3,X      AND P0CRB
       STA    0,X      CONFIGURE P0DDRA FOR INPUTS
       COMA            (A) = $FF
       STA    2,X      AND P0DDRB AS OUTPUTS
       STB    1,X      SET UP P0CRA & P0CRB - INTERRUPTS DISABLED
       STB    3,X      -VE EDGE ON CA1/CB1 & CA2/CB2 IN CR3 FOLLOW
       LDX    #P1D0RA  READY TO CONFIGURE P1PIA
       CLR    1,X      RESET P1CRA
       CLR    3,X      AND P1CRB
       DECA            (A) = $FE SETS PA0 AS INPUT, REST OUTPUTS
       STA    0,X      DDRA SETUP
       LDA    #$F8
       STA    2,X      PB0,PB1,PB2 INPUTS, REST OUTPUTS
       STB    1,X      CONFIGURE P1CR'S SAME AS P0CR'S
       STB    3,X
       CLR    0,X      RESET DAC AND PRINTER STROBE
       CLR    2,X      RESET VDG MODE LINES
       LDD    #$0A98
       STD    RSCMD    SET UP CONTROL/COMMAND REG.S
       LDA    RSRXD    CLEAR RECEIVE DATA BUFFER
* NOW INITIALISE THE SAM CHIP
       LDX    #SAMCR   SET UP BASE ADDRESS OF SAM'S CR
       LDB    #16      COUNT OF BITS IN CR OF SAM
SAMCLR STA    0,X++    ACCESS EVERY EVEN ADDRESS
       DECB            CLEARING ALL CR BITS
       BNE    SAMCLR
       STB    SAMF1S   SETS F1 BIT IN SAM CR
       STB    SAMM1S   SELECTS 64K RAM OPTION
       BRA    SAMEND   DON'T INITIALISE 48K SOFTWARE

       XDEF   ENTR48
ENTR48 JMP    BOOT64

SAMEND CLRB
       TFR    B,DP     CLEARS THE DP REG
       TFR    Y,PC     TRANSFER CONTROL TO ADDRESS IN IY
*
* SFTINI - SOFTWARE INITIALISATION ROUTINE
*
       XDEF   ZSFTIN
ZSFTIN EQU    *
SFTINI LDX    #NZDATA  GET READY TO COPY NON-ZERO TABLE ENTRIES
       LDU    #CBLCNT  INTO RAM BLOCK STARTING AT CBLCNT
       LDB    #13      (B) = COUNT OF BYTES TO COPY
       BSR    NZCOPY   INITIATE COPYING
       JSR    SFTIN2   PATCH FOR SERIAL PRINTER
       LDB    #9       AND IS 9 BYTES IN LENGTH
NZCOPY LDA    0,X+     GET TABLE DATA
       STA    0,U+     AND COPY TO RAM AREA
       DECB            UPDATE COUNT
       BNE    NZCOPY   REPEAT UNTIL BLOCK COMPLETE
       RTS
*
* NON-ZERO TABLE ENTRIES FOLLOW
*
NZDATA FCB    CBLVAL   CURSOR BLINK RATE
       FDB    $0100    SYNC BYTE COUNT
       FCB    $12      MIN 1200HZ CYCLE WIDTH
       FCB    $0A      "    "    PULSE   "   (HALF CYCLE)
       FCB    $12      MAX   "      "     "     "      "
       FDB    MSEC10*50 MOTOR DELAY VALUE - HALF SECOND
       FDB    MSEC10   KEYBOARD DEBOUNCE DELAY VALUE
       FCB    LCFW     LP COMMA FIELD WIDTH
       FCB    LLCF     LP LAST COMMA FIELD
       FCB    LWIDTH   LP WIDTH
* FINAL BLOCK ENTRIES
       FCB    ON       LP BUFFER FULL AUTO LF FLAG
       FCB    ON       ALPHA LOCK FLAG
       FCB    1        CHARACTER COUNT IN LP TERMINATOR SEQUENCE
       FCB    CR       CARRIAGE RETURN FOLLOWED
       FCB    LF       BY LINE FEED SEQUENCE (IF REQUIRED)
       BSZ    4        REMAINDER OF SEQUENCE IS FREE
* END OF NZDATA
*
* CBLINK - CURSOR BLINK ROUTINE
*
       XDEF   ZCBLIN
ZCBLIN EQU    *
CBLINK DEC    CBLCNT   UPDATE BLINK RATE COUNTER
       BNE    BLDLAY   IF .NE. 0 THEN DELAY 10 MSECS
       LDA    #CBLVAL  OTHERWISE RESET TO INITIAL VALUE
       STA    CBLCNT   FOR BLINK RATE
       LDX    CURADR   GET READY TO FLASH CURSOR
       LDA    0,X      BY READING CHAR AT CURSOR POS
       EORA   #$40     AND INVERTING
       STA    0,X      BEFORE WRITING BACK
BLDLAY LDX    #MSEC10  SET UP 10 MSEC DELAY CONSTANT
*
* IXDLAY - DELAY ROUTINE
*
IXDLAY LEAX   -1,X     DECREMENT IX
       BNE    IXDLAY   REPEAT UNTIL (IX) = 0
       RTS
*
* ROUTINES USED BY THEKEYBOARD POLLER FOLLOW
*
* CHKROW - CHECKS ROWS OF K/B MATRIX FOR CLOSURE
*
CHKROW LDB    P0PDRA   READ ROW DATA
       ORB    #$80     SET UNUSED BIT
       TST    P0PDRB   SHIFT KEY IS
       BMI    NOSHFT   IS MASKED OUT
       ORB    #$40     BY THIS
NOSHFT RTS
*
* CSHIFT - CHECKS THE STATE OH THE SHIFT KEY, Z = 1 IF PRESSED
*
CSHIFT LDB    #$7F     CLEAR TOP BIT
       STB    P0PDRB   OF THE COLUMNS
       LDB    P0PDRA   THEN READ ROWS
       ANDB   #$40     MASK OFF ALL BUT SHIFT KEY
       RTS
*
* POLCAT - POLL THE K/B AND RETURN CHARACTER IN (A)
*
       XDEF   ZPOLCA
ZPOLCA EQU    *
POLCAT PSHS   B,X      SAVE REGS
       BSR    POLLKB   POLL AND ENCODE KEYS
       JMP    KEYINT   INITILISE REPEAT COUNTDOWN
*
* POLLKB - POLLS THE K/B, DETECTS KEY CLOSURES, DEBOUNCES KEYS, PERFORMS
* ROLLOVER AND ENCODES CHARACTERS
*
POLLKB LEAS   -2,S     RESERVE 2 BYTES OF WORKSPACE ON STACK
       LDX    #KBROLL  SET UP ADDRESS OF KB ROLLOVER TABLE
* THE FIRST THING TO DO IS TO CHECK FOR ANY KEY CLOSURES WHATSOEVER
       CLR    P0PDRB   FORCE 0'S TO ALL COLUMNS
       LDB    P0PDRA   READ ROW STATUS
       ORB    #$80     SET UNUSED BIT
       CMPB   0,X      CHECK FOR ANY KEYBOARD ACTIVITY
       BEQ    NONKEY   IF THE SAME THEN NO CHANGE
* SOME CHANGE HAS BEEN DETECTED AT THIS POINT SO NEXT THING TO DO
* IS TO MAKE SURE THAT IT WASN'T THE JOYSTICK BUTTONS.
       TFR    B,A      SAVE ROW STATUS
       COM    P0PDRB   FORCE 1'S TO COLUMNS
       BSR    CHKROW   CHECK FOR JOYSTICK BUTTONS
       CMPB   #$FF     AS 0'S ON THE PA0 OR PA1
       BNE    NONKEY   MEAN BUTTONS ARE DOWN
       STA    0,X+     SAVE FULL ROW STATE IN ROLLOVER TABLE
* AT THIS POINT A CHANGE IN THE STATE OF THE ROWS HAS BEEN DETECTED
* SO THE FOLLOWING CODE IS USED TO DETECT WHICH KEY IT WAS
       CLR    0,S      RESET COLUMN COUNT
       LDB    #$FE     SET UP 0 IN LS BIT
       STB    P0PDRB   AND SEND OUT TO MATRIX COLUMNS
SCANKB BSR    CHKROW   CHECK ROW CLOSURES
       STB    1,S      SAVE ROW STATE AWAY
       EORB   0,X      PERFORM KEY CLOSURE AND ROLLOVER DETECTION
       ANDB   0,X      BIT SET IN B IF IT DIFFERED FROM LAST TIME
       LDA    1,S      RESTORE ROW STATE AND
       STA    0,X+     SAVE IN ROLLOVER TABLE FOR NEXT TIME
       TSTB            ANY CHANGES TO KEYS?
       BNE    DEBKEY   YES, DEBOUNCE BEFORE ENCODING
       INC    0,S      ELSE UPDATE COLUMN COUNT
       COMA            USED TO SET CARRY BIT
       ROL    P0PDRB   BEFORE SHIFTING 0 T0 NEXT COLUMN
       BCS    SCANKB   REPEAT UNTIL ALL DONE OR CLOSURE FOUND
       BRA    NONKEY   MUST HAVE BEEN NO KEYS FOUND
* KEY FOUND - DEBOUNCE IT
DEBKEY LDX    KBDLAY   WAIT DEBOUNCE PERIOD
       BSR    IXDLAY   BEFORE RE-CHECKING KB
       EXG    A,B      COPY ORIGINAL KEY CLOSURE
       BSR    CHKROW   AND GET NEW STATE
       CMPB   1,S      AND COMPARE WITH ORIGINAL
       EXG    A,B      RESTORE KEY CLOSURE
       BNE    NONKEY   IF NO MATCH NO KEY RETURNED
* MUST BE A VALID KEY AT THIS POINT SO ENCODE IT
       LDA    0,S      PICK UP COLUMN COUNT
       SUBA   #COLS    OFFSET IT
NXTROW ADDA   #COLS    CALCULATE KEY POSITION AS FOLLOWS
       LSRB            KEY POS = (ROWPPOS)*(COLS) + (COL POS)
       BCC    NXTROW   ROW POS = BIT SET IN (B)
       TSTA            KEY POS = 0 IS A
       BEQ    KEY0     SPECIAL CASE
       CMPA   #$0C     CHECK NUMERIC KEY RANGE
       BLO    NUMKEY   WHICH IS $00 — $0B
       CMPA   #$11     CHECK SPECIAL CASE RANGE
       BLO    SPEC1    WHICH IS $0C — $10
       CMPA   #$2A     AND FINALLY CHECK RANGE
       BHI    SPEC2    $2B ONWARDS SPECIAL CASE
* MUST BE ALPHABETIC CHARACTER IF HERE
       ADDA   #$30     ADD OFFSET FOR ASCII UPPER CASE
       BSR    CSHIFT   AND CHECK WHETHER TO SHIFT
       BEQ    CODED    IF SHIFT THEN UPPER CASE REMAINS
* COULD BE LOWER CASE AT THIS POINT SO CHECK ALPHA LOCK
       TST    ALLOCK
       BNE    CODED    IF ON THEN UPPER CASE OK
       ORA    #$20     ELSE CONVERT TO LOWER CASE
       BRA    CODED    BEFORE EXIT
* NUMERIC (+ OTHERS) ENCODED HERE
NUMKEY ADDA   #$30     CONVERT TO ASCII
       LBSR   CSHIFT   CHECK SHIFT KEY
       BNE    CODED    UNSHIFTED — NO CHANGE
       SUBA   #$10     ELSE CONVERT TO UPPER SET
CODED  CMPA   #SHIFT0  CHECK FOR ALPHA LOCK TOGGLE
       BNE    POLEND
       COM    ALLOCK   TOGGLE IF FOUND
NONKEY CLRA            NO KEY CLOSURE EXIT CONDITION
POLEND PULS   X,PC     TIDY UP WORKSPACE AND RETURN
* SPECIAL CASES FOLLOW
SPEC2  SUBA   #26      MAKE SPECIAL CASES CONTIGUOUS
SPEC1  SUBA   #11      AND OFFSET IN RANGE 1 —>
KEY0   ASLA            2 ENTRIES/KEY
       LBSR   CSHIFT   CHECK FOR SHIFTED SET
       BNE    LOOKUP
       INCA            SHIFTED SET ENTRY OFFSET
LOOKUP LDX    #KEYTAB  SET UP LOOKUP TABLE BASE
       LDA    A,X      LOOKUP KEY ENTRY
       BRA    CODED    AND RETURN IT
* KEY CODE LOOKUP TABLE FOLLOWS
* SECOND ENTRY OF EACH IS THE SHIFTED KEY
KEYTAB FCB    '0,SHIFT0
       FCB    ',,'<
       FCB    '-,'=
       FCB    '.,'>
       FCB    '/,'?
       FCB    '@,$13
       FCB    $5E,$5F  UP ARROW
       FCB    LF,$5B   DOWN ARROW
       FCB    BS,$15   LEFT ARROW
       FCB    $09,$5D  RIGHT ARROW
       FCB    SP,SP    SPACE
       FCB    CR,CR    ENTER
       FCB    $0C,$5C  CLEAR
       FCB    $03,$03  BREAK
*
* SCREEN OUTPUT ROUTINES FOLLOW
*
* CLREOL - CLEARS THE SCREEN TO THE END OF THE CURRENT LINE
*
CLREOL LDA    #INVSP   FILL REST OF THE LINE
       STA    0,X+     SPACES WRITTEN TO VRAM
       TFR    X,D      NOW CHECK FOR EOL
       ANDB   #$1F     BY ANDING WITH LINE LENGTH
       BNE    CLREOL   REPEATS UNTIL COL 32
       RTS
*
* SCROUT - OUTPUTS A CHARACTER TO THE SCREEN
*
       XDEF   ZSCROU
ZSCROU EQU    *
SCROUT PSHS   A,B,X    SAVE REGS
       LDX    CURADR   FETCH CURSOR POSITION
       CMPA   #BS      CHECK FIRST FOR BACK SPACE
       BNE    CHKCR
* BACK SPACE TO BE OUTPUT
       CMPX   #HOMPOS  CAN'T BACK UP WHEN HOMED
       BEQ    SCEXIT   SO EXIT
       LDA    #INVSP   PREPARE TO DELETE CURRENT
       STA    0,-X     CHARACTER AND MOVE LEFT
       BRA    NXTPOS   THEN UPDATE SCREEN POS
CHKCR  CMPA   #CR      NOW CHECK FOR ENTER
       BNE    CHKCNT
       BSR    CLREOL   CLEAR TO EOL IF IT IS
       BRA    NXTPOS
* CHECK FOR CONTROL CHARACTERS NOW
CHKCNT CMPA   #SP      NON-PRINTING CHARACTER
       BLO    SCEXIT   YES, THEN EXIT
       TSTA            ELSE CHECK FOR GRAPHIC (MS BIT SET)
       BMI    OUTCHR   OUTPUT AS IS IF FOUND
       CMPA   #$40     NON-ALPHA CHECK
       BLO    CONVCH
       CMPA   #$60     LOWER CASE ALPHAS
       BLO    OUTCHR   OUTPUT AS IS IF NOT
       ANDA   #$DF     LCASE SO MASK OFF D6
CONVCH EORA   #$40     INVERT CHARACTER
OUTCHR STA    0,X+     UPDATE VRAM AT CURSOR
NXTPOS STX    CURADR   UPDATE CURSOR POSITION
       CMPX   #EOSPOS  REACHED END OF SCREEN?
       BLS    SCEXIT   NO, SO EXIT OK
       LDX    #HOMPOS  YES, THEN SCROLL UP BY
SCROLL LDD    $20,X    COPYING EACH LINE TO
       STD    0,X++    THE ONE ABOVE
       CMPX   #BLPOS   UNTIL LAST LINE DONE
       BLO    SCROLL
* NOW AT START OF THE BOTTOM LINE.
       STX    CURADR   SAVE NEW CURSOR POSITION
       BSR    CLREOL   BEFORE CLEARING BOTTOM LINE
SCEXIT PULS   A,B,X,PC RESTORE AND RETURN
*
* LINE PRINTER ROUTINES FOLLOW
*
* TXLPCH - TRANSMITS A CHARACTER TO THE LINE PRINTER
*
TXLPCH PSHS   B        SAVE REG
       TST    PRNFLG   TEST PRINTER TYPE
       JMP    PRNSEL   GO FIND OUT WHICH
LPROUT STA    P0PDRB   SEND CHARACTER OUT
       LDB    #2       SET UP STROBE BIT
       STB    P1PDRA   SEND STROBE, PULSE HI
       CLR    P1PDRA   THEN PULSE LO
* N.B. THE STROBE PULSE IS INVERTED BY THE LS02 SO
* ACTUAL STROBE TO PRINTER IS LO FOLLOWED BY HI
       PULS   B,PC     RESTORE AND RETURN
*
* TXEOL - TRANSMITS THE END OF LINE TERMINATING SEQUENCE
*
TXEOL  LDX    #EOLSEQ  SET UP EOL SEQUENCE ADDRESS
       LDB    0,X+     GET COUNT OF CHARACTERS IN IT
TXSEQ  TSTB            COUNT = 0 ?
       BEQ    ENDSEQ   YES, SO FINISH
       LDA    0,X+     PICK UP NEXT CHARACTER
       BSR    TXLPCH   TRANSMIT IT
       JMP    EOLDLY   DO WE HAVE AN EOL DELAY
ENDSEQ RTS
*
* LPTOUT - OUTPUT A CHARCTER TO PRINTER INTERFACE
*
       XDEF   ZLPTOU
ZLPTOU EQU    *
LPTOUT PSHS   A,B,X    SAVE REGS
* DISABLE INTERRUPTS AT THIS POINT?
       CMPA   #CR      CR?
       BEQ    LPTEOL   YES, DEAL WITH EOL
       CMPA   #SP      PRINTABLE?
       BLO    SENDCH   NO, SO SKIP POS UPDATE
       INC    LPTPOS   YES, UPDATE PRINT POS
SENDCH BSR    TXLPCH   AND SEND CHARACTER
       LDB    LPTPOS   CHECK PRINT POS
       CMPB   LPTWID   BUFFER FULL?
       BLO    LPEXIT   NO, SO OK TO EXIT
       TST    AUTOLF   AUTO LINEFEED?
       BNE    NXTLN    YES, NO ACTION NEEDED
* END OF LINE REACHED, CR OR NO AUTO LF ON BUFFER FULL
LPTEOL TST    LPTPOS   EMPTY BUFFER?
       BNE    NEWLN    NO, SO FLUSH BUFFER
       LDA    #SP      YES, SEND OUT A SPACE
       BSR    TXLPCH   BEFORE
NEWLN  BSR    TXEOL    SENDING EOL SEQUENCE
NXTLN  CLR    LPTPOS   RESET PRINTER POSITION
LPEXIT PULS   A,B,X,PC RESTORE AND RETURN
*
* JOYSTICK ROUTINE NEXT
*
* JOYSEL - SELECT ONE THE JOYSTICK CHANNELS (0-3)
*
JOYSEL LDU    #P0CRA   FIRST TIME THRU SETS UP
       BSR    NEWCR3   LSB OF MUX, SELECT CA2
NEWCR3 LDA    0,U      READ CURRENT CR VALUE
       ANDA   #$F7     RESET CR3
       RORB            MOVE LS BIT INTO CARRY
       BCC    CR3WRT
CR3SET ORA    #8       SETS CR3 IF LS BIT OF (B) SET
CR3WRT STA    0,U++    COPY NEW CR3 BACK & SET UP
       RTS             CRB FOR SECOND TIME THRU
*
* JOYIN - READS THE JOYSTICK CHANNELS
*
       XDEF   ZJOYIN
ZJOYIN EQU    *
JOYIN  LEAS   -3,S     RESERVE 3 BYTES OF STACK WORKSPACE
       LDX    #POTVAL+4 USES AUTO-DEC SO ADDRESS 1 PAST END
       LDB    #3       STARTS OFF WITH JOYSTICK(3)
NXTJOY LDA    #10      NUMBER OF TRIES ON UNEQUAL READINGS
       STD    1,S      SAVE JOYSTICK NO. AND RETRY VALUE
       BSR    JOYSEL   SELECT JOYSTICK(B)
RETRY  LDD    #$4080   1/4 FSD IN (A), 1/2 FSD IN (B)
NXTTRY STA    0,S      SCALE INCREMENT STORED AWAY
       STB    P1PDRA   SEND APPROX. TO DAC
       TST    P0PDRA   CHECK COMPARATOR RESULT
       BMI    CMPLOW   BY TESTING PA7 BIT
* PA7 = 0 SO APPROX. > JOYSTICK VALUE SO SUBTRACT INCREMENT
       SUBB   0,S
       BRA    OVER
* PA7 = 1 SO APPROX. < JOYSTICK VALUE SO ADD INCREMENT
CMPLOW ADDB   0,S
OVER   LSRA            NEW INCREMENT = 1/2 OLD
       CMPA   #1       ALL 6 BITS DONE?
       BNE    NXTTRY   NO, TRY NEXT APPROX.
       LSRB            NORMALISE
       LSRB            FINAL RESULT
       CMPB   -1,X     SAME AS LAST READING?
       BEQ    GOTJOY   YES, SO FINISH
       DEC    1,S      NO, SO RETRY
       BNE    RETRY    A NUMBER OF TIMES
GOTJOY STB    0,-X     LAST READING UPDATES POTVALS
       LDB    2,S      RESTORE JOYSTICK NO.
       DECB            GET NEXT ONE
       BPL    NXTJOY   FINISH AFTER JOYSTICK(0)
       PULS   A,X,PC   TIDY UP STACK AND RETURN
*
* CASSETTE ROUTINES FOLLOW
*
* CLEVEL - READ THE INPUT LEVEL AT THE CASSETTE INPUT PIN
*
CLEVEL INC    PWIDTH   UPDATE PULSE WIDTH COUNTER
       LDB    P1PDRA   READ CASSETTE INPUT LEVEL
       RORB            WHICH IS RETURNED IN CARRY
       RTS
*
* BCYCLE - CALCULATES THE BIT CYCLE WIDTH
*
BCYCLE CLR    PWIDTH   RESET WIDTH COUNT - USED FOR CYCLE WIDTH
       TST    BPFLAG   CHECK SIGNAL PHASE
       BNE    FALLER
* THE FIRST 1/2 OF CYCLE STARTS WITH A HI PULSE
RISER  BSR    HANGHI   START SAMPLING  IN HI PHASE
HANGLO BSR    CLEVEL   STOP SAMPLING WHEN
       BCC    HANGLO   RISING EDGE DETECTED
       RTS
* THE FIRST 1/2 OF CYCLE STARTS WITH A LO PULSE
FALLER BSR    HANGLO   START SAMPLING IN LO PULSE
HANGHI BSR    CLEVEL   STOP SAMPLING WHEN
       BCS    HANGHI   FALLING EDGE DETECTED
       RTS
*
* BITIN - RECOVERS BIT FROM CASSETTE, RETURNED IN CARRY
*
       XDEF   ZBITIN
ZBITIN EQU    *
BITIN  BSR    BCYCLE   GET BIT CYCLE WIDTH
       LDB    PWIDTH   PULSE WITDTH = CYCLE WIDTH
       DECB            WILL BE 1 TOO MANY
       CMPB   MIN0WD   C SET IF (B) < MIN0WD = 1
       RTS             C CLEAR IF (B) > MIN0WD = 0
*
* CBIN - RECOVERS A BYTE FROM CASSETTE
*
       XDEF   ZCBIN
ZCBIN  EQU    *
CBIN   LDA    #8       SET UP COUNT OF BITS
       STA    BITCNT   TO BE RECOVERED
NXTBIT BSR    BITIN    READ INDIVIDUAL BITS
       RORA            AND SHIFT INTO (A) - LS BIT FIRST
       DEC    BITCNT   REPEAT UNTIL ALL
       BNE    NXTBIT   BITS READ IN
       RTS
*
* TIMEHI - COMPARES THE WIDTH OF HI PULSE AGAINST REFERENCE
*
TIMEHI CLR    PWIDTH   RESET COUNTER
       BSR    HANGHI   PWIDTH = TIME SPENT HI
       BRA    TESTPW   COMPARE WITH REFERENCE TIME
*
* TIMELO - SAME AS TIMEHI EXCEPT DEALING WITH A LO PULSE
*
TIMELO CLR    PWIDTH
       BSR    HANGLO
TESTPW LDB    PWIDTH   GET RESULT
       CMPB   MAX0PW   VALID PULSE WIDTH?
       BHI    PWERR
       CMPB   MIN0PW   YES, RETURN HI OR LO RESULT
       RTS
PWERR  CLR    BITCNT   NO, RESET SYNC BIT COUNTER
       RTS
*
* CASON - TURNS THE CASSETTE MOTOR ON
*
       XDEF   ZCASON
ZCASON EQU    *
CASON  LDA    P1CRA    READ CURRENT CR
       ORA    #8       SET CR3 BIT
       STA    P1CRA    WRITE BACK, SETTING CA2 HI
       LDX    MODLAY   NOW WAIT FOR MOTOR
       LBRA   IXDLAY   TO COME UP TO SPEED
*
* CASOFF - TURNS THE CASSETTE MOTOR OFF
*
       XDEF   ZCASOF
ZCASOF EOU    *
CASOFF LDA    P1CRA
       ANDA   #$F7     RESET CR3 THUS
       STA    P1CRA    TURNING MOTOR OFF
       ANDCC  #$AF     RE-ENABLE F & I INTERRUPTS
       RTS
*
* CSRDON - TURN CASSETTE ON AND GET INTO BIT SYNC
*
       XDEF   ZCSRDO
ZCSRDO EQU    *
CSRDON ORCC   #$50     DISABLE F & I INTERRUPTS FOR BIT BANGING
       BSR    CASON    TURN MOTOR ON
       CLR    BITCNT   RESET SYNC BIT COUNT
SYNCER BSR    RISER    WAIT FOR A RISING EDGE
CHK0HI BSR    TIMEHI   TIME PULSE WIDTH OF HI SIGNAL
       BHI    CHK0LO   1200 HZ PULSE?
CHK1LO BSR    TIMELO   NO, TIME PULSE WIDTH OF LO
       BLO    CHK1HI   2400 HZ PULSE?
       INC    BITCNT   NO, SO HI OF 2400 HZ FOLLOWED
       LDA    BITCNT   BY LO OF 1200 HZ, I.E 1 -> 0
       CMPA   #SYNCNT  NOW IN 2ND 1/2 OF BIT WHICH IS HI
       BRA    CHKSYN   GOT ENOUGH BITS FOR SYNC CONDITION?
CHK0LO BSR    TIMELO   LAST PULSE WAS 1200 HZ
       BHI    CHK0HI   IS THIS LO OF 1200 HZ?
CHK1HI BSR    TIMEHI   NO, SO TIME PULSE WIDTH OF HI
       BLO    CHK1LO   2400 HZ?
       DEC    BITCNT   NO, SO LO OF 2400 HZ FOLLOWED
       LDA    BITCNT   BY HI OF 1200 HZ, I.E. 1 -> 0
       ADDA   #SYNCNT  NOW IN 2ND 1/2 OF BIT WHICH IS LO
CHKSYN BNE    SYNCER   REPEAT UNTIL ENOUGH BITS FOR SYNC
* BPFLAG = 0 IF SAMPLING LO, NON-0 IF SAMPLING HI
       STA    BPFLAG
       RTS
*
* CBOUT - OUTPUTS A BYTE TO THE CASSETTE
*
       XDEF   ZCBOUT
ZCBOUT EQU    *
CBOUT  PSHS   A        SAVE BYTE VALUE
       LDB    #1       SET UP INITIAL BIT POSITION VALUE
NEWBIT LDY    #SINTAB  SET UP START OF SINE LOOKUP TABLE
       LDA    LSTSIN   PICK UP LAST ENTRY
       STA    P1PDRA   AND SEND TO DAC
       BITB   0,S      IS BIT TO BE OUTPUT SET?
       BNE    HZ2400   YES, GENERATE 2400 HZ WAVEFORM
* GENERATING A 1200 HZ WAVEFORM AT THIS POINT
HZ1200 LDA    0,Y+     PICK UP TABLE ENTRY
       CMPY   #WRTLDR  END OF TABLE REACHED?
       BHS    BITEND   YES, THEN DON'T OUTPUT LAST ENTRY
       STA    P1PDRA   NO, SEND TO DAC AND
       BRA    HZ1200   GET NEXT SINE VALUE
HZ2400 LDA    0,Y++    SAME AS 1200 HZ WAVEFORM EXCEPT
       CMPY   #WRTLDR  THAT ONLY EVERY 2ND ENTRY ACCESSED
       BHS    BITEND   THEREBY DOUBLING THE FREQUENCY
       STA    P1PDRA   TO 2400 HZ
       BRA    HZ2400
* LAST TABLE ENTRY NOT YET OUTPUT TO AVOID INTER—BIT DISCONTINUITY
BITEND STA    LSTSIN   SAVE LAST ENTRY FOR LATER USE
       ASLB            SHIFT TO NEXT BIT POSITION
       BCC    NEWBIT   UNTIL ALL 8 BITS DEALT WITH
       PULS   A,PC     RESTORE AND RETURN
*
* SINTAB — CONTAINS ENTRIES USED TO GENERATE SINE WAVE FORMS VIA DAC
* N.B. THE FIRST ENTRY IS OFFSET TO ALLOW FOR INTER—BYTE DISCONTINUITY
*
SINTAB FCB    $80,$90,$A8,$B8,$C8,$D8,$E8,$F0,$F8
       FCB    $F8,$F8,$F0,$E8,$D8,$C8,$B8,$A8,$90
       FCB    $78,$68,$50,$40,$30,$20,$10,$08,$00
       FCB    $00,$00,$08,$10,$20,$30,$40,$50,$68
*
* WRTLDR — OUTPUTS A BIT SYNC LEADER OF $55'S (ALTERNATING 0'S & 1'S)
*
       XDEF   ZWRTLD
ZWRTLD EQU    *
WRTLDR PSHS   B,Y      SAVE REGS
       ORCC   #$50     DISABLE F & I INTERRUPTS
       LBSR   CASON    TURN CASSETTE DRIVE ON
       LDA    #$55     SYNC BYTE VALUE
       LDX    LDRCNT   NUMBER OF BYTES IN LEADER
NXTLDR BSR    CBOUT    RECORD SYNC BYTE
       LEAX   -1,X     UNTIL (IX) BYTES DONE
       BNE    NXTLDR
       PULS   B,Y,PC   RESTORE AND RETURN
*
*      DOWNLOADER I/O ROUTINES
*
       XDEF   ZINHST
ZINHST PSHS   B,CC     PRESERVE REGISTERS
       ORCC   #$50
       LDA    #$08     MASK FOR DATA RECEIVED
       LDB    RSCMD
       ORB    #$01     SET DATA TERMINAL
       STB    RSCMD    ....READY
       ANDB   #$FE     WE'LL FINISH AGAIN SOON
RSRXWT BITA   RSSTAT   ANY DATA CAPTURED ?
       BEQ    RSRXWT
       STB    RSCMD    ....NOT READY
       LDA    RSRXD    READ IN THE INPUT
       PULS   B,CC,PC  RESTORE AND RETURN
*
       XDEF   ZOUTHS
ZOUTHS PSHS   B,CC     SAVE REGISTERS
       LDB    #$10     MASK FOR TRANSMIT BUFFER
RSTXWT BITB   RSSTAT   EMPTY ?
       BEQ    RSTXWT
       STA    RSTXD    PUT OUT THE BYTE
       PULS   B,CC,PC  RESTORE AND RETURN
*
       XDEF   ZSTBAU
ZSTBAU CMPB   #(RSTEND—RSTAB)
       BHS    RSERR    OUT OF RAN6E
