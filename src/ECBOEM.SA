       NAM    IODRVR
       OPT    REL,LLE=120
       TTL    I/O DRIVER EQUATES
*
* I/O DEVICE ADDRESS EQUATES
*
* CONVENTIONS USED:
*
* DDR = DATA DIRECTION REGISTER
* PDR = PERIPHERAL DATA REGISTER
* CR  = CONTROL REGISTER
* A   = A-SIDE OF PIA
* B   = B-SIDE OF PIA
* E.G.  P0CRA = CONTROL REGISTER FOR A-SIDE OF PIA SELECTED BY P0
* PIA ADDRESS EQUATES FOLLOW
       XREF   VFIRQ,VIRQ,VNMI,VSWI,VSWI2,VSWI3,XRSLWC,FCERR
*
* P0 PIA
*
P0DDRA EQU    $FF00
P0PDRA EQU    P0DDRA
P0CRA  EQU    P0DDRA+1
P0DDRB EQU    P0DDRA+2
P0PDRB EQU    P0DDRB
P0CRB  EQU    P0DDRB+1
*
* RS232  6551 CHIP
*
RSTXD  EQU    $FF04
RSRXD  EQU    RSTXD
RSSTAT EQU    $FF05
RSCMD  EQU    $FF06
RSCNT  EQU    $FF07
*
* P1 PIA
*
P1DDRA EQU    $FF20
P1PDRA EQU    P1DDRA
P1CRA  EQU    P1DDRA+1
P1DDRB EQU    P1DDRA+2
P1PDRB EQU    P1DDRB
P1CRB  EQU    P1DDRB+1
*
* SAM CHIP EQUATES
*
SAMCR  EQU    $FFC0    BASE ADDRESS OF SAM CONTROL REGISTER
SAMF1S EQU    $FFC9    F1 SET ADDRESS
SAMMOS EQU    $FFDB    M0 SET ADDRESS
SAMM1S EQU    $FFDD    M1 SET ADDRESS
SAMTYC EQU    $FFDE    MAP TYPE CLEAR ADDRESS
SAMTYS EQU    $FFDF    "   "    SET     "
*
* ADDRESSES OF I/O DRIVER RAMS FOLLOW
*
PWIDTH EQU    $82      PULSE WIDTH COUNTER
BITCNT EQU    $83      BIT COUNTER (SYNC BITS NORMALLY)
BPFLAG EQU    $84      BIT PHASE FLAG
LSTSIN EQU    $85      LAST SINE TABLE ENTRY TO BE OUTPUT
CURADR EQU    $88      CURRENT CURSOR ADDRESS IN 88,89
CBLCNT EQU    $8F      CURRENT CURSOR BLINK COUNT
LDRCNT EQU    $90      COUNT OF NUMBER OF LEADER BYTES
MIN0WD EQU    $92      MINIMUM CYCLE WIDTH OF 1200 HZ (IN PWIDTHS)
MIN0PW EQU    $93      "    PULSE   "   "    "  "   "     "
MAX0PW EQU    $94      MAXIMUM   "     "   "    "      "     "
MODLAY EQU    $95      CASSETTE MOTOR DELAY VALUE
KBDLAY EQU    $97      KEYBOARD DEBOUNCE DELAY VALUE
LPTCFW EQU    $99      LINE PRINTER COMMA FIELD WIDTH
LPTLCF EQU    $9A      "     "    LAST COMMA FIELD
LPTWID EQU    $98      "     "    WIDTH
LPTPOS EQU    $9C      "     "    CURRENT CHARACTER POSITION
LSTKEY EQU    $011D    ASCII OF KEY CURRENTLY PRESSED
CNTDWN EQU    $011E    COUNTDOWN TO KEYBOARD REPEAT
RPTDLY EQU    $011F    INTER-REPEAT INTERRUPT COUNT
AUTOLF EQU    $0148    BUFFER FULL AUTO LINE FEED FLAG
ALLOCK EQU    $0149    ALPHA LOCK FLAG
EOLSEQ EQU    $014A    LINE PRINTER EOL TERMINATOR SEQUENCE
KBROLL EQU    $0151    KEYBOARD ROLLOVER PATTERN TABLE
POTVAL EQU    $015A    START ADDRESS OF JOYSTICK READINGS
LDELAY EQU    $03FD    DELAY AFTER END OF PRINTING LINE
PRNFLG EQU    $03FF    SERIAL OR PARRALLEL PRINT FLAG
*
* CONSTANT VALUES FOLLOW
*
ON     EQU    $FF      ON VALUE
TRUE   EQU    ON       TRUE VALUE
OFF    EQU    $00      OFF VALUE
FALSE  EQU    OFF      FALSE VALUE
* CHARACTER CONSTANTS
SP     EQU    $20      SPACE
CR     EQU    $0D      CARRIAGE RETURN
LF     EQU    $0A      LINE FEED
BS     EQU    $08      BACK SPACE
INVSP  EQU    $60      INVERTED SPACE
SHIFT0 EQU    $12      SHIFTED 0 SPECIAL CASE
*
* MISC CONSTANTS
*
SYNCNT EQU    $60      NUMBER OF BITS TO MAKE UP VALID SYNC DETECT
HOMPOS EQU    $0400    HOME POSITION OF SCREEN VIDEO RAM
EOSPOS EQU    $05FF    END      "    "     "     "    "
BLPOS  EQU    $05E0    START OF LAST LINE ON SCREEN
LWIDTH EQU    $84      LINE WIDTH OF PRINTER
LCFW   EQU    $10      COMMA FIELD WIDTH
LLCF   EQU    LWIDTH-LCFW LAST COMMA FIELD
COLS   EQU    $08      NUMBER OF COLUMNS IN KB MATRIX
MSEC10 EQU    $045E    10 MILLISECOND DELAY VALUE
CBLVAL EQU    $32      CURSOR BLINK RATE CONSTANT
*
* END OF EQUATES
*
* START ADDRESS OF ROUTINES FOLLOWS
*
       TTL    I/O DRIVER SUBROUTINES
* I/O DRIVER SUBROUTINES FOLLOW:
*
* HDRINI - HARDWARE INITIALISATION ROUTINE
*
       RMB    $07      WASTE BYTES TO KEEP ADDRESSING COMPATABLE
       XDEF   OEMMEM
OEMMEM EQU    *
       XDEF   ZHRDIN
ZHRDIN EQU    *
HDRINI LDD    #$0034   A = DD BITS, B = CR BITS
       LDX    #P0DDRA  SET UP BASE ADDRESS OF P0PIA
       STA    1,X      RESET P0CRA
       STA    3,X      AND P0CRB
       STA    0,X      CONFIGURE P0DDRA FOR INPUTS
       COMA            (A) = $FF
       STA    2,X      AND P0DDRB AS OUTPUTS
       STB    1,X      SET UP P0CRA & P0CRB - INTERRUPTS DISABLED
       STB    3,X      -VE EDGE ON CA1/CB1 & CA2/CB2 IN CR3 FOLLOW
       LDX    #P1D0RA  READY TO CONFIGURE P1PIA
       CLR    1,X      RESET P1CRA
       CLR    3,X      AND P1CRB
       DECA            (A) = $FE SETS PA0 AS INPUT, REST OUTPUTS
       STA    0,X      DDRA SETUP
       LDA    #$F8
       STA    2,X      PB0,PB1,PB2 INPUTS, REST OUTPUTS
       STB    1,X      CONFIGURE P1CR'S SAME AS P0CR'S
       STB    3,X
       CLR    0,X      RESET DAC AND PRINTER STROBE
       CLR    2,X      RESET VDG MODE LINES
       LDD    #$0A98
       STD    RSCMD    SET UP CONTROL/COMMAND REG.S
       LDA    RSRXD    CLEAR RECEIVE DATA BUFFER
* NOW INITIALISE THE SAM CHIP
       LDX    #SAMCR   SET UP BASE ADDRESS OF SAM'S CR
       LDB    #16      COUNT OF BITS IN CR OF SAM
SAMCLR STA    0,X++    ACCESS EVERY EVEN ADDRESS
       DECB            CLEARING ALL CR BITS
       BNE    SAMCLR
       STB    SAMF1S   SETS F1 BIT IN SAM CR
       STB    SAMM1S   SELECTS 64K RAM OPTION
       BRA    SAMEND   DON'T INITIALISE 48K SOFTWARE

       XDEF   ENTR48
ENTR48 JMP    BOOT64

SAMEND CLRB
       TFR    B,DP     CLEARS THE DP REG
       TFR    Y,PC     TRANSFER CONTROL TO ADDRESS IN IY
*
* SFTINI - SOFTWARE INITIALISATION ROUTINE
*
       XDEF   ZSFTIN
ZSFTIN EQU    *
SFTINI LDX    #NZDATA  GET READY TO COPY NON-ZERO TABLE ENTRIES
       LDU    #CBLCNT  INTO RAM BLOCK STARTING AT CBLCNT
       LDB    #13      (B) = COUNT OF BYTES TO COPY
       BSR    NZCOPY   INITIATE COPYING
       JSR    SFTIN2   PATCH FOR SERIAL PRINTER
       LDB    #9       AND IS 9 BYTES IN LENGTH
NZCOPY LDA    0,X+     GET TABLE DATA
       STA    0,U+     AND COPY TO RAM AREA
       DECB            UPDATE COUNT
       BNE    NZCOPY   REPEAT UNTIL BLOCK COMPLETE
       RTS
*
* NON-ZERO TABLE ENTRIES FOLLOW
*
NZDATA FCB    CBLVAL   CURSOR BLINK RATE
       FDB    $0100    SYNC BYTE COUNT
       FCB    $12      MIN 1200HZ CYCLE WIDTH
       FCB    $0A      "    "    PULSE   "   (HALF CYCLE)
       FCB    $12      MAX   "      "     "     "      "
       FDB    MSEC10*50 MOTOR DELAY VALUE - HALF SECOND
       FDB    MSEC10   KEYBOARD DEBOUNCE DELAY VALUE
       FCB    LCFW     LP COMMA FIELD WIDTH
       FCB    LLCF     LP LAST COMMA FIELD
       FCB    LWIDTH   LP WIDTH
* FINAL BLOCK ENTRIES
       FCB    ON       LP BUFFER FULL AUTO LF FLAG
       FCB    ON       ALPHA LOCK FLAG
       FCB    1        CHARACTER COUNT IN LP TERMINATOR SEQUENCE
       FCB    CR       CARRIAGE RETURN FOLLOWED
       FCB    LF       BY LINE FEED SEQUENCE (IF REQUIRED)
       BSZ    4        REMAINDER OF SEQUENCE IS FREE
* END OF NZDATA
*
* CBLINK - CURSOR BLINK ROUTINE
*
       XDEF   ZCBLIN
ZCBLIN EQU    *
CBLINK DEC    CBLCNT   UPDATE BLINK RATE COUNTER
       BNE    BLDLAY   IF .NE. 0 THEN DELAY 10 MSECS
       LDA    #CBLVAL  OTHERWISE RESET TO INITIAL VALUE
       STA    CBLCNT   FOR BLINK RATE
       LDX    CURADR   GET READY TO FLASH CURSOR
       LDA    0,X      BY READING CHAR AT CURSOR POS
       EORA   #$40     AND INVERTING
       STA    0,X      BEFORE WRITING BACK
BLDLAY LDX    #MSEC10  SET UP 10 MSEC DELAY CONSTANT
*
* IXDLAY - DELAY ROUTINE
*
IXDLAY LEAX   -1,X     DECREMENT IX
       BNE    IXDLAY   REPEAT UNTIL (IX) = 0
       RTS
*
* ROUTINES USED BY THEKEYBOARD POLLER FOLLOW
*
* CHKROW - CHECKS ROWS OF K/B MATRIX FOR CLOSURE
*
CHKROW LDB    P0PDRA   READ ROW DATA
       ORB    #$80     SET UNUSED BIT
       TST    P0PDRB   SHIFT KEY IS
       BMI    NOSHFT   IS MASKED OUT
       ORB    #$40     BY THIS
NOSHFT RTS
*
* CSHIFT - CHECKS THE STATE OH THE SHIFT KEY, Z = 1 IF PRESSED
*
CSHIFT LDB    #$7F     CLEAR TOP BIT
       STB    P0PDRB   OF THE COLUMNS
       LDB    P0PDRA   THEN READ ROWS
       ANDB   #$40     MASK OFF ALL BUT SHIFT KEY
       RTS
*
* POLCAT - POLL THE K/B AND RETURN CHARACTER IN (A)
*
       XDEF   ZPOLCA
ZPOLCA EQU    *
POLCAT PSHS   B,X      SAVE REGS
       BSR    POLLKB   POLL AND ENCODE KEYS
       JMP    KEYINT   INITILISE REPEAT COUNTDOWN
*
* POLLKB - POLLS THE K/B, DETECTS KEY CLOSURES, DEBOUNCES KEYS, PERFORMS
* ROLLOVER AND ENCODES CHARACTERS
*
POLLKB LEAS   -2,S     RESERVE 2 BYTES OF WORKSPACE ON STACK
       LDX    #KBROLL  SET UP ADDRESS OF KB ROLLOVER TABLE
* THE FIRST THING TO DO IS TO CHECK FOR ANY KEY CLOSURES WHATSOEVER
       CLR    P0PDRB   FORCE 0'S TO ALL COLUMNS
       LDB    P0PDRA   READ ROW STATUS
       ORB    #$80     SET UNUSED BIT
       CMPB   0,X      CHECK FOR ANY KEYBOARD ACTIVITY
       BEQ    NONKEY   IF THE SAME THEN NO CHANGE
* SOME CHANGE HAS BEEN DETECTED AT THIS POINT SO NEXT THING TO DO
* IS TO MAKE SURE THAT IT WASN'T THE JOYSTICK BUTTONS.
       TFR    B,A      SAVE ROW STATUS
       COM    P0PDRB   FORCE 1'S TO COLUMNS
       BSR    CHKROW   CHECK FOR JOYSTICK BUTTONS
       CMPB   #$FF     AS 0'S ON THE PA0 OR PA1
       BNE    NONKEY   MEAN BUTTONS ARE DOWN
       STA    0,X+     SAVE FULL ROW STATE IN ROLLOVER TABLE
* AT THIS POINT A CHANGE IN THE STATE OF THE ROWS HAS BEEN DETECTED
* SO THE FOLLOWING CODE IS USED TO DETECT WHICH KEY IT WAS
       CLR    0,S      RESET COLUMN COUNT
       LDB    #$FE     SET UP 0 IN LS BIT
       STB    P0PDRB   AND SEND OUT TO MATRIX COLUMNS
SCANKB BSR    CHKROW   CHECK ROW CLOSURES
       STB    1,S      SAVE ROW STATE AWAY
       EORB   0,X      PERFORM KEY CLOSURE AND ROLLOVER DETECTION
       ANDB   0,X      BIT SET IN B IF IT DIFFERED FROM LAST TIME
       LDA    1,S      RESTORE ROW STATE AND
       STA    0,X+     SAVE IN ROLLOVER TABLE FOR NEXT TIME
       TSTB            ANY CHANGES TO KEYS?
       BNE    DEBKEY   YES, DEBOUNCE BEFORE ENCODING
       INC    0,S      ELSE UPDATE COLUMN COUNT
       COMA            USED TO SET CARRY BIT
       ROL    P0PDRB   BEFORE SHIFTING 0 T0 NEXT COLUMN
       BCS    SCANKB   REPEAT UNTIL ALL DONE OR CLOSURE FOUND
       BRA    NONKEY   MUST HAVE BEEN NO KEYS FOUND
* KEY FOUND - DEBOUNCE IT
DEBKEY LDX    KBDLAY   WAIT DEBOUNCE PERIOD
       BSR    IXDLAY   BEFORE RE-CHECKING KB
       EXG    A,B      COPY ORIGINAL KEY CLOSURE
       BSR    CHKROW   AND GET NEW STATE
       CMPB   1,S      AND COMPARE WITH ORIGINAL
       EXG    A,B      RESTORE KEY CLOSURE
       BNE    NONKEY   IF NO MATCH NO KEY RETURNED
* MUST BE A VALID KEY AT THIS POINT SO ENCODE IT
       LDA    0,S      PICK UP COLUMN COUNT
       SUBA   #COLS    OFFSET IT
NXTROW ADDA   #COLS    CALCULATE KEY POSITION AS FOLLOWS
       LSRB            KEY POS = (ROWPPOS)*(COLS) + (COL POS)
       BCC    NXTROW   ROW POS = BIT SET IN (B)
       TSTA            KEY POS = 0 IS A
       BEQ    KEY0     SPECIAL CASE
       CMPA   #$0C     CHECK NUMERIC KEY RANGE
       BLO    NUMKEY   WHICH IS $00 — $0B
       CMPA   #$11     CHECK SPECIAL CASE RANGE
       BLO    SPEC1    WHICH IS $0C — $10
       CMPA   #$2A     AND FINALLY CHECK RANGE
       BHI    SPEC2    $2B ONWARDS SPECIAL CASE
* MUST BE ALPHABETIC CHARACTER IF HERE
       ADDA   #$30     ADD OFFSET FOR ASCII UPPER CASE
       BSR    CSHIFT   AND CHECK WHETHER TO SHIFT
       BEQ    CODED    IF SHIFT THEN UPPER CASE REMAINS
* COULD BE LOWER CASE AT THIS POINT SO CHECK ALPHA LOCK
       TST    ALLOCK
       BNE    CODED    IF ON THEN UPPER CASE OK
       ORA    #$20     ELSE CONVERT TO LOWER CASE
       BRA    CODED    BEFORE EXIT
* NUMERIC (+ OTHERS) ENCODED HERE
NUMKEY ADDA   #$30     CONVERT TO ASCII
       LBSR   CSHIFT   CHECK SHIFT KEY
       BNE    CODED    UNSHIFTED — NO CHANGE
       SUBA   #$10     ELSE CONVERT TO UPPER SET
CODED  CMPA   #SHIFT0  CHECK FOR ALPHA LOCK TOGGLE
       BNE    POLEND
       COM    ALLOCK   TOGGLE IF FOUND
NONKEY CLRA            NO KEY CLOSURE EXIT CONDITION
POLEND PULS   X,PC     TIDY UP WORKSPACE AND RETURN
* SPECIAL CASES FOLLOW
SPEC2  SUBA   #26      MAKE SPECIAL CASES CONTIGUOUS
SPEC1  SUBA   #11      AND OFFSET IN RANGE 1 —>
KEY0   ASLA            2 ENTRIES/KEY
       LBSR   CSHIFT   CHECK FOR SHIFTED SET
       BNE    LOOKUP
       INCA            SHIFTED SET ENTRY OFFSET
LOOKUP LDX    #KEYTAB  SET UP LOOKUP TABLE BASE
       LDA    A,X      LOOKUP KEY ENTRY
       BRA    CODED    AND RETURN IT
* KEY CODE LOOKUP TABLE FOLLOWS
* SECOND ENTRY OF EACH IS THE SHIFTED KEY
KEYTAB FCB    '0,SHIFT0
       FCB    ',,'<
       FCB    '-,'=
       FCB    '.,'>
       FCB    '/,'?
       FCB    '@,$13
       FCB    $5E,$5F  UP ARROW
       FCB    LF,$5B   DOWN ARROW
       FCB    BS,$15   LEFT ARROW
       FCB    $09,$5D  RIGHT ARROW
       FCB    SP,SP    SPACE
       FCB    CR,CR    ENTER
