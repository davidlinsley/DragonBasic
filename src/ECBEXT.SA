       NAM    EXTEND   - Extended Features for TCC / MLC

**********************************************************************
*                                                                    *
*    Copyright 1982 by Microsoft Corporation, all rights reserved    *
*                                                                    *
**********************************************************************

       TTL    External Declarations

       XREF   ASC2
       XREF   BASRST,BLKOUT,BLTU,BUF
       XREF   CASOFF,CHEAD,CHEADA,CHKCLS,CHKCOM,CHKNUM,CHKOPN,CHKSTR,CHROUT
       XREF   CIRCLE,CLEARC,CLOATK,COLORS,COMBYT,CONDCR,CONINT,COPLOP
       XREF   CRDO,CSAVE,CSAVTK
       XREF   DATA,DCRNCH,DEVPRM,DLOAD,DOFDSP,DOSDSP,DRAW
       XREF   EDTENT,ELSETK,ENDCON,EOFFIN,EOFWRT,EQULTK
       XREF   ERPRNT,ERRID,ERROR,ERRUF,EVLADR
       XREF   FADD,FCERR,FDIV,FHALF,FINIT
       XREF   FINLOG,FINSAV,FMULT,FNDLIN,FNTK,FONE
       XREF   FOUT,FOUTCP,FPWRT,FREFAC,FRESTR,FRETMP,FRMEVL
       XREF   FRMNUM,FSUB,FUNDS1
       XREF   GET,GETADR,GETBYT,GETDNM,GETFLN,GETSPA
       XREF   GIVABF,GOGONE,GONE3,GOPTNW,GOTK
       XREF   HKASGN,HKCHRI,HKCHRO,HKCLS1,HKCRNC,HKERR,HKEVAL
       XREF   HKNWST,HKRENM,HKRUN
       XREF   INCHR,INIT,INLNDO,INPCOM,INPRT,INT,ISCNTC,ISDIGC,ISLETC
       XREF   LET,LINE,LINGET,LINPRT,LOADAD,LOFBUF
       XREF   MID$TK,MINUTK,ML1632,MLDVEX,MOVAF,MOV1F,MOVFA1,MOVFM
       XREF   MOVINS,MOVMF,MULDIV
       XREF   NEGOP,NORMAL
       XREF   OPNICK,OPNCSO,OPNOCK,OUTQST,OUTSPC,OVERR
       XREF   PAINT,PARCHK,PCLEAR,PCLS,PCOPY,PIA0BC,PIA0BD,PIA1BD
       XREF   PINIT,PLAY,PLYCLK,PMODE
       XREF   POLY,POLYX,PPOINT,PRESET,PSET,PTRGET,PTRGT2,PUT
       XREF   READY,RUNC
       XREF   SAM,SAMALP,SCREEN,SCRTCH,SETDNM,SIGN,SIN,SIN1,SNDOFF,SNERR
       XREF   SNGFLT,STRLTI,STRSPA,STRTAD,STKINI,STMDS1
       XREF   STRLT3,STROUT,STRPRT,STRTXT,STUB1,SUBTK,SYNCHR
       XREF   THENTK,TICKER,TOTK,TRMCHK
       XREF   ULERR,USRTAB,USRTK
       XREF   VIRQ
       XREF   WRTLDR
       XREF   ZEROF1

       TTL    Miscellanous Routines

*
* The RUN code comes here to set up the defaults for the PLAY
* and DRAW code.  The initialization code also comes here for
* the same reason.
*

       XDEF   XRRUN
XRRUN  LDD    #$B844   Init the PLAY arguments.
       STD    HIGHA    Set volume to 15 decimal.
       LDA    #&2      Set tempo to 2.
       STA    TEMPO
       STA    OCTAVE   Select middle C octave.
       ASLA            Set to undotted quarter notes.
       STA    LNOTE
       CLR    DOTFLG
       LDD    DBLZER   Init the DRAW arguments.
       STD    DRWANG   Set angle and scale to zero.
       LDB    #&128    Position to the middle.  (128,96) 
       STD    LSAVEX
       LDB    #&96
       STD    LSAVEY
RUNRTS RTS             Return to RUN or initialization code.

       TTL    CSAVEM Code

*
* CSAVEM <filename>,<first address>,<last address>,<execution address>
*

       XDEF   CSAVEM
CSAVEM JSR    CHRGET   Eat the "M" of CSAVEM.
       JSR    GETFLN   Scan the filename.
       BSR    STKXAD   Evaluate the first address.
       STX    LOADAD   Put it in the file header too.
       BSR    STKXAD   Evaluate the last address.
       CMPX   &2,S     Is last .GE. first?
       LBLO   FCERR    No, give FC error.
       BSR    STKXAD   Yes, evaluate the execution address
       STX    STRTAD   and put it in the file header block.
       JSR    CHRGOT   The statement must end now or we
       BNE    RUNRTS   to a RTS so NEWSTT will give a
*    syntax error.
CSMDOR LDA    #&2      File type is machine language.
       LDX    DBLZER   GAPFLG:=ASCFLG:=.FALSE.
       JSR    OPNCSO   Open cassette output file.
       CLR    CASOPN   Mark cassette as closed since
*    OPNCSO marked it as open.
       INC    BLKTYP   Set block type to data.
       JSR    WRTLDR   Turn on the cassette and write a
*    leader.

       LDX    &4,S     X:=first address.
CSAVML STX    CBUFAD   Set the buffer address to write the
*    next block out 
       LDA    #&255    Assume it's a full block.
       STA    BLKLEN
       LDD    &2,S     See how many more bytes to write.
       SUBD   CBUFAD
       BHS    MORSAV   There's more to save.
       LEAS   &6,S     Nothing more, clean up the stack
       JMP    FINSAV   and go close the file.

MORSAV CMPD   #&255    Is there a full block?
       BHS    BIGBLK   Yes.
       INCB            No be sure to get the last byte.
       STB    BLKLEN   Set actual block length.
BIGBLK JSR    BLKOUT   Write out the block.
       BRA    CSAVML   Go back for more.

       XDEF   STKXAD
STKXAD JSR    CHKCOM   Eat the comma.
       JSR    EVLADR   Evaluate address into X.
       LDU    ,S       U:=return address.
       STX    ,S       Stack the evaluated address.
       TFR    U,PC     Return with evaluated address on
*    the stack and in X.

        TTL   The FIX function.

*
* FIX(X) returns the truncated integer part of X.
* FIX(X) is equivalent to SGN(X)*INT(ABS(X)).
* FIX differs from INT in that FIX does not return the next lower
* integer for negative arguments.
*


       XDEF   FIX
FIX    JSR    SIGN     Is the number positive?
       BMI    FIXNEG   No.
GOINT  JMP    INT      Yes, just do normal INT function.

FIXNEG COM    FACSGN   Negate the argument.
       BSR    GOINT    Take the INT.
       JMP    NEGOP    Restore the original sign and return.
*    (Can't COM FACSGN, RTS since 0
*    would become -0. For example,
*    ?FIX(-.1) would print -0.)

       TTL    The EDIT Command

       XDEF   EDIT
EDIT   JSR    LINTRM   LINNUM:=number of line to EDIT.
*    (Line number must be terminated.)
       LEAS   &2,S     Get rid of the NEWSTT return address
*    since EDIT exits into the MAIN code.
EDITA  LDA    #&1      Set flag so line will be listed
       STA    EDTLST   prior to starting the edit.
       JSR    FNDLIN   X:=pointer to link field of line.
       LBCS   ULERR    If carry set then line doesn't exist.
       JSR    DCRNCH   Decrunch the line into BUF.
       TFR    Y,D      Calculate and store the line length.
       SUBD   #BUF+&1  (The zero byte terminator isn't
       STB    EDTLEN   included in the length.)

EDTPLN LDD    LINNUM   Print the line number followed
       JSR    LINPRT   by a space.
       JSR    OUTSPC
       LDX    #BUF     Point to the start of the line.
       LDB    EDTLST   Should the line be listed?
       BNE    ELSTIT   Yes, go do it

EDTSUB CLRB            Repetition count:=0.
EDTREP JSR    EDITIN   Get char - screen out bad ones.
       JSR    ISDIGC   Is it a digit?
       BCS    EDNTDG   No.
       SUBA   #'0      Its a digit, get  rid of ASCII offset.
       PSHS   A        Save the digit.
       LDA    #&10     Rep count:=rep count*10.
       MUL
       ADDB   ,S+      Add in the new digit.
       BRA    EDTREP   Look for more digits.

EDNTDG SUBB   #&1      If REP COUNT=0 then REP COUNT:=1.
       ADCB   #&1
       CMPA   #'A      EDIT again?
       BNE    EDITL    No.
       JSR    CRDO     Yes,  start new line
       BRA    EDITA    and  restart edit.

EDITL  CMPA   #'L      LIST AND CONTINUE EDIT?
       BNE    EDITCR   NO
ELSTIT BSR    EDTPRT   YES, PRINT REST OF LINE
       CLR    EDTLST   CLEAR LIST FLAG
       JSR    CRDO     START A NEW LINE
       BRA    EDTPLN   CONTINUE EDIT AT START OF LINE

CRINS  LEAS   &2,S     GET RID OF EDTSUB RETURN ADDRESS
EDITCR CMPA   #CR      CARRIAGE RETURN, LIST AND FINISH EDIT?
       BNE    EDITE    NO
       BSR    EDTPRT   YES, PRINT REST OF LINE
EDTEND JSR    CRDO     START A NEW LINE
AUTENT LDX    #BUF     SET TXTPTR FOR CRUNCH CODE
       STX    TXTPTR
       JMP    EDTENT   JUMP INTO "MAIN" CODE

EDITE  CMPA   #'E      END EDIT?
       BEQ    EDTEND   YES
       CMPA   #'Q      ABORT EDIT?
       BNE    NOTQ     NO
       JSR    CRDO     YES, START NEW LINE
       JMP    READY    AND ABORT EDIT
NOTQ   BSR    DOSUBC   ALL OTHER SUBCOMMANDS RETURN TO EDTSUB
       BRA    EDTSUB   TO GET NEXT SUBCOMMAND

DOSUBC CMPA   #'       MOVE CURSOR RIGHT?
       BNE    EDITD    NO
       SKIP2  JUST     PRINT [B] CHARS
       XDEF   EDTPRT
EDTPRT LDB    #MAXLEN  PRINT REST OF CHARS ON LINE
EPLOOP LDA    ,X       GET CURRENT CHAR
       BEQ    EPRTFN   IF END OF LINE THEN RETURN
       JSR    CHROUT   PRINT THE CHAR
       INX             BUMP EDIT POSITION
       DECB            DECREMENT REP COUNT
       BNE    EPLOOP   REPEAT AS NECESSARY
EPRTFN RTS

EDITD  CMPA   #'D      DELETE CHARS?
       BNE    EDITC    NO
DELLP  TST    ,X       AT END OF LINE?
       BEQ    EPRTFN   YES, NOTHING MORE TO DELETE
       BSR    DELCHR   NO, DELETE CURRENT CHAR
       DECB            REPEAT AS INDICATED
       BNE    DELLP
       RTS

DELCHR DEC    EDTLEN   DECREMENT LINE LENGTH
       LEAY   -&1,Y    ADJUST POINTER FOR preincrement.
CMPRSS LEAY   &1,Y     POINT TO NEXT CHAR
       LDA    &1,Y     MOVE CHARS DOWN A BYTE
       STA    ,Y
       BNE    CMPRSS   UNTIL END OF LINE IS REACHED
       RTS

CHKI   CMPA   #'I      INSERT CHARS?
       BEQ    EDITI    YES, GO DO IT
       CMPA   #'X      ADD CHARS TO END OF LINE?
       BEQ    EDITX    YES
       CMPA   #'H      HACK OFF REST OF LINE AND ADD CHARS?
       BNE    EDITCD   NO
       CLR    ,X       YES, LINE ENDS HERE
       TFR    X,D      Calculate and store the new line
       SUBD   #BUF+&1  length.
       STB    EDTLEN

EDITX  BSR    EDTPRT   PRINT REST OF LINE
EDITI  JSR    EDITIN   GET CHAR TO INSERT
       CMPA   #CR      CARRIAGE RETURN?
       BEQ    CRINS    YES, END INSERTION AND EDIT
       CMPA   #ESCAPE  ESCAPE?
       BEQ    CHGRTS   YES, ALL DONE INSERTING
       CMPA   #CHRDEL  CHARACTER DELETE?
       BNE    EDTINS   NO, GO INSERT THE CHAR
       CMPX   #BUF     IF AT START OF LINE IGNORE DELETE
       BEQ    EDITI    AND GET NEXT CHAR TO INSERT
       BSR    GOBACK   BACK UP THE CURSOR
       BSR    DELCHR   DELETE THE CHAR AND COMPRESS THE LINE
       BRA    EDITI    GO GET NEXT CHAR TO INSERT

EDITC  CMPA   #'C      CHANGE CHARACTERS?
       BNE    CHKI     NO
EDTCHG TST    ,X       AT END OF LINE?
       BEQ    CHGRTS   YES, NOTHING LEFT TO CHANGE
       JSR    EDITIN   GET CHAR TO REPLACE CURRENT CHAR
       BCS    OKCCHR   IF IT'S A CR, ESCAPE, OR CHRDEL
       BRA    EDTCHG   ignore  it.
OKCCHR STA    ,X+      OVERWRITE THE OLD CHAR
       BSR    GCHROT   ECHO THE NEW CHAR
       DECB            REPEAT
       BNE    EDTCHG
CHGRTS RTS


EDTINS LDB    EDTLEN   WILL LINE BE TOO LONG?
       CMPB   #MAXLEN
       BNE    OKINS    NO
       BRA    EDITI    Yes, wait for escape or CR.

OKINS  PSHS   X        SAVE EDIT POINTER
FNDEND TST    ,X+      FIND THE END OF THE LINE
       BNE    FNDEND
INSMOV LDB    ,-X      MAKE ROOM FOR THE NEW CHAR BY MOVING
       STB    &1,X     THE REST OF THE CHARS UP A BYTE
       CMPX   ,S       MOVE ALL INCLUDING CURRENT CHAR
       BNE    INSMOV
       LEAS   &2,S     Clean up the stack.
       STA    ,X+      PUT THE NEW CHAR INTO THE LINE
       BSR    GCHROT   ECHO THE NEW CHAR
       INC    EDTLEN   INCREMENT THE LENGTH
       BRA    EDITI    GET NEXT CHAR TO INSERT

EDITCD CMPA   #CHRDEL  CHARACTER DELETE?
       BNE    CHKK     NO
BACKB  BSR    GOBACK   Yes, output B backspaces.
       DECB
       BNE    BACKB
       RTS

GOBACK CMPX   #BUF     IF AT START OF LINE DO NOTHING
       BEQ    CHGRTS
       DEX             OTHERWISE BACK UP THE EDIT POINTER
*    AND BACK UP THE CURSOR
       IFEQ   REALIO
 ENDC  IFN    REALIO
BCKSPC LDA    #CHRDEL  Back up the cursor.
GCHROT JMP    CHROUT

CHKK   CMPA   #'K      KILL UNTIL MATCH FOUND?
       BEQ    EDITK    YES
       SUBA   #'S      SEARCH FOR CHAR?
       BEQ    EDITK    YES, USE SAME CODE AS K EXCEPT
*    ACCA IS CLEAR AS A FLAG NOT TO KILL
       RTS             Unrecognizable command, ignore it and
*    go get another one.
EDITK  PSHS   A        SAVE KILL FLAG
       BSR    EDITIN   GET SEARCH CHAR
       PSHS   A        PUT IT AWAY
EDTSRC LDA    ,X       END OF LINE?
       BEQ    SRCFIN   YES, GIVE UP SEARCH
       TST    &1,S     IF NOT KILLING THEN PRINT CHARS
       BNE    ISKILL   INSTEAD OF DELETING THEM
       BSR    GCHROT
       INX             POINT TO NEXT CHAR
       BRA    NOKILL
ISKILL JSR    DELCHR   DELETE THE CHAR
NOKILL LDA    ,X       DO THE CHARS MATCH?
       CMPA   ,S
       BNE    EDTSRC   NO, CONTINUE SEARCH
       DECB            YES, BUT MUST SEARCH REP COUNT TIMES
       BNE    EDTSRC
SRCFIN PULS   Y,PC     Clean up the stack and return.

EDITIN JSR    INCHR    GET A CHAR
       CMPA   #&127    THROW AWAY ALL BIGGER THAN TILDA.
       BCC    EDITIN
       CMPA   #@137    Translate shift uparrow key which
       BNE    NOTESC   generates a backarrow to an escape
       LDA    #ESCAPE  for compatibility with the TRS-80.
NOTESC CMPA   #CR      ADMIT LOW EXCEPTIONS
       BEQ    EDTINR
       CMPA   #ESCAPE
       BEQ    EDTINR
       CMPA   #CHRDEL
       BEQ    EDTINR
       CMPA   #'       ALL OTHERS BELOW SPACE ARE BAD
       BCS    EDITIN
EDTSEC SEC             SAY IT ISN'T A LOW EXCEPTION.
EDTINR RTS

       TTL    TRON and TROFF

*
* TRON turns on program tracing by setting TRCFLG to a nonzero
* value.  TRCFLG is checked at NEWSTT and if it is nonzero the
* line number of the line about to be executed is printed enclosed
* in square brackets.  TROFF turns off the program tracing by clearing
* TRCFLG.

       XDEF   TRON
TRON   FCB    @206     LDAIM CLRA opcode to make A nonzero
*    skip over the CLRA.
       XDEF   TROFF
TROFF  CLRA            Prepare to clear TRCFLG.
       STA    TRCFLG   Set or clear the trace flag.
TRORTS RTS

       TTL    The POS function.

*
* POS(<device number>) returns the print postion of the specified
* device.
*
* POS(0) returns the cursor column position.
* POS(-1), if the cassette is open for output, returns a meaningless
* result.  If the cassette is not  open a File Not Open error results.
* If the cassette is open for input, a Bad File Mode error results.
* POS(-2) returns the print position of the lineprinter.
*

       XDEF   POS
POS    LDA    DEVNUM   Preserve DEVNUM since this could be
       PSHS   A        a case such as PRINT #-1,POS(0).
       JSR    SETDNM   Convert and check the argument.
       JSR    OPNOCK   Make sure the device is open for
*    output.
       JSR    DEVPRM   Get the device parameters.
       LDB    DEVPOS   Get the position into B.
       PULS   A        Restore DEVNUM.
       STA    DEVNUM
       JMP    SNGFLT   Float the result and return.

       TTL    The VARPTR function.

*
* VARPTR(<variable name>) returns the address of the specified
*

* It is important to note that VARPTR is not legal for undefined
* variables.  This is due to the fact that PTRGET will block transfer
* to make room for the new variable. A case such as A(0)=VARPTR(S)
* where S is undefined would cause disastrous results since the array
* A would have moved. Therefore, an FC error results is VARPTR is
* called with an undefined variable as the argument.
* This is accomplished by saving STREND prior to the PRTGET call
* and checking to see that it hasn't changed when PTRGET returns.
*

       XDEF   VARPTR
VARPTR JSR    CHKOPN   Eat the opening parenthesis.
       LDD    STREND   Remember the top of storage.
       PSHS   D
       JSR    PTRGET   X:=pointer to the variable.
       JSR    CHKCLS   Check for the closing parenthesis.
       PULS   D        X:=original top of storage,
       EXG    X,D      D:=pointer to variable.
       CMPX   STREND   Did the top of storage change during
*    the call to PTRGET?
       BNE    XRFC1    Yes, give an FC error since the
*    variable was undefined prior to the
*    PTRGET call.
       JMP    PATCHV   No, go float the result and return.

       TTL    MID$ Assignment (MID$ on the Left Side).

       XDEF   LHMID$
LHMID$ JSR    CHRGET   Eat the second byte of the function
       JSR    CHKOPN   token and the left parenthesis.
       JSR    PTRGET   X:=pointer to left string
*    variable's descriptor.
       PSHS   X        Save it.
       LDD    &2,X     X:=pointer to left string data.
       CMPD   STKTOP   is it in string space?
       BLS    LHMD05   No, must copy.
       SUBD   MEMSIZ
       BLS    LHMD10   Yes, don't copy.
*    No, it must be copied into string
*    space prior ro being modified.  (It
*    could be a string literal in the
*    program for example.)
*    Note that this code checks both
*    ends of string space rather than
*    just checking to see if the string
*    is above STKTOP.  This is done
*    so it will be possible to put
*    random file buffers above MEMSIZ
*    and the copy will still occur for
*    compatibility with other versions
*    of BASIC.
LHMD05 LDB    ,X       Get the required amount of string
       JSR    GETSPA   space.
       PSHS   X        Save the pointer to the free space.
       LDX    &2,S     Copy the string.
       JSR    MOVINS
       PULS   X,U      Put the new string data address into
       STX    &2,U     the string descriptor.
       PSHS   U        Resave the descriptor pointer.
LHMD10 JSR    COMBYT   Skip comma, B:=offset into left
*    string.
       PSHS   B        Save the offset.
       TSTB            Give a Function Call error if the
       BEQ    XRFC1    offset is zero.
       LDB    #&255    Assume no third argument, in which
*    case as many chars as possible will
*    be replaced.
       CMPA   #CLSPAR  Arrived at the closing parenthesis?
       BEQ    LHMD30   Yes, no third argument.
       JSR    COMBYT   No, skip the comma and evaluate the
*    number of chars to replace.
LHMD30 PSHS   B        Save the number of chars to replace.
       JSR    CHKCLS   Eat the closing parenthesis and
       SYNCHK EQULTK   the equals sign.
       BSR    EVLSTR   Evaluate the right string
*    formula, B:=length, X:=pointer to
*    string data.
       TFR    X,U      Save pointer in U.
       LDX    &2,S     X:=pointer to left string
*    descriptor.
       LDA    ,X       A:=length of left string.
       SUBA   &1,S     Is the specified offset beyond the
*    end of the left string?
       BHS    LHMD35   No.
XRFC1  JMP    FCERR    Yes, give FC error.

LHMD35 INCA            No, A:=number of chars between the
*    offset and theend of the left
*    string.
       CMPA   ,S       Is the number of chars that can be
*    replaced greater than or equal to
*    the specified number or default (255)?
       BHS    LHMD40   Yes, use the use the specified or
*    default number.
       STA    ,S       No, use the lesser number.
LHMD40 LDA    &1,S     A:=offset into left string.
       EXG    A,B      A:=length of right string,
*    B:=offset into left string.
*    (Want to use ABX below since it
*    does an unsigned addition.)
       LDX    &2,X     X:=pointer to left string data.
       DECB            X:=pointer into left string
       ABX             where replacement will begin.
       TSTA            Is the right string null?
       BEQ    LHMD60   Yes, no replacement can be done.
       CMPA   ,S       No, is the right string shorter 
*    than the number of chars to be
*    replaced?
       BLS    LHMD50   Yes, only replace the number of chars
*    contained in the right string.
       LDA    ,S       No, use the replacement count
*    previously determined.
LHMD50 TFR    A,B      B:=number of chars to move.
       EXG    U,X      X:=source pointer (right string),
*    U:=destination pointer (left
*    string).
       JSR     COPLOP  Go move the characters.
LHMD60 PULS    D,X,PC  Clean up the stack and return.


*
* EVLSTR evaluates a numeric formula and returns with
* B containing the length of the string and X containing
* a pointer to the string data.
*

       XDEF   EVLSTR
EVLSTR JSR    FRMEVL   Evaluate a formula.
       JMP    FRESTR   Make sure it's a string, free up
*    the temporary, X:=pointer to string
*    data, B:=length of string.

       TTL    The STRING$ Function.

*
* STRING$(<count>, <character>) returns a string of length <count>
* which is filled with the character specified by <character>.
* <character> can be specified as a string or a numeric formula.
* If string, the first  character is used to fill the result.
* If numeric, the value is used as an ASCII code to fill the
* result.
*

       XDEF   STRNG$
STRNG$ JSR    CHKOPN   Eat the open parenthesis.
       JSR    GETBYT   Evaluate and save the count.
       PSHS   B
       JSR    CHKCOM   Eat the comma.
       JSR    FRMEVL   Evaluate the second argument.
       JSR    CHKCLS   Check for the closing parenthesis.
       LDA    VALTYP   Is the second argument numeric?
       BNE    STR2AR   No, it's a string.
       JSR    CONINT   Yes, convert it to an integer in B.
       BRA    GTROOM   Go get space for the string.

STR2AR JSR    ASC2     B:=ASCII code of the first byte of
*    the second argument.
GTROOM PSHS   B        Save the character code.
       LDB    &1,S     Get length of result string.
       JSR    STRSPA   Get the required amount of string
*    space.
       PULS   A,B      A:=char code, B:=string length.
       BEQ    FINBLD   Zero length string, don't put
*    any chars into it.  (STRSPA set
*    the condition codes on the length
*    of the string.)
BUILDS STA    ,X+      Build the result string by storing
       DECB            the character code into each
       BNE    BUILDS   byte of the string.
FINBLD JMP    GOPTNW   Go put away the result.

       TTL    The INSTR Function.

*
* INSTR([<offset>,<S1$>,<S2$>) searches S1$ for the first
* occurence of S2$ starting at the specified offset or at the
* start of S1$ if no offset is specified.
*
* The value returned is the position of the first char if a match
* is found, zero if a match is not found.
*
* If S2$ is null, the specified offset or 1 is returned.
*
* If S1$ is null, or the offset is beyond the end of S1$,
* 0 is returned. (These are not really special cases
* from the user's viewpoint, but the code checks for them as
* special cases.)
*
* If an offset of zero is specified, an FC error results.
*

       XDEF   INSTR
INSTR  JSR    CHKOPN   Check for the left parenthesis.
       JSR    FRMEVL   Evaluate the first argument.
       LDB    #&1      Assume no offset is specified and
       PSHS   B        set up the default.
       LDA    VALTYP   Is the first argument numeric?
       BNE    INST10   No, no offset.
       JSR    CONINT   Yes, B:=specified offset.
       STB    ,S       Overwrite the default.
       BEQ    XRFC1    Don't allow an offset of zero.
       JSR    CHKCOM   Eat the comma, evaluate and check
       JSR    FRMEVL   the S1$ argument.  (Don't want to call
       JSR    CHKSTR   EVLSTR since it would free up the
*    temporary and we can't do that until
*    the S2$ argument has been evaluated.)
INST10 LDX    FACMO    Save the pointer to the S1$
       PSHS   X        descriptor.
       JSR    CHKCOM   Skip the comma and evaluate the S2$
       JSR    EVLSTR   argument.
       PSHS   X,B      Save data pointer and length of S2$.
       JSR    CHKCLS   Check for the right parenthesis.
       LDX    &3,S     Free up the S1$ temp.
       JSR    FRETMP   X:=data pointer, B:=length.
       PSHS   B        Save length of S1$.
       CMPB   &6,S     Is the offset beyond the end of S1$?
       BLO    INST50   Yes, return 0.
       LDA    &1,S     No, is S2$ null?
       BEQ    INST40   Yes, return the offset.
       LDB    &6,S     No, X:=pointer into S1$ where the
       DECB            search must begin.
       ABX

INST20 LEAY   ,X       Save S1$ pointer where current
*    search began.
       LDU    &2,S     U:=pointer to S2$.
       LDB    &1,S     B:=length of S2$.
       LDA    ,S       A:=number of chars between the
       SUBA   &6,S     search starting point and the end
       INCA            of S1$.
       CMPA   &1,S     Is it shorter than S2$?
       BLO    INST50   Yes, give up and return 0.

INST30 LDA    ,X+      Get char from S1$.
       CMPA   ,U+      Compare to char in S2$.
       BNE    INST60   Not the same.
       DECB            Same, more to check?
       BNE    INST30   Yes, check next chars.

INST40 LDB    &6,S     Match, return the offset.
       FCB    @41      BRN over CLRB.
INST50 CLRB            No match, return 0.
       LEAS   &7,S     Clean up the stack.
       JMP    SNGFLT   Float the result and return.

INST60 INC    &6,S     Chars not the same, increment offset
*    into S1$.
       LEAX   &1,Y     Start searching one char to the right
       BRA    INST20   in S1$.

       TTL    Hex and Octal Constants

       XDEF   HOCONS
HOCONS CLR    FACMO    Clear FACMO,FACLO since that's where
       CLR    FACLO    the result is built.
       LDX    #FACMO   Set up a pointer to the FAC.
       JSR    CHRGET   See if O or H specified.
       CMPA   #'O      O for octal?
       BEQ    OCTCN1   Yes, go do octal.
       CMPA   #'H      No, H for hex?
       BEQ    HEXCN0   Yes, go do hex.
*    No, default to octal.
       JSR    CHRGOT   Reget current char to set
       BRA    OCTCN2   condition codes.

OCTCN0 CMPA   #'8      Is it a valid octal digit?
       LBHI   SNERR    No, give a syntax error.
       LDB    #&3      Yes, bits/digit:=3.
       BSR    HODIG    Go add in the new digit.
OCTCN1 JSR    CHRGET   Get next char.
OCTCN2 BCS    OCTCN0   It's a digit, continue.
*    Not a digit, time to quit.

*
* Float the sixteen bit unsigned value in FACMO,FACLO.
*

       XDEF   CONS16
CONS16 CLR    FACHO    Clear the most significant byte.
       IFNE   ADDPRC
       CLR    FACMOH
       ENDC   IFN      ADDPRC
CONS24 CLR    VALTYP   Set VALTYP to numeric.
       CLR    FACOV
       CLR    FACSGN   Mark as positive.
       LDB    #@230+@10*ADDPRC Set up the exponent.
       STB    FACEXP
       JMP    NORMAL   So normalize it.

HEXCN0 JSR    CHRGET   Get next char.
       XDEF   HEXCNX
HEXCNX BCS    HEXCN1   It's a numeric digit.
       JSR    ISLETC   Not numeric, see if letter.
       BCS    CONS16   Not letter, finished.
       CMPA   #'F+&1   Valid hex alpha digit?
       BCC    CONS16   No, all done.
       SUBA   #'A-'0-&10 Yes, adjust alpha code.

HEXCN1 LDB    #&4      Bits/digit:=4.
       BSR    HODIG    Add in new digit.
       BRA    HEXCN0   Do next digit.


HODIG  ASL    &1,X     Shift current value left bits/digit
       ROL    ,X       times while checking for overflow.
       LBCS   OVERR
       DECB
       BNE    HODIG
       SUBA   #'0      Subtract out ASCII offset.
       ADDA   &1,X     Add in new digit to
       STA    &1,X     low order byte.
HORTS  RTS             (Can't get carry since low order
*    hex or octal digit is a zero from
*    shifting done above.)

       TTL    Simple User Defined Function Code.


*
* Note only single arguments are allowed to functions
* and functions must be of the single line form:
* DEF FNA(X)=X^2+X-2
* Both the argument and result must be numeric.
*
* Idea: create a simple variable entry
* whose first character has the 200 bit set.
* The value will be:
*
* A text pntr to the formula.
* A pntr to the argument variable.
*
* Function names can be like FNA4.
*
*
* Subroutine to see if we are in direct mode
* and complain if so.
*

       XDEF   ERRDIR
ERRDIR LDX    CURLIN   Dir mode has CURLIN=65535.
       LEAX   &1,X     So now, is result zero?
       BNE    HORTS    Yes.
       LDB    #ERRID   Illegal Direct Error.
ERRGO1 JMP    ERROR

       XDEF   DEF
DEF    LDX    [TXTPTR] Is it DEF USR?
       CMPX   #$FF00+USRTK
       LBEQ   DEFUSR   Yes, go define the USR function
*    address.
       BSR    GETFNM   Get a pntr to the function.
       BSR    ERRDIR
       JSR    CHKOPN   Must have "(".
       LDB    #&128
       STB    SUBFLG   Prohibit subscripted variables.
       JSR    PTRGET   Get pntr to argument.
       BSR    CHKNU2   Is it a number?
       JSR    CHKCLS   Must have ")"
       SYNCHK EQULTK   Must have "=".
       LDX    DEFPNT   Get pntr to thing to store in.
       LDD    TXTPTR   Get thing to store.
       STD    ,X       Put down text pointer.
       LDD    VARPNT   Get more to store.
       STD    &2,X     Store it.
       JMP    DATA     Skip to end.

*
* Subroutine to get a pntr to a function name.
*

GETFNM SYNCHK FNTK     Must start with FN.
       LDB    #&128    Don't allow an array.
       STB    SUBFLG
       ORA    #&128    Put function bit on.
       JSR    PTRGT2   Get pntr to function or create anew.
       STX    DEFPNT
CHKNU2 JMP    CHKNUM   Make sure it's numeric and return.

       XDEF   FNDOER
FNDOER BSR    GETFNM   Get pointer to function definition.
       PSHS   X        Save it.
       JSR    PARCHK   Evaluate the actual parameter.
*    (It's enclosed in parentheses.)
       BSR    CHKNU2   Make sure it's numeric.
       PULS   U        U:=pointer to function def.
       LDB    #ERRUF   In case function is undefined.
       LDX    &2,U     X:=pointer to dummy arg variable.
       BEQ    ERRGO1   If zero the function isn't defined.
       LDY    TXTPTR   Y:=text pointer which points into
*    function call.
       LDU    ,U       U:=function definition text pointer.
       STU    TXTPTR   Set up txtptr for FRMEVL.
       IFNE   ADDPRC
       LDA    &4,X     Push on extra byte of arg variable.
       PSHS   A
       ENDC   IFN      ADDPRC
       LDD    ,X       D,U:=dummy arg variable value.
       LDU    &2,X
       PSHS   U,Y,X,B,A Save dummy arg variable value, pointer
*    to dummy arg, and call text pointer.
       JSR    MOVMF    Move actual parm value into dummy
*    arg variable from FAC.
       JSR    FRMNUM   Evaluate a numeric formula.  (This
*    is the function def formula.)
       PULS   A,B,X,Y,U Get back dummy arg value, dummy arg
*    pointer, and call text pointer.
       STD    ,X       Restore the dummy arg.
       STU    &2,X
       IFNE   ADDPRC
       PULS   A        Restore extra byte of arg variable.
       STA    &4,X
       ENDC   IFN      ADDPRC
       JSR    CHRGOT   Make sure the function definition is
       LBNE   SNERR    Properly terminated.  (Can't make this
*    check during definition time since
*    it is then not known where the end of
*    the expression is.)
       STY    TXTPTR   Restore caller's TXTPTR.
DEFRTS RTS

       TTL    USR Function Code.

*
* Here when DEF sees a USR token.
*

DEFUSR JSR    CHRGET   Skip the first byte of the function
*    token.
       JSR    CHRGET
       BSR    SCNUSR   X:=address of USRTAB entry.
       PSHS   X        Save it.
       BSR    EQUADR   Skip equals sign, X:=address.
       STX    [,S++]   return.
       RTS


*
* Scan USR function number and return a pointer to the specified
* USRTAB entry in X.
*

SCNUSR CLRB            Assume no function number specified.
*    The default is USR0.
       JSR     CHRGOT  USR token ALREADY SKIPPED.
       BCC     ISUSR0  No digit, default to USR0.
       SUBA    #'0     Get rid of ASCII offset and put the
       TFR     A,B     function number into B.
       JSR     CHRGET  Skip the digit.
ISUSR0 LDX     USTBAD  X:=pointer to USRTAB.
       ASLB            USRTAB entries are two bytes each.
       ABX             X:=pointer to specified entry and
       RTS             return.


*
* Here when USR token is seen by the EVAL chain.
*

       XDEF   USRFN
USRFN  BSR    SCNUSR   X:=pointer to USRTAB entry.
       LDX    ,X       Save the address of the USR function.
       PSHS   X
       JSR    PARCHK   Evaluate formula enclosed in parens.
       LDX    #FAC     Point to the FAC so the USR routine
*    doesn't need to know the absolute
*    address of the FAC for numeric
*    arguments.
       LDA    VALTYP   Is it numeric?
       BEQ    USRDSP   Yes, the argument is in the FAC.
       JSR    FREFAC   No, free up the string temporary.
       LDX    FACMO    X:=pointer to the string descriptor.
       LDA    VALTYP   Indicate the argument is string.
USRDSP RTS             Dispatch to the USR function.


*
* Skip equals sign and evaluate 16 bit unsigned integer into X.
*

EQUADR SYNCHK EQULTK   Skip the equals sign.
       JMP    EVLADR   Evaluate address into X and return.

       TTL    TIME and TIME$

       IFNE   TODCLK
 ENDC   IFN TODCLK
*
* XRSLWC is the clock interrupt routine.  It is invoked by
* an IRQ every 60th of a second.
*
* Note that TICKER is off the direct page.  If it were on the direct
* page it would be necessary to either set the DP register or
* force extended addressing to be used.
*

       XDEF   XRSLWC
XRSLWC LDA    PIA0BC   Is the slow clock interrupt flag set?
       BMI    DOTIMR   Yes.
       RTI             No, return from the interrupt.

DOTIMR LDA    PIA0BD   Clear the interrupt request.
       XDEF   XRTIMR
XRTIMR EQU    *        The disk ROM comes here when it
*    is finished with the timer IRQ.
       IFNE    TODCLK
 ENDC    IFN TODCLK
       IFEQ    TODCLK
       LDX     TICKER  Increment the two byte tick count.
       LEAX    &1,X
       STX     TICKER
       ENDC    IFE     TODCLK
GOPLYC JMP     PLYCLK  Go handle the special timer for
*    the PLAY statement.

       TTL    TIMER

       IFEQ   TODCLK

*
* Here to set the timer via TIMER=tick count.
* 0 .LE. tick count .LE. 65535.
*

       XDEF   TIMSET
TIMSET JSR    CHRGET     Skip the second byte of the function
*    token.
       BSR    EQUADR   Skip equals sign, X:=tick count.
       STX    TICKER   Put it into the timer and return.
       RTS


*
* Here to return the tick count for the TIMER function.
*

       XDEF   TIMER
TIMER  LDX    TICKER   Get the tick count.
       STX    FACMO    Float it and return.
       JMP    CONS16
       ENDC   IFE      TODCLK

       TTL    The DELETE Command

       XDEF   DELETE
DELETE LBEQ   FCERR    At least one line number must be
*    specified.
       JSR    LINGET   Read the first line number.
*    (Returns 0 if dash is first  thing.)
       JSR    FNDLIN   Get and save a pointer to the first
       STX    FSTPTR   line to be deleted.
       JSR    CHRGOT   See what the terminator is.
       BEQ    DELSRC   End of statement, delete only the
*    specified line if it exists.
       CMPA   #MINUTK  It must be a dash.
       BNE    DELSNR   Return to NEWSTT to give SN error
*    if not  dash.
       JSR    CHRGET   Skip over the dash.
       BEQ    DTOEND   End of statement, delete to the end
*    of the program.
       BSR    LINTRM   Read the final line number into
*    LINNUM and check for a terminator.
       BRA    DELSRC   Go find the first line in the range.

DTOEND LDA    #&255    Set LINNUM so higher than any
       STA    LINNUM   program line number.  (Don't care
*    about low order byte since 255*256
*    is 65280 and the highest program
*    line number allowed is 63999.)
DELSRC LDU    FSTPTR   Search for the first line outside
       SKIP2  the      range of lines to be deleted.
DELSLP LDU    ,U       Link to the next line.
       LDD    ,U       Is the link zero?
       BEQ    DELDOR   Yes, have hit end of program.
       LDD    &2,U     No, is the line number
       SUBD   LINNUM   higher than the last specified one?
       BLS    DELSLP   No, go link to the next line.
*    Yes, U is pointing to the link field
*    of the first line beyond the range.
DELDOR LDX    FSTPTR   X:=pointer to link field of first
*    line to be deleted.
*      BSR    DELDO    Move the top of the program down
*    over the lines being deleted and
*    update VARTAB.
*    Note that if a null range was
*    specified (as in the case where a
*    single nonexistent line was given),
*    the block transfer is done anyway
*    but is OK since source and dest
*    pointers are the same.
       JSR    RUNC     Wipe out variables and reset the
*    stack.
       LDX    FSTPTR   Fix up the links of the lines that
       JSR    CHEAD    were moved.
       JMP    READY    Go print "OK".


LINTRM JSR    LINGET   Read a line number into LINNUM.
       JMP    TRMCHK   Check for end of statement.


*
* Enter at DELDO to block transfer down from U to X until U=[VARTAB].
* Then update [VARTAB] by storing final X into it.
*

MORDEL LDA    ,U+      Set byte and move it down.
       STA    ,X+
DELDO  CMPU   VARTAB   At end of program?
       BNE    MORDEL   No, continue moving.
       STX    VARTAB   Yes, update VARTAB and return.
DELSNR RTS

       TTL    LINEINPUT

*
* LINEINPUT [#<device number>,]["<prompt>";]<string variable>
*
* The graphics LINE statement comes here when it sees an INPUT token
* following the LINE token.
*

       XDEF   ILINE
ILINE  JSR    ERRDIR   Disallow in direct execution mode
*    since it smashes BUF.
       JSR    CHRGET   Skip past the INPUT token.
       CMPA   #'#      Device number specified?
       BNE    ILNKBD   No, input will come from keyboard.
       JSR    GETDNM   Yes, scan the device number.
       JSR    OPNICK   Take sure it's open for input.
       JSR    CHKCOM   A comma must follow the device number.
