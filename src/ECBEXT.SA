       NAM    EXTEND   - Extended Features for TCC / MLC

**********************************************************************
*                                                                    *
*    Copyright 1982 by Microsoft Corporation, all rights reserved    *
*                                                                    *
**********************************************************************

       TTL    External Declarations

       XREF   ASC2
       XREF   BASRST,BLKOUT,BLTU,BUF
       XREF   CASOFF,CHEAD,CHEADA,CHKCLS,CHKCOM,CHKNUM,CHKOPN,CHKSTR,CHROUT
       XREF   CIRCLE,CLEARC,CLOATK,COLORS,COMBYT,CONDCR,CONINT,COPLOP
       XREF   CRDO,CSAVE,CSAVTK
       XREF   DATA,DCRNCH,DEVPRM,DLOAD,DOFDSP,DOSDSP,DRAW
       XREF   EDTENT,ELSETK,ENDCON,EOFFIN,EOFWRT,EQULTK
       XREF   ERPRNT,ERRID,ERROR,ERRUF,EVLADR
       XREF   FADD,FCERR,FDIV,FHALF,FINIT
       XREF   FINLOG,FINSAV,FMULT,FNDLIN,FNTK,FONE
       XREF   FOUT,FOUTCP,FPWRT,FREFAC,FRESTR,FRETMP,FRMEVL
       XREF   FRMNUM,FSUB,FUNDS1
       XREF   GET,GETADR,GETBYT,GETDNM,GETFLN,GETSPA
       XREF   GIVABF,GOGONE,GONE3,GOPTNW,GOTK
       XREF   HKASGN,HKCHRI,HKCHRO,HKCLS1,HKCRNC,HKERR,HKEVAL
       XREF   HKNWST,HKRENM,HKRUN
       XREF   INCHR,INIT,INLNDO,INPCOM,INPRT,INT,ISCNTC,ISDIGC,ISLETC
       XREF   LET,LINE,LINGET,LINPRT,LOADAD,LOFBUF
       XREF   MID$TK,MINUTK,ML1632,MLDVEX,MOVAF,MOV1F,MOVFA1,MOVFM
       XREF   MOVINS,MOVMF,MULDIV
       XREF   NEGOP,NORMAL
       XREF   OPNICK,OPNCSO,OPNOCK,OUTQST,OUTSPC,OVERR
       XREF   PAINT,PARCHK,PCLEAR,PCLS,PCOPY,PIA0BC,PIA0BD,PIA1BD
       XREF   PINIT,PLAY,PLYCLK,PMODE
       XREF   POLY,POLYX,PPOINT,PRESET,PSET,PTRGET,PTRGT2,PUT
       XREF   READY,RUNC
       XREF   SAM,SAMALP,SCREEN,SCRTCH,SETDNM,SIGN,SIN,SIN1,SNDOFF,SNERR
       XREF   SNGFLT,STRLTI,STRSPA,STRTAD,STKINI,STMDS1
       XREF   STRLT3,STROUT,STRPRT,STRTXT,STUB1,SUBTK,SYNCHR
       XREF   THENTK,TICKER,TOTK,TRMCHK
       XREF   ULERR,USRTAB,USRTK
       XREF   VIRQ
       XREF   WRTLDR
       XREF   ZEROF1

       TTL    Miscellanous Routines

*
* The RUN code comes here to set up the defaults for the PLAY
* and DRAW code.  The initialization code also comes here for
* the same reason.
*

       XDEF   XRRUN
XRRUN  LDD    #$B844   Init the PLAY arguments.
       STD    HIGHA    Set volume to 15 decimal.
       LDA    #&2      Set tempo to 2.
       STA    TEMPO
       STA    OCTAVE   Select middle C octave.
       ASLA            Set to undotted quarter notes.
       STA    LNOTE
       CLR    DOTFLG
       LDD    DBLZER   Init the DRAW arguments.
       STD    DRWANG   Set angle and scale to zero.
       LDB    #&128    Position to the middle.  (128,96) 
       STD    LSAVEX
       LDB    #&96
       STD    LSAVEY
RUNRTS RTS             Return to RUN or initialization code.

       TTL    CSAVEM Code

*
* CSAVEM <filename>,<first address>,<last address>,<execution address>
*

       XDEF   CSAVEM
CSAVEM JSR    CHRGET   Eat the "M" of CSAVEM.
       JSR    GETFLN   Scan the filename.
       BSR    STKXAD   Evaluate the first address.
       STX    LOADAD   Put it in the file header too.
       BSR    STKXAD   Evaluate the last address.
       CMPX   &2,S     Is last .GE. first?
       LBLO   FCERR    No, give FC error.
       BSR    STKXAD   Yes, evaluate the execution address
       STX    STRTAD   and put it in the file header block.
       JSR    CHRGOT   The statement must end now or we
       BNE    RUNRTS   to a RTS so NEWSTT will give a
*    syntax error.
CSMDOR LDA    #&2      File type is machine language.
       LDX    DBLZER   GAPFLG:=ASCFLG:=.FALSE.
       JSR    OPNCSO   Open cassette output file.
       CLR    CASOPN   Mark cassette as closed since
*    OPNCSO marked it as open.
       INC    BLKTYP   Set block type to data.
       JSR    WRTLDR   Turn on the cassette and write a
*    leader.

       LDX    &4,S     X:=first address.
CSAVML STX    CBUFAD   Set the buffer address to write the
*    next block out 
       LDA    #&255    Assume it's a full block.
       STA    BLKLEN
       LDD    &2,S     See how many more bytes to write.
       SUBD   CBUFAD
       BHS    MORSAV   There's more to save.
       LEAS   &6,S     Nothing more, clean up the stack
       JMP    FINSAV   and go close the file.

MORSAV CMPD   #&255    Is there a full block?
       BHS    BIGBLK   Yes.
       INCB            No be sure to get the last byte.
       STB    BLKLEN   Set actual block length.
BIGBLK JSR    BLKOUT   Write out the block.
       BRA    CSAVML   Go back for more.

       XDEF   STKXAD
STKXAD JSR    CHKCOM   Eat the comma.
       JSR    EVLADR   Evaluate address into X.
       LDU    ,S       U:=return address.
       STX    ,S       Stack the evaluated address.
       TFR    U,PC     Return with evaluated address on
*    the stack and in X.

        TTL   The FIX function.

*
* FIX(X) returns the truncated integer part of X.
* FIX(X) is equivalent to SGN(X)*INT(ABS(X)).
* FIX differs from INT in that FIX does not return the next lower
* integer for negative arguments.
*


       XDEF   FIX
FIX    JSR    SIGN     Is the number positive?
       BMI    FIXNEG   No.
GOINT  JMP    INT      Yes, just do normal INT function.

FIXNEG COM    FACSGN   Negate the argument.
       BSR    GOINT    Take the INT.
       JMP    NEGOP    Restore the original sign and return.
*    (Can't COM FACSGN, RTS since 0
*    would become -0. For example,
*    ?FIX(-.1) would print -0.)

       TTL    The EDIT Command

       XDEF   EDIT
EDIT   JSR    LINTRM   LINNUM:=number of line to EDIT.
*    (Line number must be terminated.)
       LEAS   &2,S     Get rid of the NEWSTT return address
*    since EDIT exits into the MAIN code.
EDITA  LDA    #&1      Set flag so line will be listed
       STA    EDTLST   prior to starting the edit.
       JSR    FNDLIN   X:=pointer to link field of line.
       LBCS   ULERR    If carry set then line doesn't exist.
       JSR    DCRNCH   Decrunch the line into BUF.
       TFR    Y,D      Calculate and store the line length.
       SUBD   #BUF+&1  (The zero byte terminator isn't
       STB    EDTLEN   included in the length.)

EDTPLN LDD    LINNUM   Print the line number followed
       JSR    LINPRT   by a space.
       JSR    OUTSPC
       LDX    #BUF     Point to the start of the line.
       LDB    EDTLST   Should the line be listed?
       BNE    ELSTIT   Yes, go do it

EDTSUB CLRB            Repetition count:=0.
EDTREP JSR    EDITIN   Get char - screen out bad ones.
       JSR    ISDIGC   Is it a digit?
       BCS    EDNTDG   No.
       SUBA   #'0      Its a digit, get  rid of ASCII offset.
       PSHS   A        Save the digit.
       LDA    #&10     Rep count:=rep count*10.
       MUL
       ADDB   ,S+      Add in the new digit.
       BRA    EDTREP   Look for more digits.

EDNTDG SUBB   #&1      If REP COUNT=0 then REP COUNT:=1.
       ADCB   #&1
       CMPA   #'A      EDIT again?
       BNE    EDITL    No.
       JSR    CRDO     Yes,  start new line
       BRA    EDITA    and  restart edit.

EDITL  CMPA   #'L      LIST AND CONTINUE EDIT?
       BNE    EDITCR   NO
ELSTIT BSR    EDTPRT   YES, PRINT REST OF LINE
       CLR    EDTLST   CLEAR LIST FLAG
       JSR    CRDO     START A NEW LINE
       BRA    EDTPLN   CONTINUE EDIT AT START OF LINE

CRINS  LEAS   &2,S     GET RID OF EDTSUB RETURN ADDRESS
EDITCR CMPA   #CR      CARRIAGE RETURN, LIST AND FINISH EDIT?
       BNE    EDITE    NO
       BSR    EDTPRT   YES, PRINT REST OF LINE
EDTEND JSR    CRDO     START A NEW LINE
AUTENT LDX    #BUF     SET TXTPTR FOR CRUNCH CODE
       STX    TXTPTR
       JMP    EDTENT   JUMP INTO "MAIN" CODE

EDITE  CMPA   #'E      END EDIT?
       BEQ    EDTEND   YES
       CMPA   #'Q      ABORT EDIT?
       BNE    NOTQ     NO
       JSR    CRDO     YES, START NEW LINE
       JMP    READY    AND ABORT EDIT
NOTQ   BSR    DOSUBC   ALL OTHER SUBCOMMANDS RETURN TO EDTSUB
       BRA    EDTSUB   TO GET NEXT SUBCOMMAND

DOSUBC CMPA   #'       MOVE CURSOR RIGHT?
       BNE    EDITD    NO
       SKIP2  JUST     PRINT [B] CHARS
       XDEF   EDTPRT
EDTPRT LDB    #MAXLEN  PRINT REST OF CHARS ON LINE
EPLOOP LDA    ,X       GET CURRENT CHAR
       BEQ    EPRTFN   IF END OF LINE THEN RETURN
       JSR    CHROUT   PRINT THE CHAR
       INX             BUMP EDIT POSITION
       DECB            DECREMENT REP COUNT
       BNE    EPLOOP   REPEAT AS NECESSARY
EPRTFN RTS

EDITD  CMPA   #'D      DELETE CHARS?
       BNE    EDITC    NO
DELLP  TST    ,X       AT END OF LINE?
       BEQ    EPRTFN   YES, NOTHING MORE TO DELETE
       BSR    DELCHR   NO, DELETE CURRENT CHAR
       DECB            REPEAT AS INDICATED
