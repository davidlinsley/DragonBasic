       NAM    EXTEND   - Extended Features for TCC / MLC

**********************************************************************
*                                                                    *
*    Copyright 1982 by Microsoft Corporation, all rights reserved    *
*                                                                    *
**********************************************************************

       TTL    External Declarations

       XREF   ASC2
       XREF   BASRST,BLKOUT,BLTU,BUF
       XREF   CASOFF,CHEAD,CHEADA,CHKCLS,CHKCOM,CHKNUM,CHKOPN,CHKSTR,CHROUT
       XREF   CIRCLE,CLEARC,CLOATK,COLORS,COMBYT,CONDCR,CONINT,COPLOP
       XREF   CRDO,CSAVE,CSAVTK
       XREF   DATA,DCRNCH,DEVPRM,DLOAD,DOFDSP,DOSDSP,DRAW
       XREF   EDTENT,ELSETK,ENDCON,EOFFIN,EOFWRT,EQULTK
       XREF   ERPRNT,ERRID,ERROR,ERRUF,EVLADR
       XREF   FADD,FCERR,FDIV,FHALF,FINIT
       XREF   FINLOG,FINSAV,FMULT,FNDLIN,FNTK,FONE
       XREF   FOUT,FOUTCP,FPWRT,FREFAC,FRESTR,FRETMP,FRMEVL
       XREF   FRMNUM,FSUB,FUNDS1
       XREF   GET,GETADR,GETBYT,GETDNM,GETFLN,GETSPA
       XREF   GIVABF,GOGONE,GONE3,GOPTNW,GOTK
       XREF   HKASGN,HKCHRI,HKCHRO,HKCLS1,HKCRNC,HKERR,HKEVAL
       XREF   HKNWST,HKRENM,HKRUN
       XREF   INCHR,INIT,INLNDO,INPCOM,INPRT,INT,ISCNTC,ISDIGC,ISLETC
       XREF   LET,LINE,LINGET,LINPRT,LOADAD,LOFBUF
       XREF   MID$TK,MINUTK,ML1632,MLDVEX,MOVAF,MOV1F,MOVFA1,MOVFM
       XREF   MOVINS,MOVMF,MULDIV
       XREF   NEGOP,NORMAL
       XREF   OPNICK,OPNCSO,OPNOCK,OUTQST,OUTSPC,OVERR
       XREF   PAINT,PARCHK,PCLEAR,PCLS,PCOPY,PIA0BC,PIA0BD,PIA1BD
       XREF   PINIT,PLAY,PLYCLK,PMODE
       XREF   POLY,POLYX,PPOINT,PRESET,PSET,PTRGET,PTRGT2,PUT
       XREF   READY,RUNC
       XREF   SAM,SAMALP,SCREEN,SCRTCH,SETDNM,SIGN,SIN,SIN1,SNDOFF,SNERR
       XREF   SNGFLT,STRLTI,STRSPA,STRTAD,STKINI,STMDS1
       XREF   STRLT3,STROUT,STRPRT,STRTXT,STUB1,SUBTK,SYNCHR
       XREF   THENTK,TICKER,TOTK,TRMCHK
       XREF   ULERR,USRTAB,USRTK
       XREF   VIRQ
       XREF   WRTLDR
       XREF   ZEROF1

       TTL    Miscellanous Routines

*
* The RUN code comes here to set up the defaults for the PLAY
* and DRAW code.  The initialization code also comes here for
* the same reason.
*

       XDEF   XRRUN
XRRUN  LDD    #$B844   Init the PLAY arguments.
       STD    HIGHA    Set volume to 15 decimal.
       LDA    #&2      Set tempo to 2.
       STA    TEMPO
       STA    OCTAVE   Select middle C octave.
       ASLA            Set to undotted quarter notes.
       STA    LNOTE
       CLR    DOTFLG
       LDD    DBLZER   Init the DRAW arguments.
       STD    DRWANG   Set angle and scale to zero.
       LDB    #&128    Position to the middle.  (128,96) 
       STD    LSAVEX
       LDB    #&96
       STD    LSAVEY
RUNRTS RTS             Return to RUN or initialization code.

       TTL    CSAVEM Code

*
* CSAVEM <filename>,<first address>,<last address>,<execution address>
*

       XDEF   CSAVEM
CSAVEM JSR    CHRGET   Eat the "M" of CSAVEM.
       JSR    GETFLN   Scan the filename.
       BSR    STKXAD   Evaluate the first address.
       STX    LOADAD   Put it in the file header too.
       BSR    STKXAD   Evaluate the last address.
       CMPX   &2,S     Is last .GE. first?
       LBLO   FCERR    No, give FC error.
       BSR    STKXAD   Yes, evaluate the execution address
       STX    STRTAD   and put it in the file header block.
       JSR    CHRGOT   The statement must end now or we
       BNE    RUNRTS   to a RTS so NEWSTT will give a
*    syntax error.
CSMDOR LDA    #&2      File type is machine language.
       LDX    DBLZER   GAPFLG:=ASCFLG:=.FALSE.
       JSR    OPNCSO   Open cassette output file.
       CLR    CASOPN   Mark cassette as closed since
*    OPNCSO marked it as open.
       INC    BLKTYP   Set block type to data.
       JSR    WRTLDR   Turn on the cassette and write a
*    leader.

       LDX    &4,S     X:=first address.
CSAVML STX    CBUFAD   Set the buffer address to write the
*    next block out 
       LDA    #&255    Assume it's a full block.
       STA    BLKLEN
       LDD    &2,S     See how many more bytes to write.
       SUBD   CBUFAD
       BHS    MORSAV   There's more to save.
       LEAS   &6,S     Nothing more, clean up the stack
       JMP    FINSAV   and go close the file.

MORSAV CMPD   #&255    Is there a full block?
       BHS    BIGBLK   Yes.
       INCB            No be sure to get the last byte.
       STB    BLKLEN   Set actual block length.
BIGBLK JSR    BLKOUT   Write out the block.
       BRA    CSAVML   Go back for more.

       XDEF   STKXAD
STKXAD JSR    CHKCOM   Eat the comma.
       JSR    EVLADR   Evaluate address into X.
       LDU    ,S       U:=return address.
       STX    ,S       Stack the evaluated address.
       TFR    U,PC     Return with evaluated address on
*    the stack and in X.

        TTL   The FIX function.

*
* FIX(X) returns the truncated integer part of X.
* FIX(X) is equivalent to SGN(X)*INT(ABS(X)).
* FIX differs from INT in that FIX does not return the next lower
* integer for negative arguments.
*


       XDEF   FIX
FIX    JSR    SIGN     Is the number positive?
       BMI    FIXNEG   No.
GOINT  JMP    INT      Yes, just do normal INT function.

FIXNEG COM    FACSGN   Negate the argument.
       BSR    GOINT    Take the INT.
       JMP    NEGOP    Restore the original sign and return.
*    (Can't COM FACSGN, RTS since 0
*    would become -0. For example,
*    ?FIX(-.1) would print -0.)

       TTL    The EDIT Command

       XDEF   EDIT
EDIT   JSR    LINTRM   LINNUM:=number of line to EDIT.
*    (Line number must be terminated.)
       LEAS   &2,S     Get rid of the NEWSTT return address
*    since EDIT exits into the MAIN code.
EDITA  LDA    #&1      Set flag so line will be listed
       STA    EDTLST   prior to starting the edit.
       JSR    FNDLIN   X:=pointer to link field of line.
       LBCS   ULERR    If carry set then line doesn't exist.
       JSR    DCRNCH   Decrunch the line into BUF.
       TFR    Y,D      Calculate and store the line length.
       SUBD   #BUF+&1  (The zero byte terminator isn't
       STB    EDTLEN   included in the length.)

EDTPLN LDD    LINNUM   Print the line number followed
       JSR    LINPRT   by a space.
       JSR    OUTSPC
       LDX    #BUF     Point to the start of the line.
       LDB    EDTLST   Should the line be listed?
       BNE    ELSTIT   Yes, go do it

EDTSUB CLRB            Repetition count:=0.
EDTREP JSR    EDITIN   Get char - screen out bad ones.
       JSR    ISDIGC   Is it a digit?
       BCS    EDNTDG   No.
       SUBA   #'0      Its a digit, get  rid of ASCII offset.
       PSHS   A        Save the digit.
       LDA    #&10     Rep count:=rep count*10.
       MUL
       ADDB   ,S+      Add in the new digit.
       BRA    EDTREP   Look for more digits.

EDNTDG SUBB   #&1      If REP COUNT=0 then REP COUNT:=1.
       ADCB   #&1
       CMPA   #'A      EDIT again?
       BNE    EDITL    No.
       JSR    CRDO     Yes,  start new line
       BRA    EDITA    and  restart edit.

EDITL  CMPA   #'L      LIST AND CONTINUE EDIT?
       BNE    EDITCR   NO
ELSTIT BSR    EDTPRT   YES, PRINT REST OF LINE
       CLR    EDTLST   CLEAR LIST FLAG
       JSR    CRDO     START A NEW LINE
       BRA    EDTPLN   CONTINUE EDIT AT START OF LINE

CRINS  LEAS   &2,S     GET RID OF EDTSUB RETURN ADDRESS
EDITCR CMPA   #CR      CARRIAGE RETURN, LIST AND FINISH EDIT?
       BNE    EDITE    NO
       BSR    EDTPRT   YES, PRINT REST OF LINE
EDTEND JSR    CRDO     START A NEW LINE
AUTENT LDX    #BUF     SET TXTPTR FOR CRUNCH CODE
       STX    TXTPTR
       JMP    EDTENT   JUMP INTO "MAIN" CODE

EDITE  CMPA   #'E      END EDIT?
       BEQ    EDTEND   YES
       CMPA   #'Q      ABORT EDIT?
       BNE    NOTQ     NO
       JSR    CRDO     YES, START NEW LINE
       JMP    READY    AND ABORT EDIT
NOTQ   BSR    DOSUBC   ALL OTHER SUBCOMMANDS RETURN TO EDTSUB
       BRA    EDTSUB   TO GET NEXT SUBCOMMAND

DOSUBC CMPA   #'       MOVE CURSOR RIGHT?
       BNE    EDITD    NO
       SKIP2  JUST     PRINT [B] CHARS
       XDEF   EDTPRT
EDTPRT LDB    #MAXLEN  PRINT REST OF CHARS ON LINE
EPLOOP LDA    ,X       GET CURRENT CHAR
       BEQ    EPRTFN   IF END OF LINE THEN RETURN
       JSR    CHROUT   PRINT THE CHAR
       INX             BUMP EDIT POSITION
       DECB            DECREMENT REP COUNT
       BNE    EPLOOP   REPEAT AS NECESSARY
EPRTFN RTS

EDITD  CMPA   #'D      DELETE CHARS?
       BNE    EDITC    NO
DELLP  TST    ,X       AT END OF LINE?
       BEQ    EPRTFN   YES, NOTHING MORE TO DELETE
       BSR    DELCHR   NO, DELETE CURRENT CHAR
       DECB            REPEAT AS INDICATED
       BNE    DELLP
       RTS

DELCHR DEC    EDTLEN   DECREMENT LINE LENGTH
       LEAY   -&1,Y    ADJUST POINTER FOR preincrement.
CMPRSS LEAY   &1,Y     POINT TO NEXT CHAR
       LDA    &1,Y     MOVE CHARS DOWN A BYTE
       STA    ,Y
       BNE    CMPRSS   UNTIL END OF LINE IS REACHED
       RTS

CHKI   CMPA   #'I      INSERT CHARS?
       BEQ    EDITI    YES, GO DO IT
       CMPA   #'X      ADD CHARS TO END OF LINE?
       BEQ    EDITX    YES
       CMPA   #'H      HACK OFF REST OF LINE AND ADD CHARS?
       BNE    EDITCD   NO
       CLR    ,X       YES, LINE ENDS HERE
       TFR    X,D      Calculate and store the new line
       SUBD   #BUF+&1  length.
       STB    EDTLEN

EDITX  BSR    EDTPRT   PRINT REST OF LINE
EDITI  JSR    EDITIN   GET CHAR TO INSERT
       CMPA   #CR      CARRIAGE RETURN?
       BEQ    CRINS    YES, END INSERTION AND EDIT
       CMPA   #ESCAPE  ESCAPE?
       BEQ    CHGRTS   YES, ALL DONE INSERTING
       CMPA   #CHRDEL  CHARACTER DELETE?
       BNE    EDTINS   NO, GO INSERT THE CHAR
       CMPX   #BUF     IF AT START OF LINE IGNORE DELETE
       BEQ    EDITI    AND GET NEXT CHAR TO INSERT
       BSR    GOBACK   BACK UP THE CURSOR
       BSR    DELCHR   DELETE THE CHAR AND COMPRESS THE LINE
       BRA    EDITI    GO GET NEXT CHAR TO INSERT

EDITC  CMPA   #'C      CHANGE CHARACTERS?
       BNE    CHKI     NO
EDTCHG TST    ,X       AT END OF LINE?
       BEQ    CHGRTS   YES, NOTHING LEFT TO CHANGE
       JSR    EDITIN   GET CHAR TO REPLACE CURRENT CHAR
       BCS    OKCCHR   IF IT'S A CR, ESCAPE, OR CHRDEL
       BRA    EDTCHG   ignore  it.
OKCCHR STA    ,X+      OVERWRITE THE OLD CHAR
       BSR    GCHROT   ECHO THE NEW CHAR
       DECB            REPEAT
       BNE    EDTCHG
CHGRTS RTS


EDTINS LDB    EDTLEN   WILL LINE BE TOO LONG?
       CMPB   #MAXLEN
       BNE    OKINS    NO
       BRA    EDITI    Yes, wait for escape or CR.

OKINS  PSHS   X        SAVE EDIT POINTER
FNDEND TST    ,X+      FIND THE END OF THE LINE
       BNE    FNDEND
INSMOV LDB    ,-X      MAKE ROOM FOR THE NEW CHAR BY MOVING
       STB    &1,X     THE REST OF THE CHARS UP A BYTE
       CMPX   ,S       MOVE ALL INCLUDING CURRENT CHAR
       BNE    INSMOV
       LEAS   &2,S     Clean up the stack.
       STA    ,X+      PUT THE NEW CHAR INTO THE LINE
       BSR    GCHROT   ECHO THE NEW CHAR
       INC    EDTLEN   INCREMENT THE LENGTH
       BRA    EDITI    GET NEXT CHAR TO INSERT

EDITCD CMPA   #CHRDEL  CHARACTER DELETE?
       BNE    CHKK     NO
BACKB  BSR    GOBACK   Yes, output B backspaces.
       DECB
       BNE    BACKB
       RTS

GOBACK CMPX   #BUF     IF AT START OF LINE DO NOTHING
       BEQ    CHGRTS
       DEX             OTHERWISE BACK UP THE EDIT POINTER
*    AND BACK UP THE CURSOR
       IFEQ   REALIO
 ENDC  IFN    REALIO
BCKSPC LDA    #CHRDEL  Back up the cursor.
GCHROT JMP    CHROUT

CHKK   CMPA   #'K      KILL UNTIL MATCH FOUND?
       BEQ    EDITK    YES
       SUBA   #'S      SEARCH FOR CHAR?
       BEQ    EDITK    YES, USE SAME CODE AS K EXCEPT
*    ACCA IS CLEAR AS A FLAG NOT TO KILL
       RTS             Unrecognizable command, ignore it and
*    go get another one.
EDITK  PSHS   A        SAVE KILL FLAG
       BSR    EDITIN   GET SEARCH CHAR
       PSHS   A        PUT IT AWAY
EDTSRC LDA    ,X       END OF LINE?
       BEQ    SRCFIN   YES, GIVE UP SEARCH
       TST    &1,S     IF NOT KILLING THEN PRINT CHARS
       BNE    ISKILL   INSTEAD OF DELETING THEM
       BSR    GCHROT
       INX             POINT TO NEXT CHAR
       BRA    NOKILL
ISKILL JSR    DELCHR   DELETE THE CHAR
NOKILL LDA    ,X       DO THE CHARS MATCH?
       CMPA   ,S
       BNE    EDTSRC   NO, CONTINUE SEARCH
       DECB            YES, BUT MUST SEARCH REP COUNT TIMES
       BNE    EDTSRC
SRCFIN PULS   Y,PC     Clean up the stack and return.

EDITIN JSR    INCHR    GET A CHAR
       CMPA   #&127    THROW AWAY ALL BIGGER THAN TILDA.
       BCC    EDITIN
       CMPA   #@137    Translate shift uparrow key which
       BNE    NOTESC   generates a backarrow to an escape
       LDA    #ESCAPE  for compatibility with the TRS-80.
NOTESC CMPA   #CR      ADMIT LOW EXCEPTIONS
       BEQ    EDTINR
       CMPA   #ESCAPE
       BEQ    EDTINR
       CMPA   #CHRDEL
       BEQ    EDTINR
       CMPA   #'       ALL OTHERS BELOW SPACE ARE BAD
       BCS    EDITIN
EDTSEC SEC             SAY IT ISN'T A LOW EXCEPTION.
EDTINR RTS

       TTL    TRON and TROFF

*
* TRON turns on program tracing by setting TRCFLG to a nonzero
* value.  TRCFLG is checked at NEWSTT and if it is nonzero the
* line number of the line about to be executed is printed enclosed
* in square brackets.  TROFF turns off the program tracing by clearing
* TRCFLG.

       XDEF   TRON
TRON   FCB    @206     LDAIM CLRA opcode to make A nonzero
*    skip over the CLRA.
       XDEF   TROFF
TROFF  CLRA            Prepare to clear TRCFLG.
       STA    TRCFLG   Set or clear the trace flag.
TRORTS RTS

       TTL    The POS function.

*
* POS(<device number>) returns the print postion of the specified
* device.
*
* POS(0) returns the cursor column position.
* POS(-1), if the cassette is open for output, returns a meaningless
* result.  If the cassette is not  open a File Not Open error results.
* If the cassette is open for input, a Bad File Mode error results.
* POS(-2) returns the print position of the lineprinter.
*

       XDEF   POS
POS    LDA    DEVNUM   Preserve DEVNUM since this could be
       PSHS   A        a case such as PRINT #-1,POS(0).
       JSR    SETDNM   Convert and check the argument.
       JSR    OPNOCK   Make sure the device is open for
*    output.
       JSR    DEVPRM   Get the device parameters.
       LDB    DEVPOS   Get the position into B.
       PULS   A        Restore DEVNUM.
       STA    DEVNUM
       JMP    SNGFLT   Float the result and return.

       TTL    The VARPTR function.

*
* VARPTR(<variable name>) returns the address of the specified
*
