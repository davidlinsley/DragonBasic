       NAM    TXRGRP   - TANDY EXTENSION ROM GRAPHICS CODE

**********************************************************************
*                                                                    *
*    Copyright 1982 by Microsoft Corporation, all rights reserved    *
*                                                                    *
**********************************************************************

       TTL    Equates
CXMAX  EQU    &256
CYMAX  EQU    &192

SAM    EQU    @177700

       TTL    External Declarations

       XREF   ANDTK
       XREF   CHEADA,CHROUT,CLEARC,CONINT,CRDO
       XREF   EQULTK,EVLADR
       XREF   FCERR,FRESTR,FRMEVL
       XREF   GETADR,GETSTK
       XREF   HEXCNX,HKPTGT
       XREF   ILINE,INLIN,ISDIGC,ISLETC,ISVAR
       XREF   NEWSTT,NOTTK
       XREF   ORTK,OUTSPC
       XREF   PIA1AD,PIA1BD,PTRGET
       XREF   READY
       XREF   SCRTCH,SETSEL,SNDCLK,SNDOFF,SNDON,SNERR,SNGFLT
       XREF   STKINI,SYNCHR
       XREF   TOTK

GTMPB1 EQU    PDIRCT

       TTL    GRAPHICS CODE PSET,PRESET,LINE,PUT,GET,PPOINT
       XREF   MINUTK,FRMNUM,INPUTK,CHKCOM
       XREF   PSETTK,PRESTK,CHKOPN,CHKCLS,COMBYT
XLOW   EQU    XSTORE+&1
YLOW   EQU    YSTORE+&1

       XREF   GETBYT,GETNUM
*
* THE KEY SYSTEM DEPENDENT ROUTINES ARE THE FOLLOWING:
*  GTADRS - FETCH THE MEMORY ADDRESS OF THE POINT SPECIFIED IN
*  XSTORE AND YSTORE INTO [X] WITH A BIT MASK IN [A]
*  GINCY,GINCX -- INCREMENT X OR Y IN CHAR OR GRAPHIC MODE
*
*
* MEMORY HAS THE FOLLOWING KEY LOCATIONS:
* SCBASE LOW ADDRESS OF SCREEN
* SCTOP HIGH ADDRESS OF SCREEN
* SCMODE VALUE SHOWING CURRENT MODE
* RADIO SHACK HAS 5 GRAPHICS MODES
*  0 128X 96  BW  SCWID=16 ASPECT=1 MEM=1.5K
*  1 128X 96  C   SCWID=32 ASPECT=1 MEM=3K
*  2 128X192  BW  SCWID=16 ASPECT=2 MEM=3K
*  3 128X192  C   SCWID=32 ASPECT=2 MEM=6K
*  4 256X192  BW  SCWID=32 ASPECT=1 MEM=6K
* SCWID GIVING SCREEN WIDTH (16 OR 32)
* XSTORE IS THE 2 BYTE X VALUE
* YSTORE IS THE 2 BYTE Y VALUE
*
PTADRS LDU    #PTADRG  POINT AT ADDRESS TABLE
       LDA    SCMODE   GET THE SCREEN MODE
       ASLA            CONSTRUCT A TABLE INDEX
       LDU    A,U
FTRTS  RTS
GENADR BSR    PTADRS   GET ADDRESS IN [U]
       JMP    ,U

PTADRG FDB    GPUTMB
       FDB    GPUTMC
       FDB    GPUTMB
       FDB    GPUTMC
       FDB    GPUTMB

*
* IN BLACK AND WHITE MODE WE SELECT THE ADDRESS AS FOLLOWS:
*  [X] = SCBASE + Y*SCWID + INT (X/8)
*  [A] = 2 ^ ( 7 - ( X MOD 8 ) )
*
GPUTMB PSHS   B,U
       LDB    SCWID    GET BYTE SIZE OF EACH ROW
       LDA    YLOW     GET ROW COUNTER
       MUL             MULTIPLY
       ADDD   SCBASE   TURN INTO MEMORY SCREEN POINTER
       TFR    D,X      SAVE CURRENT SUM IN [X]
       LDB    XLOW     LOOK AT X
       LSRB            DIVIDED BY 8
       LSRB
       LSRB
       ABX             ADD ONTO SUM
       LDA    XLOW     LOOK AT X AGAIN TO GET BIT MASK
       ANDA   #&7      LOW THREE BITS ARE AN INDEX
       LDU    #BITTB1  INTO A POWER OF 2 TABLE
       LDA    A,U      FETCH BIT MASK FROM TABLE
       PULS   U,B,PC
*
* GRAPHICS ADDRESS SELECT IN COLOR MODE WORKS AS FOLLOWS:
*  [X] = SCBASE + Y*SCWID + INT (X/4)
*  [A] = 3 * ( 4 ^ ( 3 - ( X MOD 4 ) ) )
* SO BIT MASK HAS 2 BITS IN [A] AND ADDRESS IS IN [X]
*
GPUTMC PSHS   B,U
       LDB    SCWID    GET BYTE SIZE OF EACH ROW
       LDA    YLOW     GET ROW COUNTER
       MUL             MULTIPLY
       ADDD   SCBASE   TURN INTO MEMORY SCREEN POINTER
       TFR    D,X      SAVE CURRENT SUM IN [X]
       LDB    XLOW     LOOK AT X
       LSRB            DIVIDED BY 4
       LSRB
       ABX             ADD ON BYTE OFFSET FROM ROW
       LDA    XLOW     GET BACK X COUNT TO CONSTRUCT
       ANDA   #&3      BIT MASK
       LDU    #BITTB2  USE AS INDEX INTO BIT TABLE
       LDA    A,U      GET BIT MASK WITH 2 BITS FROM TABLE
       PULS   U,B,PC


BITTB1 FCB    &128     BACKWARDS BECAUSE OF THE WAY
       FCB    &64      GRAPHICS BITS ARE HANDLED
       FCB    &32
       FCB    &16
       FCB    &8
       FCB    &4
       FCB    &2
       FCB    &1

BITTB2 FCB    &192     MASK FOR COLOR GRAPHICS CASE
       FCB    &48      TWO  BITS PER PIXEL
       FCB    &12
       FCB    &3

*
* THESE ARE THE RELATIVE POSITION ROUTINES THAT MOVE
* UP ONE IN X OR Y
*
GINCY  LDB    SCWID
       ABX
       RTS
GINXB  LSRA            SHIFT BIT MASK TO THE RIGHT
       BCC    GIXRTS   IF NO CARRY THATS ALL
       RORA            SET HIGH BIT IN [A]
       LEAX   &1,X     UPDATE DISPLAY ADDRESS
GIXRTS RTS
GINXC  LSRA            MOVE OVER 1 BIT
       BCC    GINXB    JUST SHIFT ONE MORE IF NO CARRY
       LDA    #&192    SET UP FOR 2 LEFTMOST BITS
       LEAX   &1,X     UPDATE DISPLAY ADDRESS
       RTS


*
* THIS ROUTINE SCANS A POINT AT THE CURRENT TEXT POSITION INTO
* XSTORE AND YSTORE. THE RANGE IS COMPRESSED TO Y=0 TO CYMAX-1
* AND X=0 TO CXMAX-1
*
       XDEF   SCNPNT
SCNPNT JSR    GETNUM   SET X INTO POKER AND Y INTO [B]
       LDY    #XSTORE
SCNPN2 CMPB   #CYMAX   IS IT TOO BIG?
       BCS    SCNYNT
       LDB    #CYMAX—&1 SET MAXIMUM VALUE
SCNYNT CLRA            MAKE DOUBLE BYTE
       STD    &2,Y
       LDD    POKER    GET X VALUE
       CMPD   #CXMAX   SEE IF TOO BIG
       BCS    SVXRTS
       LDD    #CXMAX—&1
SVXRTS STD    ,Y
       RTS

*
* THIS SUBROUTINE TAKES THE VALUES IN XSTORE AND YSTORE AND
* ASSUMING THEY ARE GRAPHICS COORDINATES SCALES THEM BASED ON THE
* CURRENT GRAPHICS MODE.
* THIS ALLOWS ALL GRAPHICS COORDINATES TO BE DECLARED IN THE SPACE
* Y=0 TO CYMAX-1 AND X=0 TO CXMAX-1 SO MODE CHANGES DON'T REQUIRE PROGRAM
* CHANGES
* IN MODE0+1 X=X/2 Y=Y/2
* IN MODE2+3 X=X/2
* IN MODE4 NO CHANGE
*
GSCALR JSR    SCNPNT   SCAN VALUES OUT OF TEXT
GSCALE LDU    #XSTORE  POINT AT ARGUMENTS
GSCALC LDA    SCMODE   GET THE SCREEN MODE
       CMPA   #&2      SEE IF Y NEEDS TO BE ADJUSTED
       BCC    GSCNTY   NO GO HANDLE X
       LDD    &2,U     DIVIDE Y BY 2
       LSRA
       RORB
       STD    &2,U
GSCNTY LDA    SCMODE   NOW SEE IF X HAS TO BE SHIFTED

       CMPA   #&4      SEE IF ITS MODE 4
       BCC    SVURTS   ONLY MODE4 HAS X NON—SCALED
       LDD    ,U
       LSRA
       RORB            DO THE DIVIDE
       STD    ,U
SVURTS RTS


*
* PPOINT IS A FUNCTION TAKING (X,Y) AND RETURNING THE COLOR OF THE GRAPHICS
* BIT SET AT THAT LOCATION
*
       XDEF   PPOINT
PPOINT JSR    ONECRD   SCAN COORDINATE
       JSR    GSCALE   SCALE TO GRAPHICS RANGE
       JSR    GENADR   GET THE ADDRESS IN [X] AND BITS IN [A]
       ANDA   ,X       GET BIT RESULT INTO [A]
       LDB    SCMODE   SEE IF COLOR OR BLACK AND WHITE
       RORB
       BCC    PNTBW    POINT IN COLOR MODE IS SPECIAL
PNTCLP CMPA   #&4      ARE BITS IN RANGE?
       BCS    PNTCDN
       RORA
       RORA
       BRA    PNTCLP
PNTCDN INCA            MAP NON BLACK COLORS TO 1 TO 8
       ASLA
       ADDA   SCCSS    ADD IN COLOR SELECT TO GIVE ACTUAL COLOR
       LSRA
PNTRT1 TFR    A,B      RETURN RESULT IN [B]
PNTRT0 JMP    SNGFLT
PNTBW  TSTA            SEE IF POINT IS SET OR NOT
       BEQ    PNTRT1   RETURN ZERO FOR BLACK
       CLRA            OTHERWISE ITS GREEN OR CYAN
       BRA    PNTCDN
*
* PSET AND PRESET ARE STATEMENTS WHICH TAKE (X,Y,[,Z])
* AND AFFECT THE SELECTED POINT. Z IS THE ATTRIBUTE TO SET
* IF IT IS PRESENT.
*
       XDEF   PSET
PSET   LDA    #&1      INDICATE THIS IS A SET
       BRA    PSETCN
       XDEF   PRESET
PRESET CLRA
PSETCN STA    SETFLG   SET UP A FLAG FOR LATER USE
       JSR    CHKOPN
       JSR    GSCALR   GET THE ARGUMENT IN GRAPHICS MODE
       JSR    CMCOLR
       JSR    CHKCLS   MAKE SURE STATEMENT ENDED
       JSR    GENADR   GET [X] POINTING AT VALUE AND [A] AS MASK
GRPACT LDB    ,X       Remember the current contents of
       PSHS   B        the video memory.
       TFR    A,B      DUPLICATE BIT MASK
       COMA            FORM COMPLEMENT
       ANDA   ,X       AND BRING IN CURRENT DATA BITS
       ANDB   ACTCLE   AND BITS WITH CURRENT COLOR BITS
       PSHS   B        PUT [B] ON STACK TO OR TOGETHER
       ORA    ,S+      NEW COLOR BITS AND OLD DATA
       STA    ,X
       SUBA   ,S+      Set the change flag for PAINT if
       ORA    PNTCHF   the video memory was changed.
       STA    PNTCHF
       RTS

*
* SCAN A PAIR OF POINTS INTO XSTORE,YSTORE AND X2STOR,Y2STOR
*
       XDEF   CRDGET
CRDGET LDX    LSAVEX
       STX    XSTORE
       LDX    LSAVEY
       STX    YSTORE
       CMPA   #MINUTK  SEE IF DEFAULTING
       BEQ    CRDGT2
       JSR    ONECRD   READ ONE PAIR INTO XSTORE AND YSTORE
CRDGT2 SYNCHK MINUTK   SEPERATED BY A MINUS SIGN
       JSR    CHKOPN
       JSR    GETNUM   EVALUATE NUMBER
       LDY    #X2STOR  STORE VALUE INTO SECOND SET OF POINTS
       JSR    SCNPN2
       BRA    CHKCGO
*
* READ A COORDINATE SET WITH PARENS INTO XSTORE AND YSTORE
*
ONECRD JSR    CHKOPN
       JSR    SCNPNT
CHKCGO JMP    CHKCLS

*
* THIS IS THE GENERAL PURPOSE LINE ROUTINE
* FORMAT IS LINE(X1,Y1)-(X2,Y2), (PSET OR PRESET)
* OPTIONAL ,B (FOR BOX) OR ,BF (BOX FILL)
