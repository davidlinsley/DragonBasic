       NAM    TXRGRP   - TANDY EXTENSION ROM GRAPHICS CODE

**********************************************************************
*                                                                    *
*    Copyright 1982 by Microsoft Corporation, all rights reserved    *
*                                                                    *
**********************************************************************

       TTL    Equates
CXMAX  EQU    &256
CYMAX  EQU    &192

SAM    EQU    @177700

       TTL    External Declarations

       XREF   ANDTK
       XREF   CHEADA,CHROUT,CLEARC,CONINT,CRDO
       XREF   EQULTK,EVLADR
       XREF   FCERR,FRESTR,FRMEVL
       XREF   GETADR,GETSTK
       XREF   HEXCNX,HKPTGT
       XREF   ILINE,INLIN,ISDIGC,ISLETC,ISVAR
       XREF   NEWSTT,NOTTK
       XREF   ORTK,OUTSPC
       XREF   PIA1AD,PIA1BD,PTRGET
       XREF   READY
       XREF   SCRTCH,SETSEL,SNDCLK,SNDOFF,SNDON,SNERR,SNGFLT
       XREF   STKINI,SYNCHR
       XREF   TOTK

GTMPB1 EQU    PDIRCT

       TTL    GRAPHICS CODE PSET,PRESET,LINE,PUT,GET,PPOINT
       XREF   MINUTK,FRMNUM,INPUTK,CHKCOM
       XREF   PSETTK,PRESTK,CHKOPN,CHKCLS,COMBYT
XLOW   EQU    XSTORE+&1
YLOW   EQU    YSTORE+&1

       XREF   GETBYT,GETNUM
*
* THE KEY SYSTEM DEPENDENT ROUTINES ARE THE FOLLOWING:
*  GTADRS - FETCH THE MEMORY ADDRESS OF THE POINT SPECIFIED IN
*  XSTORE AND YSTORE INTO [X] WITH A BIT MASK IN [A]
*  GINCY,GINCX -- INCREMENT X OR Y IN CHAR OR GRAPHIC MODE
*
*
* MEMORY HAS THE FOLLOWING KEY LOCATIONS:
* SCBASE LOW ADDRESS OF SCREEN
* SCTOP HIGH ADDRESS OF SCREEN
* SCMODE VALUE SHOWING CURRENT MODE
* RADIO SHACK HAS 5 GRAPHICS MODES
*  0 128X 96  BW  SCWID=16 ASPECT=1 MEM=1.5K
*  1 128X 96  C   SCWID=32 ASPECT=1 MEM=3K
*  2 128X192  BW  SCWID=16 ASPECT=2 MEM=3K
*  3 128X192  C   SCWID=32 ASPECT=2 MEM=6K
*  4 256X192  BW  SCWID=32 ASPECT=1 MEM=6K
* SCWID GIVING SCREEN WIDTH (16 OR 32)
* XSTORE IS THE 2 BYTE X VALUE
* YSTORE IS THE 2 BYTE Y VALUE
*
PTADRS LDU    #PTADRG  POINT AT ADDRESS TABLE
       LDA    SCMODE   GET THE SCREEN MODE
       ASLA            CONSTRUCT A TABLE INDEX
       LDU    A,U
FTRTS  RTS
GENADR BSR    PTADRS   GET ADDRESS IN [U]
       JMP    ,U

PTADRG FDB    GPUTMB
       FDB    GPUTMC
       FDB    GPUTMB
       FDB    GPUTMC
       FDB    GPUTMB

*
* IN BLACK AND WHITE MODE WE SELECT THE ADDRESS AS FOLLOWS:
*  [X] = SCBASE + Y*SCWID + INT (X/8)
*  [A] = 2 ^ ( 7 - ( X MOD 8 ) )
*
GPUTMB PSHS   B,U
       LDB    SCWID    GET BYTE SIZE OF EACH ROW
       LDA    YLOW     GET ROW COUNTER
       MUL             MULTIPLY
       ADDD   SCBASE   TURN INTO MEMORY SCREEN POINTER
       TFR    D,X      SAVE CURRENT SUM IN [X]
       LDB    XLOW     LOOK AT X
       LSRB            DIVIDED BY 8
       LSRB
       LSRB
       ABX             ADD ONTO SUM
       LDA    XLOW     LOOK AT X AGAIN TO GET BIT MASK
       ANDA   #&7      LOW THREE BITS ARE AN INDEX
       LDU    #BITTB1  INTO A POWER OF 2 TABLE
       LDA    A,U      FETCH BIT MASK FROM TABLE
       PULS   U,B,PC
*
* GRAPHICS ADDRESS SELECT IN COLOR MODE WORKS AS FOLLOWS:
*  [X] = SCBASE + Y*SCWID + INT (X/4)
*  [A] = 3 * ( 4 ^ ( 3 - ( X MOD 4 ) ) )
* SO BIT MASK HAS 2 BITS IN [A] AND ADDRESS IS IN [X]
*
GPUTMC PSHS   B,U
       LDB    SCWID    GET BYTE SIZE OF EACH ROW
       LDA    YLOW     GET ROW COUNTER
       MUL             MULTIPLY
       ADDD   SCBASE   TURN INTO MEMORY SCREEN POINTER
       TFR    D,X      SAVE CURRENT SUM IN [X]
       LDB    XLOW     LOOK AT X
       LSRB            DIVIDED BY 4
       LSRB
       ABX             ADD ON BYTE OFFSET FROM ROW
       LDA    XLOW     GET BACK X COUNT TO CONSTRUCT
       ANDA   #&3      BIT MASK
       LDU    #BITTB2  USE AS INDEX INTO BIT TABLE
       LDA    A,U      GET BIT MASK WITH 2 BITS FROM TABLE
       PULS   U,B,PC


BITTB1 FCB    &128     BACKWARDS BECAUSE OF THE WAY
       FCB    &64      GRAPHICS BITS ARE HANDLED
       FCB    &32
       FCB    &16
       FCB    &8
       FCB    &4
       FCB    &2
       FCB    &1

BITTB2 FCB    &192     MASK FOR COLOR GRAPHICS CASE
       FCB    &48      TWO  BITS PER PIXEL
       FCB    &12
       FCB    &3

*
* THESE ARE THE RELATIVE POSITION ROUTINES THAT MOVE
* UP ONE IN X OR Y
*
GINCY  LDB    SCWID
       ABX
       RTS
GINXB  LSRA            SHIFT BIT MASK TO THE RIGHT
       BCC    GIXRTS   IF NO CARRY THATS ALL
       RORA            SET HIGH BIT IN [A]
       LEAX   &1,X     UPDATE DISPLAY ADDRESS
GIXRTS RTS
GINXC  LSRA            MOVE OVER 1 BIT
       BCC    GINXB    JUST SHIFT ONE MORE IF NO CARRY
       LDA    #&192    SET UP FOR 2 LEFTMOST BITS
       LEAX   &1,X     UPDATE DISPLAY ADDRESS
       RTS


*
* THIS ROUTINE SCANS A POINT AT THE CURRENT TEXT POSITION INTO
* XSTORE AND YSTORE. THE RANGE IS COMPRESSED TO Y=0 TO CYMAX-1
* AND X=0 TO CXMAX-1
*
       XDEF   SCNPNT
SCNPNT JSR    GETNUM   SET X INTO POKER AND Y INTO [B]
       LDY    #XSTORE
SCNPN2 CMPB   #CYMAX   IS IT TOO BIG?
       BCS    SCNYNT
       LDB    #CYMAX—&1 SET MAXIMUM VALUE
SCNYNT CLRA            MAKE DOUBLE BYTE
       STD    &2,Y
       LDD    POKER    GET X VALUE
       CMPD   #CXMAX   SEE IF TOO BIG
       BCS    SVXRTS
       LDD    #CXMAX—&1
SVXRTS STD    ,Y
       RTS

*
* THIS SUBROUTINE TAKES THE VALUES IN XSTORE AND YSTORE AND
* ASSUMING THEY ARE GRAPHICS COORDINATES SCALES THEM BASED ON THE
* CURRENT GRAPHICS MODE.
* THIS ALLOWS ALL GRAPHICS COORDINATES TO BE DECLARED IN THE SPACE
* Y=0 TO CYMAX-1 AND X=0 TO CXMAX-1 SO MODE CHANGES DON'T REQUIRE PROGRAM
* CHANGES
* IN MODE0+1 X=X/2 Y=Y/2
* IN MODE2+3 X=X/2
* IN MODE4 NO CHANGE
*
GSCALR JSR    SCNPNT   SCAN VALUES OUT OF TEXT
GSCALE LDU    #XSTORE  POINT AT ARGUMENTS
GSCALC LDA    SCMODE   GET THE SCREEN MODE
       CMPA   #&2      SEE IF Y NEEDS TO BE ADJUSTED
       BCC    GSCNTY   NO GO HANDLE X
       LDD    &2,U     DIVIDE Y BY 2
       LSRA
       RORB
       STD    &2,U
GSCNTY LDA    SCMODE   NOW SEE IF X HAS TO BE SHIFTED

       CMPA   #&4      SEE IF ITS MODE 4
       BCC    SVURTS   ONLY MODE4 HAS X NON—SCALED
       LDD    ,U
       LSRA
       RORB            DO THE DIVIDE
       STD    ,U
SVURTS RTS


*
* PPOINT IS A FUNCTION TAKING (X,Y) AND RETURNING THE COLOR OF THE GRAPHICS
* BIT SET AT THAT LOCATION
*
       XDEF   PPOINT
PPOINT JSR    ONECRD   SCAN COORDINATE
       JSR    GSCALE   SCALE TO GRAPHICS RANGE
       JSR    GENADR   GET THE ADDRESS IN [X] AND BITS IN [A]
       ANDA   ,X       GET BIT RESULT INTO [A]
       LDB    SCMODE   SEE IF COLOR OR BLACK AND WHITE
       RORB
       BCC    PNTBW    POINT IN COLOR MODE IS SPECIAL
PNTCLP CMPA   #&4      ARE BITS IN RANGE?
       BCS    PNTCDN
       RORA
       RORA
       BRA    PNTCLP
PNTCDN INCA            MAP NON BLACK COLORS TO 1 TO 8
       ASLA
       ADDA   SCCSS    ADD IN COLOR SELECT TO GIVE ACTUAL COLOR
       LSRA
PNTRT1 TFR    A,B      RETURN RESULT IN [B]
PNTRT0 JMP    SNGFLT
PNTBW  TSTA            SEE IF POINT IS SET OR NOT
       BEQ    PNTRT1   RETURN ZERO FOR BLACK
       CLRA            OTHERWISE ITS GREEN OR CYAN
       BRA    PNTCDN
*
* PSET AND PRESET ARE STATEMENTS WHICH TAKE (X,Y,[,Z])
* AND AFFECT THE SELECTED POINT. Z IS THE ATTRIBUTE TO SET
* IF IT IS PRESENT.
*
       XDEF   PSET
PSET   LDA    #&1      INDICATE THIS IS A SET
       BRA    PSETCN
       XDEF   PRESET
PRESET CLRA
PSETCN STA    SETFLG   SET UP A FLAG FOR LATER USE
       JSR    CHKOPN
       JSR    GSCALR   GET THE ARGUMENT IN GRAPHICS MODE
       JSR    CMCOLR
       JSR    CHKCLS   MAKE SURE STATEMENT ENDED
       JSR    GENADR   GET [X] POINTING AT VALUE AND [A] AS MASK
GRPACT LDB    ,X       Remember the current contents of
       PSHS   B        the video memory.
       TFR    A,B      DUPLICATE BIT MASK
       COMA            FORM COMPLEMENT
       ANDA   ,X       AND BRING IN CURRENT DATA BITS
       ANDB   ACTCLE   AND BITS WITH CURRENT COLOR BITS
       PSHS   B        PUT [B] ON STACK TO OR TOGETHER
       ORA    ,S+      NEW COLOR BITS AND OLD DATA
       STA    ,X
       SUBA   ,S+      Set the change flag for PAINT if
       ORA    PNTCHF   the video memory was changed.
       STA    PNTCHF
       RTS

*
* SCAN A PAIR OF POINTS INTO XSTORE,YSTORE AND X2STOR,Y2STOR
*
       XDEF   CRDGET
CRDGET LDX    LSAVEX
       STX    XSTORE
       LDX    LSAVEY
       STX    YSTORE
       CMPA   #MINUTK  SEE IF DEFAULTING
       BEQ    CRDGT2
       JSR    ONECRD   READ ONE PAIR INTO XSTORE AND YSTORE
CRDGT2 SYNCHK MINUTK   SEPERATED BY A MINUS SIGN
       JSR    CHKOPN
       JSR    GETNUM   EVALUATE NUMBER
       LDY    #X2STOR  STORE VALUE INTO SECOND SET OF POINTS
       JSR    SCNPN2
       BRA    CHKCGO
*
* READ A COORDINATE SET WITH PARENS INTO XSTORE AND YSTORE
*
ONECRD JSR    CHKOPN
       JSR    SCNPNT
CHKCGO JMP    CHKCLS

*
* THIS IS THE GENERAL PURPOSE LINE ROUTINE
* FORMAT IS LINE(X1,Y1)-(X2,Y2), (PSET OR PRESET)
* OPTIONAL ,B (FOR BOX) OR ,BF (BOX FILL)
*
* IDEA IS TO SCAN COORDINATES INTO (XSTORE,YSTORE) AND (X2STOR,Y2STOR)
* AND USE SETFLG TO DISTINGUISH THE GRAPHICS OR CHAR AND PSET OR PRESET
*
       XDEF   LINE
LINE   CMPA   #INPUTK  FUNCTION NAME LIKE "INPUT"
       LBEQ   ILINE
       CMPA   #OPNPAR
       BEQ    GLINEC   DON'T REQUIRE @ LIKE NEC VERSION
       CMPA   #MINUTK
       BEQ    GLINEC   ALLOW DEFAULT OF FIRST COORDINATE
       SYNCHK '@       SKIP @ THAT MUST BE THERE
GLINEC JSR    CRDGET   SCAN THE COORDINATES
       LDX    X2STOR   SAVE SECOND COORDINATE FOR REUSE WITH -
       STX    LSAVEX
       LDX    Y2STOR
       STX    LSAVEY
       JSR    CHKCOM
       CMPA   #PRESTK  IS IT PRESET?
       BEQ    GRLINR
       CMPA   #PSETTK
       LBNE   SNERR
GRLINS LDB    #&1      FLAG FOR PSET
       SKIP1
GRLINR CLRB            FLAG FOR PRESET
       PSHS   B        SAVE THE FLAG
       JSR    CHRGET   SKIP OVER PSET OR PRESET
       JSR    GSCAL2   GRAPHICS SCALE BOTH POINTS
       PULS   B        GET BACK THE FLAG
LINCN2 STB    SETFLG   FLAG IS 1PSET,0PRESET
       JSR    DEFCOL   SET UP DEFAULT COLOR
       JSR    CHRGOT   REGET THE LAST CHAR
       LBEQ   LINGEN   JUST LINE
       JSR    CHKCOM   MUST HAVE ATTRIBUTE
       SYNCHK 'B       MUST HAVE B FOR BOX
       BNE    LINBXF   IF CONTINUES MUST BE BOX FILL
       BSR    XLINE    DRAW THE BOX
       BSR    YLINE
       LDX    XSTORE
       PSHS   X        SAVE XSTORE FOR LAST LINE
       LDX    X2STOR   OVERWRITE FOR BOTTOM LINE
       STX    XSTORE
       BSR    YLINE
       PULS   X        GET BACK XSTORE
       STX    XSTORE
       LDX    Y2STOR   DRAW BOTTOM LINE
       STX    YSTORE
       BRA    XLINE

*
* SET UP GRAPHICS LINE BY SCALING COORDINATES AND SETTING FLAG
*
GSCAL2 JSR    GSCALE   SCALE FIRST COORDINATE
       LDU    #X2STOR  POINT AT SECOND COORDINATES
       JMP    GSCALC   AND SCALE THEM

LINBXF SYNCHK 'F       THIS IS LINE BOX FILL
       BRA    LINBXS   JUMP INTO THE LOOP
LINBXD LEAX   -&1,X    DECREMENT Y COORDINATE
LINBXL STX    YSTORE   UPDATE Y COORDINATE
LINBXS JSR    XLINE    DRAW THE XLINE
       LDX    YSTORE   SEE HOW WE COMPARE WITH Y2STOR
       CMPX   Y2STOR
       BEQ    LINRTS   ALL DONE WHEN MATCH
       BCC    LINBXD   YSTORE IS BIGGER SO DECREMENT IT
       LEAX   &1,X     YSTORE IS SMALLER SO INCREMENT IT
       BRA    LINBXL

LINRTS RTS


*
* DRAW A LINE FROM XSTORE,YSTORE TO X2STOR,YSTORE
*
XLINE  LDX    XSTORE   GET X1 COORDINATE
       PSHS   X        SAVE IT FOR CALLER
       JSR    XDELTS
       BCC    XLNXFR   [D] HAS COUNT IF NO CARRY SO GO
       LDX    X2STOR   ALWAYS INCREMENT SO MAKE XSTORE SMALLER
       STX    XSTORE
XLNXFR TFR    D,Y      PUT COUNT IN [Y]
       LEAY   &1,Y     OFFSET BY ONE
       JSR    GENADR   GET ADDRESS AND BIT MASK FOR START
       PULS   U        GET BACK XSTORE
       STU    XSTORE
       BSR    XADRI    MAKE U ADDRESS OF INCREMENT ROUTINE
XLNLOP STA    GTMPB1   SAVE THE BIT MASK
       JSR    GRPACT   ACTUALLY PERFORM ACTION (SET RESET OR PUT CHR)
       LDA    GTMPB1   GET BACK THE BIT MASK
       JSR    ,U       GO OFF TO INCREMENT ROUTINE
       LEAY   -&1,Y    DECREMENT THE COUNT
       BNE    XLNLOP   ITERATE WITH ACTION
       RTS

*
* YLINE DRAWS FROM XSTORE,YSTORE TO XSTORE,Y2STOR
*
DYLINE PULS   D        ENTRY FROM GENERAL LINE DRAW ROUTINE
*    CLEAN OFF THE STACK

       XDEF   YLINE
YLINE  LDD    YSTORE   GET Y COORDINATE
       PSHS   D        SAVE TO RESTORE
       JSR    YDELTS
       BCC    YLNXFR
       LDX    Y2STOR
       STX    YSTORE
YLNXFR TFR    D,Y
       LEAY   &1,Y
       JSR    GENADR
       PULS   U
       STU    YSTORE
       BSR    YADRI    MAKE U A ROUTINE TO INCREMENT Y
       BRA    XLNLOP

*
