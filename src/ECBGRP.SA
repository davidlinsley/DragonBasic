       NAM    TXRGRP   - TANDY EXTENSION ROM GRAPHICS CODE

**********************************************************************
*                                                                    *
*    Copyright 1982 by Microsoft Corporation, all rights reserved    *
*                                                                    *
**********************************************************************

       TTL    Equates
CXMAX  EQU    &256
CYMAX  EQU    &192

SAM    EQU    @177700

       TTL    External Declarations

       XREF   ANDTK
       XREF   CHEADA,CHROUT,CLEARC,CONINT,CRDO
       XREF   EQULTK,EVLADR
       XREF   FCERR,FRESTR,FRMEVL
       XREF   GETADR,GETSTK
       XREF   HEXCNX,HKPTGT
       XREF   ILINE,INLIN,ISDIGC,ISLETC,ISVAR
       XREF   NEWSTT,NOTTK
       XREF   ORTK,OUTSPC
       XREF   PIA1AD,PIA1BD,PTRGET
       XREF   READY
       XREF   SCRTCH,SETSEL,SNDCLK,SNDOFF,SNDON,SNERR,SNGFLT
       XREF   STKINI,SYNCHR
       XREF   TOTK

GTMPB1 EQU    PDIRCT

       TTL    GRAPHICS CODE PSET,PRESET,LINE,PUT,GET,PPOINT
       XREF   MINUTK,FRMNUM,INPUTK,CHKCOM
       XREF   PSETTK,PRESTK,CHKOPN,CHKCLS,COMBYT
XLOW   EQU    XSTORE+&1
YLOW   EQU    YSTORE+&1

       XREF   GETBYT,GETNUM
*
* THE KEY SYSTEM DEPENDENT ROUTINES ARE THE FOLLOWING:
*  GTADRS - FETCH THE MEMORY ADDRESS OF THE POINT SPECIFIED IN
*  XSTORE AND YSTORE INTO [X] WITH A BIT MASK IN [A]
*  GINCY,GINCX -- INCREMENT X OR Y IN CHAR OR GRAPHIC MODE
*
*
* MEMORY HAS THE FOLLOWING KEY LOCATIONS:
* SCBASE LOW ADDRESS OF SCREEN
* SCTOP HIGH ADDRESS OF SCREEN
* SCMODE VALUE SHOWING CURRENT MODE
* RADIO SHACK HAS 5 GRAPHICS MODES
*  0 128X 96  BW  SCWID=16 ASPECT=1 MEM=1.5K
*  1 128X 96  C   SCWID=32 ASPECT=1 MEM=3K
*  2 128X192  BW  SCWID=16 ASPECT=2 MEM=3K
*  3 128X192  C   SCWID=32 ASPECT=2 MEM=6K
*  4 256X192  BW  SCWID=32 ASPECT=1 MEM=6K
* SCWID GIVING SCREEN WIDTH (16 OR 32)
* XSTORE IS THE 2 BYTE X VALUE
* YSTORE IS THE 2 BYTE Y VALUE
*
PTADRS LDU    #PTADRG  POINT AT ADDRESS TABLE
       LDA    SCMODE   GET THE SCREEN MODE
       ASLA            CONSTRUCT A TABLE INDEX
       LDU    A,U
FTRTS  RTS
GENADR BSR    PTADRS   GET ADDRESS IN [U]
       JMP    ,U

PTADRG FDB    GPUTMB
       FDB    GPUTMC
       FDB    GPUTMB
       FDB    GPUTMC
       FDB    GPUTMB

*
* IN BLACK AND WHITE MODE WE SELECT THE ADDRESS AS FOLLOWS:
*  [X] = SCBASE + Y*SCWID + INT (X/8)
*  [A] = 2 ^ ( 7 - ( X MOD 8 ) )
*
GPUTMB PSHS   B,U
       LDB    SCWID    GET BYTE SIZE OF EACH ROW
       LDA    YLOW     GET ROW COUNTER
       MUL             MULTIPLY
       ADDD   SCBASE   TURN INTO MEMORY SCREEN POINTER
       TFR    D,X      SAVE CURRENT SUM IN [X]
       LDB    XLOW     LOOK AT X
       LSRB            DIVIDED BY 8
       LSRB
       LSRB
       ABX             ADD ONTO SUM
       LDA    XLOW     LOOK AT X AGAIN TO GET BIT MASK
       ANDA   #&7      LOW THREE BITS ARE AN INDEX
       LDU    #BITTB1  INTO A POWER OF 2 TABLE
       LDA    A,U      FETCH BIT MASK FROM TABLE
       PULS   U,B,PC
*
* GRAPHICS ADDRESS SELECT IN COLOR MODE WORKS AS FOLLOWS:
*  [X] = SCBASE + Y*SCWID + INT (X/4)
*  [A] = 3 * ( 4 ^ ( 3 - ( X MOD 4 ) ) )
* SO BIT MASK HAS 2 BITS IN [A] AND ADDRESS IS IN [X]
*
GPUTMC PSHS   B,U
       LDB    SCWID    GET BYTE SIZE OF EACH ROW
       LDA    YLOW     GET ROW COUNTER
       MUL             MULTIPLY
       ADDD   SCBASE   TURN INTO MEMORY SCREEN POINTER
       TFR    D,X      SAVE CURRENT SUM IN [X]
       LDB    XLOW     LOOK AT X
       LSRB            DIVIDED BY 4
       LSRB
       ABX             ADD ON BYTE OFFSET FROM ROW
       LDA    XLOW     GET BACK X COUNT TO CONSTRUCT
       ANDA   #&3      BIT MASK
       LDU    #BITTB2  USE AS INDEX INTO BIT TABLE
       LDA    A,U      GET BIT MASK WITH 2 BITS FROM TABLE
       PULS   U,B,PC


BITTB1 FCB    &128     BACKWARDS BECAUSE OF THE WAY
       FCB    &64      GRAPHICS BITS ARE HANDLED
       FCB    &32
       FCB    &16
       FCB    &8
       FCB    &4
       FCB    &2
       FCB    &1

BITTB2 FCB    &192     MASK FOR COLOR GRAPHICS CASE
       FCB    &48      TWO  BITS PER PIXEL
       FCB    &12
       FCB    &3

*
* THESE ARE THE RELATIVE POSITION ROUTINES THAT MOVE
* UP ONE IN X OR Y
*
GINCY  LDB    SCWID
       ABX
       RTS
GINXB  LSRA            SHIFT BIT MASK TO THE RIGHT
       BCC    GIXRTS   IF NO CARRY THATS ALL
       RORA            SET HIGH BIT IN [A]
       LEAX   &1,X     UPDATE DISPLAY ADDRESS
GIXRTS RTS
GINXC  LSRA            MOVE OVER 1 BIT
       BCC    GINXB    JUST SHIFT ONE MORE IF NO CARRY
       LDA    #&192    SET UP FOR 2 LEFTMOST BITS
       LEAX   &1,X     UPDATE DISPLAY ADDRESS
       RTS


*
* THIS ROUTINE SCANS A POINT AT THE CURRENT TEXT POSITION INTO
* XSTORE AND YSTORE. THE RANGE IS COMPRESSED TO Y=0 TO CYMAX-1
* AND X=0 TO CXMAX-1
*
       XDEF   SCNPNT
SCNPNT JSR    GETNUM   SET X INTO POKER AND Y INTO [B]
       LDY    #XSTORE
SCNPN2 CMPB   #CYMAX   IS IT TOO BIG?
       BCS    SCNYNT
       LDB    #CYMAX—&1 SET MAXIMUM VALUE
SCNYNT CLRA            MAKE DOUBLE BYTE
       STD    &2,Y
       LDD    POKER    GET X VALUE
       CMPD   #CXMAX   SEE IF TOO BIG
       BCS    SVXRTS
       LDD    #CXMAX—&1
SVXRTS STD    ,Y
       RTS

*
