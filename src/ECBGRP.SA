       NAM    TXRGRP   - TANDY EXTENSION ROM GRAPHICS CODE

**********************************************************************
*                                                                    *
*    Copyright 1982 by Microsoft Corporation, all rights reserved    *
*                                                                    *
**********************************************************************

       TTL    Equates
CXMAX  EQU    &256
CYMAX  EQU    &192

SAM    EQU    @177700

       TTL    External Declarations

       XREF   ANDTK
       XREF   CHEADA,CHROUT,CLEARC,CONINT,CRDO
       XREF   EQULTK,EVLADR
       XREF   FCERR,FRESTR,FRMEVL
       XREF   GETADR,GETSTK
       XREF   HEXCNX,HKPTGT
       XREF   ILINE,INLIN,ISDIGC,ISLETC,ISVAR
       XREF   NEWSTT,NOTTK
       XREF   ORTK,OUTSPC
       XREF   PIA1AD,PIA1BD,PTRGET
       XREF   READY
       XREF   SCRTCH,SETSEL,SNDCLK,SNDOFF,SNDON,SNERR,SNGFLT
       XREF   STKINI,SYNCHR
       XREF   TOTK

GTMPB1 EQU    PDIRCT

       TTL    GRAPHICS CODE PSET,PRESET,LINE,PUT,GET,PPOINT
       XREF   MINUTK,FRMNUM,INPUTK,CHKCOM
       XREF   PSETTK,PRESTK,CHKOPN,CHKCLS,COMBYT
XLOW   EQU    XSTORE+&1
YLOW   EQU    YSTORE+&1

       XREF   GETBYT,GETNUM
*
* THE KEY SYSTEM DEPENDENT ROUTINES ARE THE FOLLOWING:
*  GTADRS - FETCH THE MEMORY ADDRESS OF THE POINT SPECIFIED IN
*  XSTORE AND YSTORE INTO [X] WITH A BIT MASK IN [A]
*  GINCY,GINCX -- INCREMENT X OR Y IN CHAR OR GRAPHIC MODE
*
*
* MEMORY HAS THE FOLLOWING KEY LOCATIONS:
* SCBASE LOW ADDRESS OF SCREEN
* SCTOP HIGH ADDRESS OF SCREEN
* SCMODE VALUE SHOWING CURRENT MODE
* RADIO SHACK HAS 5 GRAPHICS MODES
*  0 128X 96  BW  SCWID=16 ASPECT=1 MEM=1.5K
*  1 128X 96  C   SCWID=32 ASPECT=1 MEM=3K
*  2 128X192  BW  SCWID=16 ASPECT=2 MEM=3K
*  3 128X192  C   SCWID=32 ASPECT=2 MEM=6K
*  4 256X192  BW  SCWID=32 ASPECT=1 MEM=6K
* SCWID GIVING SCREEN WIDTH (16 OR 32)
* XSTORE IS THE 2 BYTE X VALUE
* YSTORE IS THE 2 BYTE Y VALUE
*
PTADRS LDU    #PTADRG  POINT AT ADDRESS TABLE
       LDA    SCMODE   GET THE SCREEN MODE
       ASLA            CONSTRUCT A TABLE INDEX
       LDU    A,U
FTRTS  RTS
GENADR BSR    PTADRS   GET ADDRESS IN [U]
       JMP    ,U

PTADRG FDB    GPUTMB
       FDB    GPUTMC
       FDB    GPUTMB
       FDB    GPUTMC
       FDB    GPUTMB

*
* IN BLACK AND WHITE MODE WE SELECT THE ADDRESS AS FOLLOWS:
*  [X] = SCBASE + Y*SCWID + INT (X/8)
*  [A] = 2 ^ ( 7 - ( X MOD 8 ) )
*
GPUTMB PSHS   B,U
       LDB    SCWID    GET BYTE SIZE OF EACH ROW
       LDA    YLOW     GET ROW COUNTER
       MUL             MULTIPLY
       ADDD   SCBASE   TURN INTO MEMORY SCREEN POINTER
       TFR    D,X      SAVE CURRENT SUM IN [X]
       LDB    XLOW     LOOK AT X
       LSRB            DIVIDED BY 8
       LSRB
       LSRB
       ABX             ADD ONTO SUM
       LDA    XLOW     LOOK AT X AGAIN TO GET BIT MASK
       ANDA   #&7      LOW THREE BITS ARE AN INDEX
       LDU    #BITTB1  INTO A POWER OF 2 TABLE
       LDA    A,U      FETCH BIT MASK FROM TABLE
       PULS   U,B,PC
*
* GRAPHICS ADDRESS SELECT IN COLOR MODE WORKS AS FOLLOWS:
*  [X] = SCBASE + Y*SCWID + INT (X/4)
*  [A] = 3 * ( 4 ^ ( 3 - ( X MOD 4 ) ) )
* SO BIT MASK HAS 2 BITS IN [A] AND ADDRESS IS IN [X]
*
GPUTMC PSHS   B,U
       LDB    SCWID    GET BYTE SIZE OF EACH ROW
       LDA    YLOW     GET ROW COUNTER
       MUL             MULTIPLY
       ADDD   SCBASE   TURN INTO MEMORY SCREEN POINTER
       TFR    D,X      SAVE CURRENT SUM IN [X]
       LDB    XLOW     LOOK AT X
       LSRB            DIVIDED BY 4
       LSRB
       ABX             ADD ON BYTE OFFSET FROM ROW
       LDA    XLOW     GET BACK X COUNT TO CONSTRUCT
       ANDA   #&3      BIT MASK
       LDU    #BITTB2  USE AS INDEX INTO BIT TABLE
