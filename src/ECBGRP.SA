       NAM    TXRGRP   - TANDY EXTENSION ROM GRAPHICS CODE

**********************************************************************
*                                                                    *
*    Copyright 1982 by Microsoft Corporation, all rights reserved    *
*                                                                    *
**********************************************************************

       TTL    Equates
CXMAX  EQU    &256
CYMAX  EQU    &192

SAM    EQU    @177700

       TTL    External Declarations

       XREF   ANDTK
       XREF   CHEADA,CHROUT,CLEARC,CONINT,CRDO
       XREF   EQULTK,EVLADR
       XREF   FCERR,FRESTR,FRMEVL
       XREF   GETADR,GETSTK
       XREF   HEXCNX,HKPTGT
       XREF   ILINE,INLIN,ISDIGC,ISLETC,ISVAR
       XREF   NEWSTT,NOTTK
       XREF   ORTK,OUTSPC
       XREF   PIA1AD,PIA1BD,PTRGET
       XREF   READY
       XREF   SCRTCH,SETSEL,SNDCLK,SNDOFF,SNDON,SNERR,SNGFLT
       XREF   STKINI,SYNCHR
       XREF   TOTK

GTMPB1 EQU    PDIRCT

       TTL    GRAPHICS CODE PSET,PRESET,LINE,PUT,GET,PPOINT
       XREF   MINUTK,FRMNUM,INPUTK,CHKCOM
       XREF   PSETTK,PRESTK,CHKOPN,CHKCLS,COMBYT
XLOW   EQU    XSTORE+&1
YLOW   EQU    YSTORE+&1

       XREF   GETBYT,GETNUM
*
* THE KEY SYSTEM DEPENDENT ROUTINES ARE THE FOLLOWING:
*  GTADRS - FETCH THE MEMORY ADDRESS OF THE POINT SPECIFIED IN
*  XSTORE AND YSTORE INTO [X] WITH A BIT MASK IN [A]
*  GINCY,GINCX -- INCREMENT X OR Y IN CHAR OR GRAPHIC MODE
*
*
* MEMORY HAS THE FOLLOWING KEY LOCATIONS:
* SCBASE LOW ADDRESS OF SCREEN
* SCTOP HIGH ADDRESS OF SCREEN
* SCMODE VALUE SHOWING CURRENT MODE
* RADIO SHACK HAS 5 GRAPHICS MODES
*  0 128X 96  BW  SCWID=16 ASPECT=1 MEM=1.5K
*  1 128X 96  C   SCWID=32 ASPECT=1 MEM=3K
*  2 128X192  BW  SCWID=16 ASPECT=2 MEM=3K
*  3 128X192  C   SCWID=32 ASPECT=2 MEM=6K
*  4 256X192  BW  SCWID=32 ASPECT=1 MEM=6K
* SCWID GIVING SCREEN WIDTH (16 OR 32)
* XSTORE IS THE 2 BYTE X VALUE
* YSTORE IS THE 2 BYTE Y VALUE
*
PTADRS LDU    #PTADRG  POINT AT ADDRESS TABLE
       LDA    SCMODE   GET THE SCREEN MODE
       ASLA            CONSTRUCT A TABLE INDEX
       LDU    A,U
FTRTS  RTS
GENADR BSR    PTADRS   GET ADDRESS IN [U]
       JMP    ,U

PTADRG FDB    GPUTMB
       FDB    GPUTMC
       FDB    GPUTMB
       FDB    GPUTMC
       FDB    GPUTMB

*
* IN BLACK AND WHITE MODE WE SELECT THE ADDRESS AS FOLLOWS:
*  [X] = SCBASE + Y*SCWID + INT (X/8)
*  [A] = 2 ^ ( 7 - ( X MOD 8 ) )
*
GPUTMB PSHS   B,U
       LDB    SCWID    GET BYTE SIZE OF EACH ROW
       LDA    YLOW     GET ROW COUNTER
       MUL             MULTIPLY
       ADDD   SCBASE   TURN INTO MEMORY SCREEN POINTER
       TFR    D,X      SAVE CURRENT SUM IN [X]
       LDB    XLOW     LOOK AT X
       LSRB            DIVIDED BY 8
       LSRB
       LSRB
       ABX             ADD ONTO SUM
       LDA    XLOW     LOOK AT X AGAIN TO GET BIT MASK
       ANDA   #&7      LOW THREE BITS ARE AN INDEX
       LDU    #BITTB1  INTO A POWER OF 2 TABLE
       LDA    A,U      FETCH BIT MASK FROM TABLE
       PULS   U,B,PC
*
* GRAPHICS ADDRESS SELECT IN COLOR MODE WORKS AS FOLLOWS:
*  [X] = SCBASE + Y*SCWID + INT (X/4)
*  [A] = 3 * ( 4 ^ ( 3 - ( X MOD 4 ) ) )
* SO BIT MASK HAS 2 BITS IN [A] AND ADDRESS IS IN [X]
*
GPUTMC PSHS   B,U
       LDB    SCWID    GET BYTE SIZE OF EACH ROW
       LDA    YLOW     GET ROW COUNTER
       MUL             MULTIPLY
       ADDD   SCBASE   TURN INTO MEMORY SCREEN POINTER
       TFR    D,X      SAVE CURRENT SUM IN [X]
       LDB    XLOW     LOOK AT X
       LSRB            DIVIDED BY 4
       LSRB
       ABX             ADD ON BYTE OFFSET FROM ROW
       LDA    XLOW     GET BACK X COUNT TO CONSTRUCT
       ANDA   #&3      BIT MASK
       LDU    #BITTB2  USE AS INDEX INTO BIT TABLE
       LDA    A,U      GET BIT MASK WITH 2 BITS FROM TABLE
       PULS   U,B,PC


BITTB1 FCB    &128     BACKWARDS BECAUSE OF THE WAY
       FCB    &64      GRAPHICS BITS ARE HANDLED
       FCB    &32
       FCB    &16
       FCB    &8
       FCB    &4
       FCB    &2
       FCB    &1

BITTB2 FCB    &192     MASK FOR COLOR GRAPHICS CASE
       FCB    &48      TWO  BITS PER PIXEL
       FCB    &12
       FCB    &3

*
* THESE ARE THE RELATIVE POSITION ROUTINES THAT MOVE
* UP ONE IN X OR Y
*
GINCY  LDB    SCWID
       ABX
       RTS
GINXB  LSRA            SHIFT BIT MASK TO THE RIGHT
       BCC    GIXRTS   IF NO CARRY THATS ALL
       RORA            SET HIGH BIT IN [A]
       LEAX   &1,X     UPDATE DISPLAY ADDRESS
GIXRTS RTS
GINXC  LSRA            MOVE OVER 1 BIT
       BCC    GINXB    JUST SHIFT ONE MORE IF NO CARRY
       LDA    #&192    SET UP FOR 2 LEFTMOST BITS
       LEAX   &1,X     UPDATE DISPLAY ADDRESS
       RTS


*
* THIS ROUTINE SCANS A POINT AT THE CURRENT TEXT POSITION INTO
* XSTORE AND YSTORE. THE RANGE IS COMPRESSED TO Y=0 TO CYMAX-1
* AND X=0 TO CXMAX-1
*
       XDEF   SCNPNT
SCNPNT JSR    GETNUM   SET X INTO POKER AND Y INTO [B]
       LDY    #XSTORE
SCNPN2 CMPB   #CYMAX   IS IT TOO BIG?
       BCS    SCNYNT
       LDB    #CYMAX—&1 SET MAXIMUM VALUE
SCNYNT CLRA            MAKE DOUBLE BYTE
       STD    &2,Y
       LDD    POKER    GET X VALUE
       CMPD   #CXMAX   SEE IF TOO BIG
       BCS    SVXRTS
       LDD    #CXMAX—&1
SVXRTS STD    ,Y
       RTS

*
* THIS SUBROUTINE TAKES THE VALUES IN XSTORE AND YSTORE AND
* ASSUMING THEY ARE GRAPHICS COORDINATES SCALES THEM BASED ON THE
* CURRENT GRAPHICS MODE.
* THIS ALLOWS ALL GRAPHICS COORDINATES TO BE DECLARED IN THE SPACE
* Y=0 TO CYMAX-1 AND X=0 TO CXMAX-1 SO MODE CHANGES DON'T REQUIRE PROGRAM
* CHANGES
* IN MODE0+1 X=X/2 Y=Y/2
* IN MODE2+3 X=X/2
* IN MODE4 NO CHANGE
*
GSCALR JSR    SCNPNT   SCAN VALUES OUT OF TEXT
GSCALE LDU    #XSTORE  POINT AT ARGUMENTS
GSCALC LDA    SCMODE   GET THE SCREEN MODE
       CMPA   #&2      SEE IF Y NEEDS TO BE ADJUSTED
       BCC    GSCNTY   NO GO HANDLE X
       LDD    &2,U     DIVIDE Y BY 2
       LSRA
       RORB
       STD    &2,U
GSCNTY LDA    SCMODE   NOW SEE IF X HAS TO BE SHIFTED

       CMPA   #&4      SEE IF ITS MODE 4
       BCC    SVURTS   ONLY MODE4 HAS X NON—SCALED
       LDD    ,U
       LSRA
       RORB            DO THE DIVIDE
       STD    ,U
SVURTS RTS


*
* PPOINT IS A FUNCTION TAKING (X,Y) AND RETURNING THE COLOR OF THE GRAPHICS
* BIT SET AT THAT LOCATION
*
       XDEF   PPOINT
PPOINT JSR    ONECRD   SCAN COORDINATE
       JSR    GSCALE   SCALE TO GRAPHICS RANGE
       JSR    GENADR   GET THE ADDRESS IN [X] AND BITS IN [A]
       ANDA   ,X       GET BIT RESULT INTO [A]
       LDB    SCMODE   SEE IF COLOR OR BLACK AND WHITE
       RORB
       BCC    PNTBW    POINT IN COLOR MODE IS SPECIAL
PNTCLP CMPA   #&4      ARE BITS IN RANGE?
       BCS    PNTCDN
       RORA
       RORA
       BRA    PNTCLP
PNTCDN INCA            MAP NON BLACK COLORS TO 1 TO 8
       ASLA
       ADDA   SCCSS    ADD IN COLOR SELECT TO GIVE ACTUAL COLOR
       LSRA
PNTRT1 TFR    A,B      RETURN RESULT IN [B]
PNTRT0 JMP    SNGFLT
PNTBW  TSTA            SEE IF POINT IS SET OR NOT
       BEQ    PNTRT1   RETURN ZERO FOR BLACK
       CLRA            OTHERWISE ITS GREEN OR CYAN
       BRA    PNTCDN
*
* PSET AND PRESET ARE STATEMENTS WHICH TAKE (X,Y,[,Z])
* AND AFFECT THE SELECTED POINT. Z IS THE ATTRIBUTE TO SET
* IF IT IS PRESENT.
*
       XDEF   PSET
PSET   LDA    #&1      INDICATE THIS IS A SET
       BRA    PSETCN
       XDEF   PRESET
PRESET CLRA
PSETCN STA    SETFLG   SET UP A FLAG FOR LATER USE
       JSR    CHKOPN
       JSR    GSCALR   GET THE ARGUMENT IN GRAPHICS MODE
       JSR    CMCOLR
       JSR    CHKCLS   MAKE SURE STATEMENT ENDED
       JSR    GENADR   GET [X] POINTING AT VALUE AND [A] AS MASK
GRPACT LDB    ,X       Remember the current contents of
       PSHS   B        the video memory.
       TFR    A,B      DUPLICATE BIT MASK
       COMA            FORM COMPLEMENT
       ANDA   ,X       AND BRING IN CURRENT DATA BITS
       ANDB   ACTCLE   AND BITS WITH CURRENT COLOR BITS
       PSHS   B        PUT [B] ON STACK TO OR TOGETHER
       ORA    ,S+      NEW COLOR BITS AND OLD DATA
       STA    ,X
       SUBA   ,S+      Set the change flag for PAINT if
       ORA    PNTCHF   the video memory was changed.
       STA    PNTCHF
       RTS

*
* SCAN A PAIR OF POINTS INTO XSTORE,YSTORE AND X2STOR,Y2STOR
*
       XDEF   CRDGET
CRDGET LDX    LSAVEX
       STX    XSTORE
       LDX    LSAVEY
       STX    YSTORE
       CMPA   #MINUTK  SEE IF DEFAULTING
       BEQ    CRDGT2
       JSR    ONECRD   READ ONE PAIR INTO XSTORE AND YSTORE
CRDGT2 SYNCHK MINUTK   SEPERATED BY A MINUS SIGN
       JSR    CHKOPN
       JSR    GETNUM   EVALUATE NUMBER
       LDY    #X2STOR  STORE VALUE INTO SECOND SET OF POINTS
       JSR    SCNPN2
       BRA    CHKCGO
*
* READ A COORDINATE SET WITH PARENS INTO XSTORE AND YSTORE
*
ONECRD JSR    CHKOPN
       JSR    SCNPNT
CHKCGO JMP    CHKCLS

*
* THIS IS THE GENERAL PURPOSE LINE ROUTINE
* FORMAT IS LINE(X1,Y1)-(X2,Y2), (PSET OR PRESET)
* OPTIONAL ,B (FOR BOX) OR ,BF (BOX FILL)
*
* IDEA IS TO SCAN COORDINATES INTO (XSTORE,YSTORE) AND (X2STOR,Y2STOR)
* AND USE SETFLG TO DISTINGUISH THE GRAPHICS OR CHAR AND PSET OR PRESET
*
       XDEF   LINE
LINE   CMPA   #INPUTK  FUNCTION NAME LIKE "INPUT"
       LBEQ   ILINE
       CMPA   #OPNPAR
       BEQ    GLINEC   DON'T REQUIRE @ LIKE NEC VERSION
       CMPA   #MINUTK
       BEQ    GLINEC   ALLOW DEFAULT OF FIRST COORDINATE
       SYNCHK '@       SKIP @ THAT MUST BE THERE
GLINEC JSR    CRDGET   SCAN THE COORDINATES
       LDX    X2STOR   SAVE SECOND COORDINATE FOR REUSE WITH -
       STX    LSAVEX
       LDX    Y2STOR
       STX    LSAVEY
       JSR    CHKCOM
       CMPA   #PRESTK  IS IT PRESET?
       BEQ    GRLINR
       CMPA   #PSETTK
       LBNE   SNERR
GRLINS LDB    #&1      FLAG FOR PSET
       SKIP1
GRLINR CLRB            FLAG FOR PRESET
       PSHS   B        SAVE THE FLAG
       JSR    CHRGET   SKIP OVER PSET OR PRESET
       JSR    GSCAL2   GRAPHICS SCALE BOTH POINTS
       PULS   B        GET BACK THE FLAG
LINCN2 STB    SETFLG   FLAG IS 1PSET,0PRESET
       JSR    DEFCOL   SET UP DEFAULT COLOR
       JSR    CHRGOT   REGET THE LAST CHAR
       LBEQ   LINGEN   JUST LINE
       JSR    CHKCOM   MUST HAVE ATTRIBUTE
       SYNCHK 'B       MUST HAVE B FOR BOX
       BNE    LINBXF   IF CONTINUES MUST BE BOX FILL
       BSR    XLINE    DRAW THE BOX
       BSR    YLINE
       LDX    XSTORE
       PSHS   X        SAVE XSTORE FOR LAST LINE
       LDX    X2STOR   OVERWRITE FOR BOTTOM LINE
       STX    XSTORE
       BSR    YLINE
       PULS   X        GET BACK XSTORE
       STX    XSTORE
       LDX    Y2STOR   DRAW BOTTOM LINE
       STX    YSTORE
       BRA    XLINE

*
* SET UP GRAPHICS LINE BY SCALING COORDINATES AND SETTING FLAG
*
GSCAL2 JSR    GSCALE   SCALE FIRST COORDINATE
       LDU    #X2STOR  POINT AT SECOND COORDINATES
       JMP    GSCALC   AND SCALE THEM

LINBXF SYNCHK 'F       THIS IS LINE BOX FILL
       BRA    LINBXS   JUMP INTO THE LOOP
LINBXD LEAX   -&1,X    DECREMENT Y COORDINATE
LINBXL STX    YSTORE   UPDATE Y COORDINATE
LINBXS JSR    XLINE    DRAW THE XLINE
       LDX    YSTORE   SEE HOW WE COMPARE WITH Y2STOR
       CMPX   Y2STOR
       BEQ    LINRTS   ALL DONE WHEN MATCH
       BCC    LINBXD   YSTORE IS BIGGER SO DECREMENT IT
       LEAX   &1,X     YSTORE IS SMALLER SO INCREMENT IT
       BRA    LINBXL

LINRTS RTS


*
* DRAW A LINE FROM XSTORE,YSTORE TO X2STOR,YSTORE
*
XLINE  LDX    XSTORE   GET X1 COORDINATE
       PSHS   X        SAVE IT FOR CALLER
       JSR    XDELTS
       BCC    XLNXFR   [D] HAS COUNT IF NO CARRY SO GO
       LDX    X2STOR   ALWAYS INCREMENT SO MAKE XSTORE SMALLER
       STX    XSTORE
XLNXFR TFR    D,Y      PUT COUNT IN [Y]
       LEAY   &1,Y     OFFSET BY ONE
       JSR    GENADR   GET ADDRESS AND BIT MASK FOR START
       PULS   U        GET BACK XSTORE
       STU    XSTORE
       BSR    XADRI    MAKE U ADDRESS OF INCREMENT ROUTINE
XLNLOP STA    GTMPB1   SAVE THE BIT MASK
       JSR    GRPACT   ACTUALLY PERFORM ACTION (SET RESET OR PUT CHR)
       LDA    GTMPB1   GET BACK THE BIT MASK
       JSR    ,U       GO OFF TO INCREMENT ROUTINE
       LEAY   -&1,Y    DECREMENT THE COUNT
       BNE    XLNLOP   ITERATE WITH ACTION
       RTS

*
* YLINE DRAWS FROM XSTORE,YSTORE TO XSTORE,Y2STOR
*
DYLINE PULS   D        ENTRY FROM GENERAL LINE DRAW ROUTINE
*    CLEAN OFF THE STACK

       XDEF   YLINE
YLINE  LDD    YSTORE   GET Y COORDINATE
       PSHS   D        SAVE TO RESTORE
       JSR    YDELTS
       BCC    YLNXFR
       LDX    Y2STOR
       STX    YSTORE
YLNXFR TFR    D,Y
       LEAY   &1,Y
       JSR    GENADR
       PULS   U
       STU    YSTORE
       BSR    YADRI    MAKE U A ROUTINE TO INCREMENT Y
       BRA    XLNLOP

*
* TABLE OF ROUTINES TO INCREMENT X AND Y FOR EACH MODE
*
XINCS  FDB    GINXB
       FDB    GINXC
       FDB    GINXB
       FDB    GINXC
       FDB    GINXB
XADRI  LDU    #XINCS
       LDB    SCMODE
       ASLB
IMDFET LDU    B,U
       RTS
YADRI  LDU    #GINCY   Y INCREMENT ROUTINE
       RTS
*
* THIS IS THE GENERAL PURPOSE LINE DRAWING ROUTINE
* IT DRAWS FROM XSTORE,YSTORE TO X2STOR,Y2STOR
*
LINGEN LDY    #YINC    ASSSUME INCREMENTING Y
       JSR    YDELTS
*** BNE LINNTX
*** TST CFLFLG  ;CANT USE XLINE FOR FILLING
       LBEQ   XLINE    SPECIAL CASE IS FASTER
LINNTX BCC    LY1BIG
       LDY    #YDEC
LY1BIG PSHS   D        SAVE DELTA Y ON THE STACK
       LDU    #XINC    ASSUME INCREMENT
       JSR    XDELTS
*** BNE LINNTY
*** TST CFLFLG  ;CANT USE YLIN FOR CIRCLE FILL CASE
       BEQ    DYLINE
LINNTY BCC    LX1BIG
       LDU    #XDEC
LX1BIG CMPD   ,S       SEE WHICH DELTA IS BIGGER
       PULS   X        GET DELTA Y INTO X
       BCC    XMLDLT   IF CC THEN XDELTA IS BIGGER
       EXG    U,Y      MAKE U MAJOR AXIS AND Y MINOR AXIS
*    INCREMENT OR DECREMENT ROUTINE
       EXG    D,X      MAKE D MAJOR DELTA AND X MINOR DELTA
XMLDLT PSHS   U,D      SAVE COUNT OF POINTS IN LINE
       PSHS   D        SAVE MAJOR DELTA TO KNOW WHEN TO
*    INCREMENT ON MINOR AXIS
       LSRA            START THE COUNT AT MAJOR DELTA/2
       RORB            SO MIDPOINT IS ALWAYS CORRECT
       BCS    HLFNTO   IF NOT ODD NO PROBLEM
*    WE ROUND IF WE ARE DECREMENTING
*    SO WE END UP WITH THE SAME POINTS
*    IN BOTH DIRECTIONS
       CMPU   #YINC+&1
       BCS    HLFNTO   SINCE XINC AND YINC ARE BELOW YINC+1 SKIP INCREMENT
       SUBD   #&1
HLFNTO PSHS   X,D      THE COUNTER IN [D] IS INCREMENTED BY
*    THE MINOR DELTA EVERYTIME AND THE MINOR
*    AXIS IS UPDATED WHEN IT REACHES THE MAJOR
*    DELTA
*    SAVE MINOR DELTA IN [X] FOR ADDING TO
*    COUNTER
       JSR    PTADRS   GET INTO [U] ADDRESS OF INDEX ROUTINE
       IFNE   &0
 ENDC   IFN 0
LNGLOP JSR    ,U       GET LOCATION IN [X] AND BIT IN [A]
       JSR    GRPACT   ACTUALLY PERFORM THE ACTION
LNGLP2 LDX    &6,S     CHECK COUNT OF POINTS
       BEQ    LNGFIN
       LEAX   -&1,X    DECREMENT
       STX    &6,S
       JSR    [&8,S]   UPDATE MAJOR AXIS
       LDD    ,S       GET COUNT TO ADD MINOR DELTA
       ADDD   &2,S
       STD    ,S       UPDATE COUNT
       SUBD   &4,S     SEE IF REACHED MAJOR DELTA
       BCS    LNGLOP   IF NOT JUST CONTINUE DRAWING
       STD    ,S       UPDATE TEMP COUNT
       JSR    ,Y       UPDATE MINOR AXIS
       BRA    LNGLOP
LNGFIN PULS   X        GET RID OF FIFTH TEMP ON STACK
       PULS   X,D,Y,U,PC GET RlD OF 4 TEMPS AND RETURN
*** JSR SPCROT  ;SPECIAL JSR FOR CIRCLE FILL
***    ;THIS IS CALLED WHEN MINOR AXIS UPDATE
***    ;IS DECREMENTED BY 3 FOR FILLED CIRCLE
XINC   LDX    XSTORE
       LEAX   &1,X
       STX    XSTORE
       RTS
*** JSR SPCROT
* NOTE THIS ORDER IS IMPORTANT SINCE WE COMPARE ADDRESS OF MAJOR
* AXIS UPDATE ROUTINE TO YINC+1 TO SEE IF WE ARE +ING OR -ING
YINC   LDX    YSTORE
       LEAX   &1,X
       STX    YSTORE
       RTS
*** JSR SPCROT
XDEC   LDX    XSTORE
       LEAX   -&1,X
       STX    XSTORE
       RTS
*** JSR SPCROT
YDEC   LDX    YSTORE
       LEAX   -&1,X
       STX    YSTORE
       RTS
STMAXS LDU    #XMAX    POINT AT MAX STORAGE AREA
       LDX    #CXMAX-&1 MAX LOGICAL VALUE TO SCALE
       STX    ,U
       LDX    #CYMAX-&1 MAX Y LOGICAL VALUE
       STX    &2,U
       JMP    GSCALC

       TTL    NEW GRAPHICS CODE FOR 6847 COLOR COMPUTER

*
* PCLS CLEAR A GRAPHICS SCREEN
*
       XDEF   PCLS
PCLS   BEQ    DEFCLS   IF NO ARGUMENT, DEFAULT CLEAR
       BSR    GETCLR   READ COLOR TO CLEAR TO
GCLSB  LDA    #@125    REPLICATE THROUGHOUT BYTE
       MUL
       LDX    SCBASE   STORE INTO SCREEN MEMORY
GCLSLP STB    ,X+
       CMPX   SCTOP
       BNE    GCLSLP
       RTS
DEFCLS LDB    BAKCLR
       BRA    GCLSB

*
* COLOR SETS UP FOREGROUND AND BACKROUND COLOR
*
       XDEF   COLORS
COLORS CMPA   #COMMA   FOREGROUND COLOR PRESENT?
       BEQ    COLORB   IF ONLY BACKGROUND
       BSR    GETCLR   READ COLOR IN
       STB    FORCLR   SET UP FORCLR (FOREGROUND COLOR)
       JSR    CHRGOT   FOREGROUND ONLY?
       BEQ    COLRTS
COLORB JSR    CHKCOM   HAVE TO HAVE COMMA BEFORE BACKROUND
       BSR    GETCLR   FETCH BACKROUND COLOR
       STB    BAKCLR   SET UP BAKCLR
COLRTS RTS

*
* GETCLR RETURNS
* [B] = COLOR FROM 0 TO 3
* [A] = 8 IF CSS SHOULD BE SET 0 OTHERWISE
* TABLE OF RETURNS
* ARG C BW CSS
*   0 3  0  0
*   1 0  3  0
*   2 1  0  0
*   3 2  3  0
*   4 3  0  0
*   5 0  3  8
*   6 1  0  8
*   7 2  3  8
*   8 3  0  8
*
GETCLR JSR    GETBYT   READ THE COLOR
GETCLX CMPB   #&9
       LBCC   FCERR    ILLEGAL OVER 9
       CLRA            ASSUME CSS 0
       CMPB   #&5
       BCS    CNOCSS   0 -4 HAVE NO CSS
       LDA    #&8
       SUBB   #&4      MAP 5-8 TO 1-4
CNOCSS PSHS   A        SAVE CSS
       LDA    SCMODE   SEE IF COLOR OR BLACK AND WHITE
       RORA
       BCC    CLBWST   CLEAR FOR BLACK AND WHITE
       TSTB            IF NON-ZERO ALL WE NEED IS A DECREMENT
       BNE    CLCLST
CLBW3  LDB    #&4      FOR ZERO END UP MAPPING TO 3
CLCLST DECB
GETCFN PULS   A,PC     GET CSS BACK AND RETURN
CLBWST RORB            LOOK AT LOW BIT OF COLOR
       BCS    CLBW3
       CLRB            OTHERWISE RETURN ZERO
       BRA    GETCFN
*
* COLOR FETCH ROUTINE
*
CMCOLR JSR    DEFCOL   SETUP DEFAULT
       JSR    CHRGOT   SEE IF DEFAULT IS CORRECT
       BEQ    CO2RTS   IF END, IT MUST BE
       CMPA   #CLSPAR
       BEQ    CO2RTS
       JSR    CHKCOM
       CMPA   #COMMA   IF COMMA IF MUST BE
       BEQ    CO2RTS
       JSR    GETCLR   GET COLOR IN
       BSR    DEFFOR
CO2RTS JMP    CHRGOT
DEFCOL LDB    FORCLR   ASSUME FOREGROUND IS CORRECT
       TST    SETFLG   SEE IF PSET OR PRESET
       BNE    DEFFOR
       LDB    BAKCLR
DEFFOR STB    ACTCLR
       LDA    #@125
       MUL
       STB    ACTCLE
       RTS
*
* SAMALP IS CALLED TO SWITCH BACK TO ALPHA MODE FROM GRAPHICS
*
SAMMOD BNE    SAMGRP   CALLED BY SCREEN TO SELECT MODE
       XDEF   SAMALP
SAMALP PSHS   D,X
       LDX    #SAM+&8
       STA    &10,X    SPEED LESSENS FLICKER IN MODE SWITCH
       STA    &8,X     CHANGE LEAST IMPORTANT FIRST
       STA    &6,X
       STA    &4,X
       STA    &2,X
       STA    &1,X
       STA    -&2,X
       STA    —&4,X
       STA    —&6,X
       STA    -&8,X
       LDA    PIA1BD   GET PIA VALUE FOR VIDEO CONTROL
       ANDA   #&7      PRESERVE NON—VIDEO BITS
       STA    PIA1BD   SETTING ALL VIDEO BIT TO 0
       PULS   D,X,PC   RETURN PRESERVING ALL REGISTERS
SAMGRP PSHS   D,X
       LDA    SCMODE   GET GRAPHICS MODE TO SET
       ADDA   #&3
       LDB    #&16     MOVE OVER 4 BITS
       MUL             AND PUT RESULT IN [B]
       ORB    #&128    ALWAYS TURN HIGH BIT ON
       ORB    SCCSS
       LDA    PIA1BD   GET OLD STATE OF PIA
       ANDA   #&7      PRESERVE LOW 3 BITS
       PSHS   A
       ORB    ,S+      OR IN OLD WITH NEW
       STB    PIA1BD   SET UP FOR GRAPHICS NOW
       LDA    SCBASE   GET SCREEN BASE
       LSRA            AS A .5K COUNT
       JSR    SETVAD   AND SET UP AS A VIDEO ADDRESS
       LDA    SCMODE   GET SCREEN MODE AGAIN
       ADDA   #&3      TO PROGRAM SAM CHIP
       CMPA   #&7      ONLY CHANGE IS MAP 7 TO 6
       BNE    GSTVMD
       DECA
GSTVMD BSR    SETVMD   SET VIDEO MODE
       PULS   D,X,PC
SETVMD LDB    #&3      THREE BITS TO SET
       LDX    #SAM     START AT SAM BASE ADDRESS
SETVLP RORA            SET IF NEXT BIT IS HIGH OR LOW
       BCC    SETVZR   IF LOW STORE INTO LOW ADDRESS
       STA    &1,X
       BRA    SETVON
SETVZR STA    ,X
SETVON LEAX   &2,X     MOVE UP TO SET NEXT BIT
       DECB            MORE BITS TO SET?
       BNE    SETVLP
       RTS
SETVAD LDB    #&7      SEVEN BITS TO SET IN VIDEO BASE
       LDX    #SAM+&6  STARTING PLACE IS 6 BYTES INTO SAM
       BRA    SETVLP
SETCSS LDA    PIA1BD   GET VIDEO STATUS
       ANDA   #@377-@10 TURN OFF BIT 3
       ORA    SCCSS    OR IN CURRENT CSS VALUE
       STA    PIA1BD   SET NEW VALUE TO PIA
SETRTS RTS

*
* PMODE SCREEN MODE (0-4),PAGE NUMBER (WHICH 1.5K BLOCK)
*
       XDEF   PMODE
PMODE  CMPA   #COMMA
       BEQ    PMDPGS   IF NO MODE, READ NEW PAGE NUMBER
       JSR    GETBYT   GET THE MODE
       CMPB   #&5      MAX MODE IS 4
       BCC    FCGRP1
       LDA    SCRBAS   REINIT SCBASE TO PAGE 1
       XDEF   XRPMOD
XRPMOD STA    SCBASE
       ASLB            CONSTRUCT INDEX INTO SCREEN DATA TABLE
       LDU    #SCRTAB+&1 EACH ENTRY HAS 2 BYTES
       ADDA   B,U      NUMBER OF MEMORY PAGES IS #2
       CMPA   TXTTAB   COMPARE WITH MAXIMUM
       BHI    FCGRP1   NO MEMORY FOR THAT MODE
       STA    SCTOP    SET TOP ADDRESS OF SCREEN
       LEAU   -&1,U    GET FIRST BYTE IN TABLE
       LDA    B,U      WHICH IS THE SCWID FOR THE MODE
       STA    SCWID
       LSRB            GET BACK MODE
       STB    SCMODE
       CLRA            DEFAULT BACKROUND AND FOREGROUND
       STA    BAKCLR   COLORS
       LDA    #&3
       STA    FORCLR
       JSR    CHRGOT   SEE IF ANY MORE ARGUMENT
       BEQ    SCRRTS
       XDEF   PMDPGS
PMDPGS JSR    COMBYT   FORCE COMMA AND READ PAGE
       TSTB            ZERO NOT ALLOWED
       BEQ    FCGRP1
       DECB
       LDA    #&6      CONVERT TO NUMBER OF MEMORY PAGES
       MUL             IN [B]
       ADDB   SCRBAS   ADD ON BASE OF GRAPHICS MEMORY
       PSHS   B        SAVE CANDIDATE FOR SCBASE
       ADDB   SCTOP    ADD ON SIZE OF CURRENT MODE
       SUBB   SCBASE   WHICH IS SCTOP-SCBASE
       CMPB   TXTTAB   AND SEE IF HITTING PROGRAM
       BHI    FCGRP1
       STB    SCTOP    SETUP NEW TOP
       PULS   B
       STB    SCBASE   AND NEW BOTTOM
SCRRTS RTS

FCGRP1 JMP    FCERR

*
* SCREEN [ALPHA/GRAPHIC FLAG][,CSS FLAG]
*
       XDEF   SCREEN
SCREEN CMPA   #COMMA   JUST CHANGE CSS
       BEQ    SCRCSS   SCAN CSS ARGUMENT
       JSR    GETBYT   READ FLAG ALPHA/GRAPHIC
       TSTB            SEE CONDITION CODES
       JSR    SAMMOD   SELECT ALPHA IF ZERO ELSE GRAPHICS
       JSR    CHRGOT
       BEQ    SCRRTS
SCRCSS JSR    COMBYT   READ CSS FLAG
       TSTB            ZERO OR NON-ZERO?
       BEQ    SCRS2R
       LDB    #&8      B3 SHOULD DE SELECTED
SCRS2R STB    SCCSS    SAVE FLAG
       BRA    SETCSS   ACTUALLY CHANGE THE VALUE
       XDEF   PCLEAR
PCLEAR JSR    GETBYT   READ IN NUMBER OF 1.5K BLOCKS ALLOWED
       TSTB            MUST ALLOW AT LEAST ONE
       BEQ    FCGRP1
       CMPB   #&9      LIMIT IS 8 FOR 12K MAXIMUM
CCFCER BCC    FCGRP1
       LDA    #&6      CONVERT 1.5K TO 256 BYTE
       MUL             TURN INTO 256 BYTE COUNT
       ADDB   SCRBAS   ADD BASE ADDRESS FOR GRAPHICS MEMORY
       TFR    B,A      MAKE [D] CONTAIN ADDRESS OF NEW
       LDB    #&1      TXTTAB CANDIDATE
       TFR    D,Y      SAVE TO SET IF LEGAL
       CMPD   SCTOP    SEE IF PROGRAM WOULD BE IN VIDEO
       LBCS   FCERR
       SUBD   TXTTAB   CALCULATE NEW VARTAB
       ADDD   VARTAB   BY ADDING OLD VARTAB-OLD TXTTAB
       TFR    D,X      ALSO SAVE VARTAB CANDIDATE
       ADDD   #&200    ALLOW 200 BYTES EXTRA
       SUBD   STKTOP   ROOM AFTER END OF PROGRAM?
       BCC    FCGRP1   SHOULD BE WELL BELOW STKTOP
       LDA    CURLIN   Executing a direct statement?
       INCA
       BEQ    DIRSTA   Yes, leave TXTPTR as is.
       TFR    Y,D      No, TXTPTR:=TXTPTR+(new TXTTAB-
       SUBD   TXTTAB   old TXTTAB) so it points to the
       ADDD   TXTPTR   same place in the program after
       STD    TXTPTR   the program is moved.
DIRSTA LDU    VARTAB   FETCH OLD VARTAB FOR BLOCK TRANSFER
       STX    VARTAB   SAVE NEW VARTAB
       CMPU   VARTAB   MOVING UP OR DOWN?
       BCC    PRGMVD   BLOCK TRANSFER DOWN
PRGMVU LDA    ,-U      FETCH FROM OLD VARTAB GOING LOWER
       STA    ,-X      STORE INTO NEW VARTAB
       CMPU   TXTTAB   REACHED OLD TXTTAB?
       BNE    PRGMVU   IF NOT, KEEP TRANSFERING
       STY    TXTTAB   SET UP NEW TXTTAB
       CLR    -&1,Y    AND ZERO BYTE BEFORE IT
       XDEF   PRGSET
PRGSET JSR    CHEADA   FIX UP THE LINKS
       JSR    CLEARC   PERFORM A CLEAR TO SET NEW ARYTAB...
       JMP    NEWSTT   AND CONTINUE WITH PROGRAM
PRGMVD LDU    TXTTAB   GET OLD TXTTAB TO MOVE DOWN FROM
       STY    TXTTAB   SET UP NEW TXTTAB
       CLR    -&1,Y    AND FORCE ZERO BEFORE IT
PRGMVL LDA    ,U+      FETCH FROM TXTTAB UP
       STA    ,Y+      AND STORE INTO NEW TXTTAB GOING UP
       CMPY   VARTAB   COMPARE AGAINST NEW VARTAB
       BNE    PRGMVL   ITERATE MOVING TO LOWER ADDRESSES
       BRA    PRGSET   FINISH UP PCLEAR
       XDEF   PINIT
PINIT  LDB    #&30     ALLOW FOR MAXIMUM GRAPHICS
       IFNE   REALIO
       STB    TXTTAB   SAME AS PCLEAR 4
       ENDC   IFN      REALIO
       LDA    #&6
       XDEF   REPINT
REPINT STA    SCRBAS   SAVE FOR FUTURE USE
       STA    SCBASE
       CLRA
       STA    SCMODE
       LDA    #&16
       STA    SCWID
       LOA    #&3
       STA    FORCLR
       LDA    #&12
       STA    SCTOP
       LDX    TXTTAB
       CLR    -&1,X
       JMP    SCRTCH
SCRTAB FCB    &16      MODE 0 HAS SCWID 16
       FCB    &6       AND REQUIRE 6 256 BYTE PAGES OF MEMORY
       FCB    &32      MOVE TO 32 BYTE SCWID FOR COLOR
       FCB    &12      AND DOUBLE THE MEMORY
       FCB    &16
       FCB    &12
       FCB    &32
       FCB    &24
       FCB    &32
       FCB    &24
YDELTS LDD    Y2STOR   CALCULATE DELTA Y IN [D]
       SUBD   YSTORE
YDLCON BCC    YDLRTS
       PSHS   CC       Save carry and zero flags.
       JSR    NEGD     Get a positive delta.
       PULS   CC,PC    Restore carry and zero and return.

XDELTS LDD    X2STOR   CALCULATE DELTA X
       SUBD   XSTORE
       BRA    YDLCON
       XDEF   PCOPY
PCOPY  BSR    PCOPR    READ A PAGE NUMBER ARGUMENT AND
       PSHS   D        GET PAGE ADDRESS IN [D]
       SYNCHK TOTK     Format is PCOPY <source> TO <dest>.
       BSR    PCOPR    GET dest PAGE ARGUMENT
       PULS   X        GET source PAGE IN [X]
       TFR    D,U      PUT dest PAGE IN [U]
       LDY    #&0768   NUMBER OF BYTES ON A PAGE IS 2*768
PCOPLP LDD    ,X++     READ FROM SOURCE PAGE
       STD    ,U++     AND STORE WITHOUT MODIFYING
       LEAY   -&1,Y
       BNE    PCOPLP
       RTS
PCOPR  JSR    GETBYT   PAGE NUMBERS ARE 1-8
       TSTB            ZERO IS ILLEGAL
       BEQ    GFCER
       DECB            MAP PAGE NUMBER TO 0 TO 7
       LDA    #&6      TRANSLATE TO MEMORY ADDRESS
       MUL             MAKE [B] NUMBER OF 256 BYTE PAGES
       ADDB   SCRBAS   ADD GRAPHICS MEMORY BASE ADDRESS
       CMPB   TXTTAB   SHOULDN'T POINT INTO PROGRAM
       BHS    GFCER
       EXG    A,B      Turn it into a 16 bit address.
YDLRTS RTS             (A was zero from MUL.)

       TTL    Graphics PUT and GET


*
* GET[@](X1,Y1)-(X2,Y2),ARRAY NAME[,G]
* PUT[@](X1,Y1)-(X2,Y2),ARRAY NAME[ACTION=AND,OR,PSET,PRESET,NOT]
*

GFCER  JMP    FCERR    FUNCTION CALL FROM SEVERAL SOURCES

       XDEF   GET
GET    CLRB            FLAG AS GET -- SHARE CODE WITH PUT
       BRA    GGETCN

       XDEF   PUT
PUT    LDB    #&1      FLAG AS PUT NOT GET
GGETCN STB    GTPTFL   SAVE INDICATION OF WHICH IT IS
       JSR    HKPTGT   ALLOW EXIT IN CASE GET/PUT USED OTHERPLACES
       XDEF   GGPRET
GGPRET EQU    *        This address is used by the code
*    the disk ROM hooks into HKPTGT to
*    determine if the caller was the
*    graphics PUT/GET code.
       CMPA   #'@      ALLOW OPTIONAL @ FOR COMPATIBILITY
       BNE    GGETC2
       JSR    CHRGET   SKIP OVER THE @ SIGN
GGETC2 JSR    CRDGET   SCAN THE COORDINATES
       JSR    CHKCOM   SKIP COMMA AFTER COORDINATES
       JSR    PGTARY   SCAN THE ARRAY NAME AND LOOK IT UP
•    [X] RECEIVES POINTER AT THE LENGTH
*    BYTES. AN FCERR IS GENERATED IF
*    THE ARRAY DOES NOT EXIST
       TFR    X,D      SAVE POINTER LENGTH BYTES IN [D]
       LDU    ,X       [U]=LENGTH
       LEAU   -&2,U    DON'T INCLUDE NAME SIZE WHICH IS IN COUNT
       LEAU   D,U      SET [U]=ADDRESS JUST PAST END OF ARRAY
       STU    ARYFIN   SAVE THIS SO WE MAKE SURE WE NEVER
*    READ OR WRITE THIS HIGH
       LEAX   &2,X     MOVE TO POINT AT NUMBER OF DIMENSIONS
       LDB    ,X       [B]=NUMBER OF DIMENSIONS
       LSLB            [B]=BYTES USED BY DIMENSION SIZES
       ABX             POINT AT THE BYTE JUST BEFORE THE DATA
*    SINCE WE NEVER ADDED ONE FOR THE
*    NUMBER OF DIMENSIONS
       STX    ARYIDX   SAVE START ADDRESS IN ARRAY-1
       LDA    VALTYP   MAKE SURE IT IS NOT A STRING ARRAY
       BNE    GFCER    SINCE GARBAGE COLLECTION WOULD FAIL
       CLR    GGRPFL   ASSUME IT'S NOT GRAPHICS MODE
       JSR    CHRGOT   ANYTHING MORE ON THIS LINE?
       BEQ    GNOTRL   MUST BE CHARACTER MODE
       COM    GGRPFL   SET GRAPHICS FLAG
       JSR    CHKCOM   COMMA BEFORE TRAILING FLAGS
       TST    GTPTFL   IS IT PUT OR GET?
       BNE    PUTTRL   HANDLING ACTION VERB ON PUT
       SYNCHK 'G       GET ONLY ALLOWS ,G MEANING GRAPHICS
       BRA    GETCN2

PUTTRL LDB    #PUTCNT  COUNT OF VERBS TO COMPARE AGAINST
       LDX    #PUTTAB  TABLE WITH ADDRESSES AND VERBS
PUTTR2 LDU    ,X++     GET CANDIDATE FOR PUTAC0
       LDY    ,X++     GET CANDIDATE FOR PUTAC1
       CMPA   ,X+      SEE IF MATCHES THE VERB
       BEQ    PUTGOA   GO STORE ACTION ADDRESSES
       DECB            MORE ITEMS IN TABLE?
       BNE    PUTTR2   CONTINUE COMPARING
       JMP    SNERR    SYNTAX ERROR IF NO MATCH AT ALL

PUTGOA STY    PUTAC1   STORE ACTION IF BIT IS A 1
       STU    PUTAC0   STORE ACTION IF BIT IS A 0
       JSR    CHRGET   SKIP OVER ACTION VERB
       BRA    GETCN2   CONTINUE SCANNING

GNOTRL LDB    #@377-&7 GET RID OF LAST 3 BITS IN BW MODE
       LDA    SCMODE   SEE IF BW OR COLOR
       RORA            BY TESTING LOW BIT
       BCC    GNOTRB   ALREADY SET UP FOR BW
       LDB    #@377-&3 GET RID OF LAST 2 BITS IN COLOR
GNOTRB TFR    B,A      MAKE 2 COPIES OF THE BIT MASK
       ANDB   XLOW     AND FIRST COORDINATE
       STB    XLOW
       ANDA   X2STOR+&1 AND SECOND COORDINATE
       STA    X2STOR+&1
GETCN2 JSR    XDELTS   CALCULATE DELTA X IN [D]
       BCC    STXDLT   SKIP OVER IF XSTORE IS LOWER
       LDX    X2STOR   FORCE XSTORE TO BE THE SMALLER
       STX    XSTORE
STXDLT STD    X2STOR   USE X2STOR TO KEEP COUNT OF COLUMNS
       JSR    YDELTS   CALCULATE DELTA Y IN [D]
       BCC    STYDLT   OK IF YSTORE IS ALREADY SMALLER
       LDX    Y2STOR   MAKE SURE YSTORE IS SMALLER
       STX    YSTORE
STYDLT STD    Y2STOR   USE Y2STOR FOR COUNT OF ROWS
       LDA    SCMODE   WE HAVE TO DOUBLE THE X COUNT FOR COLOR
       RORA            MODE SINCE THERE ARE 2 BITS PER PIXEL
       LDD    X2STOR
       BCC    GTPTBW
       ADDD   X2STOR   Double it and put it back.
       STD    X2STOR
GTPTBW JSR    GSCAL2   Scale the deltas according to the
*    current graphics mode.
       LDD    X2STOR   Get X delta into D.
       LDX    Y2STOR   Make Y2STOR a count.
       LEAX   &1,X
       STX    Y2STOR
       TST    GGRPFL   SEE IF GRAPHICS OR NOT
       BNE    GRPGTP   USE A VERY DIFFERENT LOOP FOR
*    ITERATING THROUGH GRAPHICS BITS
       LSRA            Now divide by 8 for byte mode.
       RORB
       LSRA
       RORB
       LSRA
       RORB
       ADDD   #&1      MAKE IT A COUNT
       STD    X2STOR
       JSR    GENADR   [X]=VIDEO RAM ADDRESS TO START AT
PCOLLP LDB    X2STOR+&1 GET COLUMN COUNT IN [U]
       PSHS   X        SAVE ADDRESS AT START OF COLUMN
*    AND PUT COLUMN COUNTER ON STACK
PROWLP TST    GTPTFL   IS THIS GET OR PUT?
       BEQ    GROWSB   HANDLE GET FOR ONE CHARACTER
       BSR    GARYSB   INDEX NEXT BYTE IN ARRAY
       LDA    ,U       GET THE BYTE OUT OF THE ARRAY
       STA    ,X+      SAVE THE CHARACTER
PRWINC DECB            DECREMENT COLUMN COUNT
       BNE    PROWLP   ITERATE FOR THE ENTIRE ROW
       PULS   X        [X]=ADDRESS AT START OR ROW

GSKPCH JSR    GINCY    GO TO THE NEXT ROW
GGSKPC DEC    Y2STOR+&1 COUNT DOWN FOR EACH ROW
       BNE    PCOLLP
CPTRTS RTS

GARYSB LDU    ARYIDX   INDEX INTO THE ARRAY
       LEAU   &1,U     UPDATE INDEX
       STU    ARYIDX
       CMPU   ARYFIN   ARE WE PAST THE ARRAY?
       BNE    CPTRTS
G2FCER JMP    FCERR

GROWSB LDA    ,X+      GET CHARACTERS AT CURRENT POSITION
       BSR    GARYSB   GET INDEX
       STA    ,U       STORE INTO THE ARRAY
       BRA    PRWINC   RETURN TO CHARACTER ITERATION


*
* THE FOLLOWING CODE IS THE ITERATION LOOP FOR GRAPHICS GET AND PUT
* THE IDEA IS TO GO THROUGH A GRAPHICS AREA BIT BY BIT AND EITHER
* READ BITS FROM THE SCREEN INTO THE ARRAY OR READ BITS FROM THE
* ARRAY AND USE THE BIT ALONG WITH THE ACTION VERB TO AFFECT THE
* SCREEN BIT
*

*
* THIS TABLE IS INDEXED WHEN THE VERB IS READ
* IT GIVES THE SCREEN ACTION FOR THE CASE WHEN THE ARRAY BIT IS
* SET AND NOT SET
*

PUTTAB FDB    ZERIT    ZERO ON 0
       FDB    SETIT    SET ON 1 - IGNORE OLD VALUE OF BIT
       FCB    PSETTK   PSET
       FDB    SETIT    OPPOSITE OF PSET, STILL IGNORE OLD BIT
       FDB    ZERIT
       FCB    PRESTK   PRESET
       FDB    LVEIT    ON ZERO WITH OR, LEAVE OLD VALUE
       FDB    SETIT    ON ONE WITH OT SETIT
       FCB    ORTK     OR
       FDB    ZERIT    ON ZERO WITH AND ZERO IT
       FDB    LVEIT    ON ONE WITH AND LEAVE IT ALONE
       FCB    ANDTK    AND
       FDB    COMIT    COMPLEMENT IN BOTH CASES WIH NOT
       FDB    COMIT
       FCB    NOTTK
PUTCNT EQU    (*-PUTTAB)/&5

GRPGTP ADDD   #&1      Turn D into the X count.
       STD    X2STOR   SAVE WHERE LOOP EXPECTS COUNT
       LDA    GTPTFL   IF IT IS GET WE CLEAR THE ARRAY FIRST
       BNE    PSKPCL   IF IT IS PUT SKIP CLEARING
       LDU    ARYFIN   GET END PLUS ONE
GTLPCL STA    ,-U
       CMPU   ARYIDX   GO BACK TO START MINUS ONE
       BHI    GTLPCL
PSKPCL JSR    GENADR   GET X=ADDRESS AND B=BIT MASK OF START
       LDB    SCMODE   SEE IF COLOR OR BLACK AND WHITE
       RORB            SET CARRY FOR COLOR
       BCC    GCOLST   NOTHING SPECIAL FOR BLACK AND WHITE
       ANDA   #@252    ONLY ONE OF COLOR BITS SHOULD BE ON
GCOLST LDB    #&1      INITIALIZE BIT MASK IN ARRAY
       LDY    ARYIDX   CARRY ARRAY INDEX IN [Y]
GCOLLP PSHS   X,A      SAVE ROW START ADDRESS AND BIT MASK
       LDU    X2STOR   GET BITS PER ROW
GROWLP PSHS   U,A      SAVE BIT MASK AND COUNT
       LSRB            ADJUST BIT MASK
       BCC    GETBCN   IF NO CARRY, NO INCREMENT
       RORB            MAKE HIGH BIT BE SET
       LEAY   &1,Y     ADVANCE IN THE ARRAY
       CMPY   ARYFIN   GONE OFF END?
       BEQ    G2FCER
GETBCN TST    GTPTFL   PERFORM GET OR PUT?
       BEQ    GGRPDO   GO GET INTO ARRAY
       BITB   ,Y       TEST ARRAY ELEMENT TO SEE WHICH ACTION
       BEQ    GOPUT0   ON ZERO, PERFORM ZERO ACTION
       JMP    [PUTAC1] ON ONE, PERFORM ONE ACTION
GOPUT0 JMP    [PUTAC0]

*
* THESE ARE THE ACTION ROUTINES STORED IN PUTAC1 AND PUTAC0
*

ZERIT  COMA            CLEAR THE SELECTED BIT
       ANDA   ,X
       STA    ,X
       BRA    PGRPRT

SETIT  ORA    ,X       SET THE SELECTED BIT
       STA    ,X
       BRA    PGRPRT

COMIT  EORA   ,X       EXCLUSIVE OR THE BIT TO COMPLEMENT IT
       STA    ,X
       BRA    PGRPRT

GGRPDO BITA   ,X       TEST BIT ON SCREEN
       BEQ    PGRPRT   IF CLEAR NO BIT TO SET
       TFR    B,A      SAVE CONTENTS OF B
       ORA    ,Y       SET THE SELECTED BIT
       STA    ,Y

LVEIT  EQU    *        DO NOTHING IF LEAVE BIT ALONE
PGRPRT PULS   A,U      GET BACK ROW COUNT AND BIT MASK
       JSR    GINXB    UPDATE X TO NEXT POSITION
       LEAU   -&1,U    DECREMENT COUNT OF BITS IN THE ROW
       CMPU   DBLZER   (LEAU DOESN'T SET CONDITION CODES)
       BNE    GROWLP   IF NONZERO CONTINUE THIS ROW
       LDX    &1,S     GET ADDRESS AT START OF ROW
       LDA    SCWID    UPDATE IT
       LEAX   A,X
       PULS   A        GET BIT MASK
       LEAS   &2,S     GET RID OF OLD ADDRESS
       DEC    Y2STOR+&1 DECREMENT NUMBER OF ROWS COUNT
       BNE    GCOLLP   ITERATE EACH ROW
       RTS
*
* THIS ROUTINE LOOKS UP AN ARRAY AND RETURN THE POINTER
* TO ITS COUNT BYTES IN [X]
* IF NO ARRAY IS PRESENT, AN FCERR RESULTS
*
PGTARY JSR    PTRGET   LOOK VARIABLE UP AS A SIMPLE
*    TO GET THE NAME
       LDB    ,-X      LOOK JUST BEFORE VALUE TO FETCH
       LDA    ,-X      NAME
       TFR    D,U      SAVE NAME IN [U]
       LDX    ARYTAB   START AT FIRST ARRAY
LOPFDP CMPX   STREND   SEE IF ARRAYS ENDED
       LBEQ   FCERR    IF SO ILLEGAL STATEMENT
       CMPU   ,X       IS THIS ARRAY THE ONE?
       BEQ    PGTRET   IF SO, ADVANCE POINT AND RETURN
       LDD    &2,X     GET SIZE INTO [D]
       LEAX   D,X      ADVANCE TO NEXT ARRAY
       BRA    LOPFDP   AND CHECK IT
PGTRET LEAX   &2,X     POINT AT BYTE COUNT
       RTS

       TTL    PAINT CODE
PNTRTS RTS


*
* PAINT (X,Y),PAINT COLOR,BORDER COLOR
* STARTING AT (X,Y) WE COLOR WITH PAINT COLOR UNTIL
* WE FIND THE BORDER COLOR
* ALL CONNECTED FIGURES CAN BE PROPERLY COLORED
* THE EDGE OF THE SCREEN IS CONSIDERED A BORDER
*
       XDEF   PAINT
PAINT  CMPA   #'@
       BNE    PNTNAT
       JSR    CHRGET
PNTNAT JSR    ONECRD
       JSR    GSCALE
       LDA    #&1      FLAG AS PSET CASE
       STA    SETFLG
       JSR    CMCOLR   READ THE PAINT COLOR INTO [B]
       LDD    ACTCLR   SAVE PAINT COLOR
       PSHS   D        WHICH CMCOLR SETUP
       JSR    CHRGOT   SEE IF BORDER COLOR IS DIFFERENT
       BEQ    DEFBRD   IF NOT PRESENT DEFAULT TO PAINT COLOR
       JSR    CMCOLR   READ A NEW COLOR
DEFBRD LDA    ACTCLE   GET RESULT AND SAVE
       STA    PNTCLR   IN BORDER COLOR STORAGE AREA
       PULS   D        GET BACK ACTIVE COLOR
       STD    ACTCLR   FOR FILLING
SCAN   CLRA            MAKE A DUMMY ENTRY ON THE
       PSHS   D,X,U    STACK WITH DIRECTION OF 0
       JSR    STMAXS   SETUP MAXIMUMS
*    SO WE KNOW WHERE THE BORDER IS
       JSR    PTADRS   GET THE ADRESS MAP ROUTINE FOR
       STU    PNTADR   THIS SCREEN MODE AND SAVE IT
       JSR    SCANL    LOOK LEFT FILLING AS WE GO MAKING [D] A COUNT
       BEQ    PNTLP2   IF NOT, POP DUMMY ENTRY AND QUIT
       JSR    SCNCON   CONTINUE SCAN TO RIGHT AND PUT TOTAL IN [X]
       LDA    #&1      MAKE ENTRY TO LOOK UP
       STA    PDIRCT
       JSR    ENTERS   MAKE SCAN ENTRY WITH X2STOR & PDIRCT
       NEG    PDIRCT   MAKE ENTRY FOR LOOKING DOWN
       JSR    ENTERS
PNTLP2 STS    PNTSTK   Store stack pointer in case PNTCHF
*    equals zero since we don't initialize
*    PNTCHF.
PNTLOP TST    PNTCHF   Anything changed?
       BNE    PNTPUL   Yes, use the next stack entry.
       LDS    PNTSTK   No, prune the stack.
PNTPUL PULS   D,X,U    PULL SCAN ENTRY OFF THE STACK
       CLR    PNTCHF   Say nothing changed yet.
       STS    PNTSTK   Remember stack pointer for possible
*    pruning.
*
* THIS IS THE RECURSIVE SCAN ENTRY POINT. THE IDEA IS THAT
* ANY NON-BORDERPOINTS ARE CONNECTED STARTING TO THE RIGHT
* OF X,Y AND EXTENDING FOR COUNT POINTS. WE COLOR THE NON-BORDER
* POINTS AND MAKE NEW STACK ENTRIES FOR EACH NEW CONTIGUOUS GROUP
* OF CONNECTED POINTS. THIS WILL ALWAYS BE IN THE CURRENT SCAN DIRECTION
* UNLESS THERE IS OVERHANG ON THE LEFT OR RIGHT
* [A] HAS DIRECTION
* [B] HAS Y VALUE
* [X] HAS X VALUE
* [U] HAS POINT COUNT
* THE X AND Y ARE TO THE LEFT OF THE
* PLACE TO SCAN
       LEAX   &1,X     MOVE TO THE RIGHT TO GET INTO THE SCAN AREA
       STX    XSTORE
       STU    PCOUNT
       STA    PDIRCT   SAVE THE DIRECTION
       BEQ    PNTRTS   IF DUMMY ENTRY, QUIT
       BMI    SCANDN   IF NEGATIVE DECREMENT Y VALUE
       INCB
       CMPB   YMAX+&1  SEE IF OFF THE BOTTOM
       BLS    SCNCN1   IF NOT KEEP SCANNING
       CLRB            MAKE 0 SO BRANCH TO PNTLOP
SCANDN TSTB
       BEQ    PNTLOP   IF AT TOP, TRY NEXT ENTRY
       DECB            DECREMENT Y
SCNCN1 STB    YLOW     SAVE Y VALUE
       JSR    SCANL    SCAN LEFT TO EXTEND
       BEQ    SCNCN4
       CMPD   #&3     ENOUGH TO OVERHANG ON LEFT SIDE SO NEED TO LOOK
*    IN OPPOSITE DIRECTION
       BCS    NLSENT   IF NOT NO NEW SCAN ENTRY
       LEAX   -&2,X    SUBTRACT TWO TO GET SCAN SIZE
       BSR    ENTERL   MAKE THE ENTRY
NLSENT JSR    SCNCON   CONTINUE SCAN TO RIGHT
SCNLC1 BSR    ENTERS   MAKE ENTRY
SCNCN4 COMA
       COMB            SUBTRACT [D]+1 FROM TOTAL
SCNLCN ADDD   PCOUNT   ADD ONTO PCOUNT
       STD    PCOUNT   AND UPDATE
       BLE    SCNFIN   IF 0 OR LESS NO MORE SCANNING
       JSR    XINC     MOVE RIGHT IF MORE POINTS
       JSR    TSTBRD   SEE IF BORDER OR NOT
       BNE    SCNLC2   IF NOT, CALL SCANR
       LDD    #-&1     SUBTRACT ONE FROM POINT COUNT
       BRA    SCNLCN
SCNLC2 JSR    XDEC
       BSR    SAVLOC   SAVE LEFT POSIION
       BSR    SCANR    SCAN FOR COMPLETE SIZE
       BRA    SCNLC1   GO MAKE ENTRY AND SUBTRACT
*
* WE ARE FINISHED EXTCEPT WE MIGHT NEED TO MAKE
* A REVERSE DIRECTION ENTRY FOR RIGHT SIDE OVERHANG
*
SCNFIN JSR    XINC     NO CHECK IF RIGHT OVERHANG NEEDS A SCAN
       LEAX   D,X      SUBTRACT OVERHANG SIZE FROM STOP POSITION
       STX    XSTORE
       COMA            MAKE IT A POSITIVE COUNT
       COMB
       SUBD   #&1      IF STOPPED AT END+1 ALSO NO OVERHANG
       BLE    PQUIT    TAKES AT LEAST 2 POINTS TO OVERHANG
       TFR    D,X
       BSR    ENTERL   ENTER OVERHANG SCAN
PQUIT  JMP    PNTLOP
ENTERL STD    PNTTMP   SAVE [D] WHICH HAS CURRENT COUNT
       PULS   Y        TAKE OFF THE RETURN ADDRESS
       LDD    XSTORE   SAVE COUNT AND X VALUE
       PSHS   D,X
       LDA    PDIRCT   GET DIRECTION
       NEGA
ENTCON LDB    YLOW
       PSHS   D        SAVE DIRECTION AND Y VALUE
       PSHS   Y        PUT RETURN ADDRESS BACK ON
       LDB    #&2      CHECK FOR STACK SPACE
       JSR    GETSTK
       LDD    PNTTMP   GET BACK SAVED [D] COUNT
       RTS
ENTERS STD    PNTTMP
       PULS   Y        GET RETURN ADDRESS
       LDD    X2STOR   GET X VALUE FROM SAVED POSITION
       PSHS   D,X
       LDA    PDIRCT   USE CURRENT DIRECTION
       BRA    ENTCON   MERGE WITH ENTERL CODE
SAVLOC LDX    XSTORE   MOVE PRIMARY INTO SECONDARY
       STX    X2STOR
       RTS
*
* CALLED HERE WHEN WANT TO  SCAN RIGHT AFTER A SCANL AND PUT THE
* TWO PIECES TOGETHER ALL AS ONE SCAN. WE HAVE STORED THE
* RIGHT POSITION OH THE LEFT SCAN IN THE SECONDARY
* WE ADD THE SIZES TOGETHER AND LEAVE THE TOTAL IN [X]
*
SCNCON STD    PCNT2    SAVE SIZE OF LEFT PIECE
       LDY    X2STOR   SAVE SECONDARY IN REGISTERS
       BSR    SAVLOC
       STY    XSTORE
       BSR    SCANR    SCAN RIGHT MAKING COUNT IN [D]
       LDX    PCNT2    GET SIZE OF PREVIOUS SCAN
       LEAX   D,X      COMBINE SIZE OF LEFT AND RIGHT
       ADDD   #&1      INCLUDE FIRST POINT IN LEFT IN SCAN SIZE
       RTS

*
* THESE ARE THE MOST IMPORTANT SCAN ROUTINES
* THEY SCAN EITHER LEFT OR RIGHT UNTIL THEY FIND A BORDER
* POINT OR THE EDGE. AS THEY SCAN THEY COLOR AND KEEP A POINT COUNT
* WHICH IS RETURNED IN [D]. XSTORE IS UPDATED AS THF SCAN PROCEEDS
* THE POINT VALUE RETURNED IN XSTORE IS EITHER AN EDGE OR BORDER
*
SCANL  JSR    SAVLOC
       LDY    #XDEC    SCAN LEFT DECREMENTS X AS IT GOES
       BRA    SCANLC
SCANR  LDY    #XINC    SCAN RIGHT INCREMENTS X
       JSR    ,Y
SCANLC LDU    DBLZER   SET COUNT VALUE TO 0
       LDX    XSTORE   START AT XSTORE
SCANLP BMI    SCLRTS   RETURN IF NEGATIVE 1 ALREADY
       CMPX   XMAX     SEE IF AT HIGH END
       BHI    SCLRTS   IF HIGHER MUST BE ON EDGE
       PSHS   U,Y      SAVE ROUTINE ADDRESS AND COUNT
       BSR    TSTBRD   SEE IF BORDER
       BEQ    SCLRT2   IF BORDER, QUIT
       JSR    GRPACT   SET THE COLOR AT THE DESIRED POINT
       PULS   U,Y      GET BACK COUNT AND ROUTINE ADDRESS
       LEAU   &1,U     UPDATE COUNT
       JSR    ,Y       UPDATE X VALUE
       BRA    SCANLP   AND CONTINUE SCANNING
SCLRT2 PULS   U,Y      TAKE OFF COUNT AND ADDRESS
SCLRTS TFR    U,D      MOVE COUNT INTO [D]
       TFR    D,X
       SUBD   DBLZER
RTSSCL RTS
TSTBRD JSR    [PNTADR] GET ADDRESS OF THIS POINT
       TFR    A,B      SET [B] TO BE A COPY OF THE BIT MASK
       ANDB   PNTCLR   MASK BORDER COLOR TO GET SELECTED BORDER BITS
       PSHS   D        SAVE THE BIT MASK IN [A]
       ANDA   ,X       READ CURRENT DATA IN AND MASK
       CMPA   &1,S     SEE IF MATCH BORDER COLOR
       PULS   D, PC    RETURN WITH CONDITION CODES SET

       TTL    MUSIC COMMAND

*
* PLAY
* TAKES A SINGLE STRING ARGUMENT WHICH IS THE "MUSIC MACRO LANGUAGE"
* THIS STRING DEFINES VOLUME, TEMPO, OCTAVE, NOTE, ETC AND ALLOWS
* EXECUTION OF SUBSTRINGS WITH X (EXECUTE)
* CURRENT FORM IS:
* O (OCTAVE) ARG 1-5
* V (VOLUME) ARG 0-31
* L (Length of note) ARG 1-255
* T (Tempo) ARG 1-255
* P (Pause) 1 to 255 (+, -, less than, greater than not allowed.)
* Notes A through G, with + or # for sharp, - for flat.
* Notes can also be specified as 1 through 12 with 1 being C.
* N preceding the note argument is optional.
* X (EXECUTE) STRING NAME;
* SEMICOLON, SPACE, AND SINGLEQUOTE ARE IGNORED
* ARG MEANS ONE OF:
* + (INCREMENT CURRENT VALUE BY ONE)
* - (DECREMENT CURRENT VALUE BY ONE)
* Right Angle Bracket (MULTIPLY CURRENT VALUE BY 2)
* Left Angle Bracket (DIVIDE CURRENT VALUE BY 2)
* =VAR NAME; (USE VARIABLE VALUE)
